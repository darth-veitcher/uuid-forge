{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"UUID-Forge Documentation","text":"<p>Deterministic UUID Generation for Cross-System Coordination</p> <p>Welcome to the UUID-Forge documentation! This library provides a simple, secure way to generate deterministic UUIDs that remain consistent across multiple storage systems without requiring inter-service communication or centralized ID generation.</p>"},{"location":"#what-is-uuid-forge","title":"What is UUID-Forge?","text":"<p>UUID-Forge solves a common problem in microservices and distributed systems: How do you maintain consistent entity identifiers across multiple storage systems?</p> <pre><code>from uuid_forge import generate_uuid_only, IDConfig\nimport os\n\n# Configure once\nconfig = IDConfig(salt=os.getenv(\"UUID_FORGE_SALT\"))\n\n# Generate UUID from business data\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\n# Later, regenerate the exact same UUID - no database needed!\nregenerated = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nassert invoice_uuid == regenerated  # Always True!\n</code></pre>"},{"location":"#core-principle","title":"Core Principle","text":"<p>Same Input + Same Config = Same UUID, Every Time</p> <p>This enables:</p> <ul> <li>\u2705 Zero coordination between services</li> <li>\u2705 Direct access to any storage system</li> <li>\u2705 No lookups required</li> <li>\u2705 Deterministic testing</li> <li>\u2705 Simple architecture</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running in minutes with our step-by-step guide.</p> <p>Get Started \u2192</p>"},{"location":"#user-guide","title":"\ud83d\udcda User Guide","text":"<p>Learn core concepts and best practices for production use.</p> <p>User Guide \u2192</p>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<p>Complete API documentation with examples and type signatures.</p> <p>API Reference \u2192</p>"},{"location":"#cli-reference","title":"\ud83d\udee0\ufe0f CLI Reference","text":"<p>Command-line interface for generating UUIDs and managing config.</p> <p>CLI Reference \u2192</p>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#microservices-architecture","title":"Microservices Architecture","text":"<p>Generate consistent IDs across multiple services without coordination:</p> <pre><code># Order Service\norder_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\n# Invoice Service (different codebase, same UUID!)\ninvoice_order_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\nassert order_uuid == invoice_order_uuid\n</code></pre>"},{"location":"#multi-storage-systems","title":"Multi-Storage Systems","text":"<p>Use the same UUID across all your storage layers:</p> <pre><code># Postgres\ndb.execute(\"INSERT INTO invoices (id, ...) VALUES (%s, ...)\", invoice_uuid)\n\n# S3\ns3.put_object(Key=f\"invoices/{invoice_uuid}.pdf\", ...)\n\n# Redis\nredis.set(f\"invoice:{invoice_uuid}\", ...)\n\n# All accessible with the same UUID!\n</code></pre>"},{"location":"#deterministic-testing","title":"Deterministic Testing","text":"<p>Reproduce exact UUIDs in tests for reliable assertions:</p> <pre><code>def test_invoice_processing():\n    test_config = IDConfig(salt=\"test-salt\")\n\n    # Known UUID for assertions\n    expected_uuid = generate_uuid_only(\n        \"invoice\",\n        config=test_config,\n        region=\"EUR\",\n        number=12345\n    )\n\n    # Test your code\n    result = process_invoice(region=\"EUR\", number=12345)\n\n    assert result.id == expected_uuid\n</code></pre>"},{"location":"#why-uuid-forge","title":"Why UUID-Forge?","text":"<p>Traditional approaches to cross-system ID coordination have significant drawbacks:</p> Approach Problems Central ID Service Single point of failure, latency, complexity Database Lookups Performance impact, requires database access ID Mappings Additional storage, synchronization challenges Random UUIDs No reproducibility, requires storage everywhere <p>UUID-Forge eliminates all of these problems with deterministic generation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd12 Secure: Cryptographic salt prevents UUID prediction</li> <li>\ud83c\udfaf Deterministic: Identical inputs always produce identical UUIDs</li> <li>\ud83d\ude80 Zero Coordination: No inter-service communication needed</li> <li>\ud83d\udce6 Simple API: Functional-first with optional OO wrapper</li> <li>\ud83d\udd27 Production Ready: Type-safe, tested, documented</li> <li>\ud83c\udfa8 CLI Included: First-class command-line interface</li> <li>\ud83d\udc0d Modern Python: Requires Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># With uv (recommended)\nuv add uuid-forge\n\n# With pip\npip install uuid-forge\n</code></pre> <p>Learn more \u2192</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ol> <li>Install UUID-Forge</li> <li>Follow the Quick Start guide</li> <li>Learn core concepts</li> <li>Explore use cases</li> </ol>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Contributing: Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>UUID-Forge is released under the MIT License. See License for details.</p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to UUID-Forge will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Initial implementation of deterministic UUID generation</li> <li>Support for UUID versions 3, 4, and 5</li> <li>Comprehensive configuration system</li> <li>Command-line interface with full feature support</li> <li>Cross-platform compatibility</li> <li>Extensive documentation and examples</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#deprecated","title":"Deprecated","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#removed","title":"Removed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#010-2024-01-15","title":"[0.1.0] - 2024-01-15","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li> <p>Core UUID Generation</p> </li> <li> <p>Deterministic UUID generation from various input types</p> </li> <li>Support for strings, dictionaries, and custom objects</li> <li>Configurable namespace support for entity isolation</li> <li> <p>Multiple UUID versions (3, 4, 5) with version 5 as default</p> </li> <li> <p>Configuration System</p> </li> <li> <p>Environment variable configuration support</p> </li> <li>Configuration file support (YAML/JSON)</li> <li>Hierarchical configuration with precedence rules</li> <li> <p>Runtime configuration validation</p> </li> <li> <p>Command-Line Interface</p> </li> <li> <p>Full-featured CLI with typer and rich for enhanced UX</p> </li> <li>Batch processing capabilities</li> <li>Multiple output formats (hex, urn, bytes)</li> <li>Configuration management commands</li> <li> <p>UUID validation and verification tools</p> </li> <li> <p>Developer Experience</p> </li> <li> <p>Comprehensive type hints throughout codebase</p> </li> <li>Extensive test suite with &gt;95% coverage</li> <li>Pre-commit hooks for code quality</li> <li>Detailed documentation with MkDocs</li> <li> <p>Performance benchmarks and optimization</p> </li> <li> <p>Documentation</p> </li> <li>Getting started guide with quick setup</li> <li>Comprehensive API reference</li> <li>Use case examples for microservices, multi-storage, testing</li> <li>Best practices and optimization guides</li> <li>CLI reference with all commands and options</li> </ul>"},{"location":"about/changelog/#technical-implementation","title":"Technical Implementation","text":"<ul> <li>Core Architecture: Clean separation between core logic, configuration, and CLI</li> <li>Type Safety: Full type annotations with mypy validation</li> <li>Testing: Unit tests, integration tests, and property-based testing</li> <li>Performance: Optimized for both single UUID generation and batch processing</li> <li>Security: Secure random salt generation and validation</li> <li>Compatibility: Python 3.11+ support with backwards compatibility considerations</li> </ul>"},{"location":"about/changelog/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Linting: Black, isort, ruff for code formatting and linting</li> <li>Type Checking: mypy for static type analysis</li> <li>Testing: pytest with coverage reporting</li> <li>Documentation: MkDocs with material theme and API documentation</li> <li>CI/CD: GitHub Actions for automated testing and deployment</li> </ul>"},{"location":"about/changelog/#template-for-future-releases","title":"Template for Future Releases","text":"<p>Use this template when creating new changelog entries:</p> <pre><code>## [X.Y.Z] - YYYY-MM-DD\n\n### Added\n\n- New features and functionality\n\n### Changed\n\n- Changes to existing functionality\n\n### Deprecated\n\n- Features marked for removal in future versions\n\n### Removed\n\n- Features removed in this version\n\n### Fixed\n\n- Bug fixes\n\n### Security\n\n- Security-related changes\n</code></pre>"},{"location":"about/changelog/#change-categories","title":"Change Categories","text":"<ul> <li>Added: New features</li> <li>Changed: Changes in existing functionality</li> <li>Deprecated: Soon-to-be removed features</li> <li>Removed: Now removed features</li> <li>Fixed: Any bug fixes</li> <li>Security: Security improvements or fixes</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>UUID-Forge is released under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2024 Darth Veitcher</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>UUID-Forge depends on several third-party packages, each with their own licenses:</p>"},{"location":"about/license/#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>Python Standard Library: Python Software Foundation License</li> <li>typing_extensions (if Python &lt; 3.11): Python Software Foundation License</li> </ul>"},{"location":"about/license/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>pytest: MIT License</li> <li>black: MIT License</li> <li>ruff: MIT License</li> <li>mypy: MIT License</li> <li>coverage: Apache License 2.0</li> <li>pre-commit: MIT License</li> <li>typer: MIT License</li> <li>rich: MIT License</li> </ul>"},{"location":"about/license/#documentation-dependencies","title":"Documentation Dependencies","text":"<ul> <li>mkdocs: BSD License</li> <li>mkdocs-material: MIT License</li> <li>mkdocstrings: ISC License</li> </ul>"},{"location":"about/license/#license-compatibility","title":"License Compatibility","text":"<p>The MIT License is:</p> <ul> <li>Permissive: Allows commercial and private use</li> <li>Compatible: Works with most other licenses</li> <li>Simple: Minimal restrictions and requirements</li> <li>Popular: Widely adopted in the Python ecosystem</li> </ul>"},{"location":"about/license/#using-uuid-forge-in-your-project","title":"Using UUID-Forge in Your Project","text":"<p>You can freely use UUID-Forge in your projects, whether:</p> <ul> <li>Open source: Include the license in your project</li> <li>Commercial: No additional requirements beyond attribution</li> <li>Private: Use internally without restrictions</li> <li>Modified: Create derivative works with attribution</li> </ul>"},{"location":"about/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>When using UUID-Forge, you must:</p> <ol> <li>Include the license: Keep the MIT license text in your distribution</li> <li>Include copyright notice: Maintain the copyright notice</li> <li>No trademark use: Don't use UUID-Forge name without permission</li> </ol>"},{"location":"about/license/#warranty-disclaimer","title":"Warranty Disclaimer","text":"<p>UUID-Forge is provided \"as is\" without warranty of any kind. The authors are not liable for any damages arising from the use of this software.</p>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to UUID-Forge, you agree that your contributions will be licensed under the same MIT License that covers the project.</p> <p>For more information about contributing, see Contributing Guide.</p>"},{"location":"api/cli/","title":"CLI API Reference","text":"<p>Complete API reference for UUID-Forge command-line interface.</p>"},{"location":"api/cli/#overview","title":"Overview","text":"<p>The UUID-Forge CLI provides command-line access to all core functionality including UUID generation, configuration management, and security validation.</p>"},{"location":"api/cli/#cli-module-reference","title":"CLI Module Reference","text":""},{"location":"api/cli/#uuid_forge.cli","title":"uuid_forge.cli","text":"<p>Command-line interface for UUID-Forge.</p> <p>This module provides a comprehensive CLI for generating deterministic UUIDs, managing configuration, and validating security settings. The CLI is designed as a first-class interface to the library, suitable for both interactive use and automation in scripts and CI/CD pipelines.</p> <p>Functions:</p> Name Description <code>generate</code> <p>Generate a deterministic UUID for an entity.</p> <code>extract</code> <p>Extract the UUID from a prefixed identifier.</p> <code>new_salt</code> <p>Generate a new cryptographic salt for UUID generation.</p> <code>init</code> <p>Initialize a new configuration file with generated salt.</p> <code>validate</code> <p>Validate current configuration for security best practices.</p> <code>info</code> <p>Display information about current configuration and usage.</p> <code>docs</code> <p>Build or serve the documentation locally.</p> <code>test</code> <p>Run the test suite with pytest.</p> <p>Attributes:</p> Name Type Description <code>app</code>"},{"location":"api/cli/#uuid_forge.cli-attributes","title":"Attributes","text":""},{"location":"api/cli/#uuid_forge.cli.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = Typer(\n    name=\"uuid-forge\",\n    help=\"Deterministic UUID generation for cross-system coordination\",\n    add_completion=False,\n)\n</code></pre>"},{"location":"api/cli/#uuid_forge.cli-functions","title":"Functions","text":""},{"location":"api/cli/#uuid_forge.cli.generate","title":"generate","text":"<pre><code>generate(\n    entity_type=Argument(\n        ..., help=\"Type of entity (e.g., 'invoice', 'order', 'user')\"\n    ),\n    prefix=Option(\n        None, \"--prefix\", \"-p\", help=\"Human-readable prefix for the UUID\"\n    ),\n    separator=Option(\n        \"-\", \"--separator\", \"-s\", help=\"Separator between prefix and UUID\"\n    ),\n    namespace=Option(\n        None,\n        \"--namespace\",\n        \"-n\",\n        help=\"Custom namespace domain (e.g., 'mycompany.com')\",\n    ),\n    salt=Option(\n        None, \"--salt\", help=\"Cryptographic salt (leave empty to use env var)\"\n    ),\n    use_env=Option(\n        True,\n        \"--env/--no-env\",\n        help=\"Load configuration from environment variables\",\n    ),\n    attributes=Option(\n        None,\n        \"--attr\",\n        \"-a\",\n        help=\"Attributes in key=value format (can be used multiple times)\",\n    ),\n)\n</code></pre> <p>Generate a deterministic UUID for an entity.</p> <p>This command generates a UUID that will be identical for the same inputs and configuration. Perfect for coordinating IDs across multiple storage systems (Postgres, S3, Redis, etc.) without requiring inter-service communication.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.generate--simple-generation-with-environment-config","title":"Simple generation with environment config","text":"<p>$ uuid-forge generate invoice --attr region=EUR --attr number=12345</p>"},{"location":"api/cli/#uuid_forge.cli.generate--with-human-readable-prefix","title":"With human-readable prefix","text":"<p>$ uuid-forge generate invoice --prefix INV-EUR --attr region=EUR --attr number=12345</p>"},{"location":"api/cli/#uuid_forge.cli.generate--custom-namespace-and-salt","title":"Custom namespace and salt","text":"<p>$ uuid-forge generate user --namespace mycompany.com --salt \"my-secret\" --attr email=user@example.com</p>"},{"location":"api/cli/#uuid_forge.cli.generate--using-environment-variables-only","title":"Using environment variables only","text":"<p>$ export UUID_FORGE_SALT=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\" $ export UUID_FORGE_NAMESPACE=\"mycompany.com\" $ uuid-forge generate invoice --attr region=EUR --attr number=12345</p>"},{"location":"api/cli/#uuid_forge.cli.extract","title":"extract","text":"<pre><code>extract(\n    prefixed_id=Argument(..., help=\"Prefixed UUID to extract from\"),\n    separator=Option(\n        \"-\", \"--separator\", \"-s\", help=\"Separator between prefix and UUID\"\n    ),\n)\n</code></pre> <p>Extract the UUID from a prefixed identifier.</p> <p>This command parses a prefixed UUID (created with --prefix option) and extracts just the UUID portion. Useful for database queries or API calls that require the pure UUID.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.extract--extract-from-prefixed-uuid","title":"Extract from prefixed UUID","text":"<p>$ uuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"</p>"},{"location":"api/cli/#uuid_forge.cli.extract--with-custom-separator","title":"With custom separator","text":"<p>$ uuid-forge extract \"INV_EUR_550e8400-e29b-41d4-a716-446655440000\" --separator \"_\"</p>"},{"location":"api/cli/#uuid_forge.cli.new_salt","title":"new_salt","text":"<pre><code>new_salt(\n    length=Option(\n        32, \"--length\", \"-l\", help=\"Length of salt in bytes (minimum 16)\"\n    ),\n)\n</code></pre> <p>Generate a new cryptographic salt for UUID generation.</p> <p>This command creates a secure random salt that should be used in production environments. The salt should be generated once per deployment and stored securely in environment variables or secret management systems.</p> <p>WARNING: Keep the salt secret! Anyone with the salt can predict your UUIDs.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.new_salt--generate-standard-32-byte-salt","title":"Generate standard 32-byte salt","text":"<p>$ uuid-forge new-salt</p>"},{"location":"api/cli/#uuid_forge.cli.new_salt--generate-longer-salt-for-extra-security","title":"Generate longer salt for extra security","text":"<p>$ uuid-forge new-salt --length 64</p>"},{"location":"api/cli/#uuid_forge.cli.init","title":"init","text":"<pre><code>init(\n    output=Option(\n        Path(\".env\"),\n        \"--output\",\n        \"-o\",\n        help=\"Output path for configuration file\",\n    ),\n    force=Option(False, \"--force\", \"-f\", help=\"Overwrite existing file\"),\n)\n</code></pre> <p>Initialize a new configuration file with generated salt.</p> <p>This command creates a template configuration file (.env format) with a freshly generated salt and usage instructions. Perfect for setting up new projects or deployments.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.init--create-env-in-current-directory","title":"Create .env in current directory","text":"<p>$ uuid-forge init</p>"},{"location":"api/cli/#uuid_forge.cli.init--create-in-custom-location","title":"Create in custom location","text":"<p>$ uuid-forge init --output config/uuid.env</p>"},{"location":"api/cli/#uuid_forge.cli.init--overwrite-existing-file","title":"Overwrite existing file","text":"<p>$ uuid-forge init --force</p>"},{"location":"api/cli/#uuid_forge.cli.validate","title":"validate","text":"<pre><code>validate(strict=Option(False, '--strict', help='Treat warnings as errors'))\n</code></pre> <p>Validate current configuration for security best practices.</p> <p>This command checks your current configuration (loaded from environment variables) against security best practices. Use this in CI/CD pipelines to ensure production deployments have secure configurations.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.validate--validate-current-config","title":"Validate current config","text":"<p>$ uuid-forge validate</p>"},{"location":"api/cli/#uuid_forge.cli.validate--strict-mode-warnings-cause-failure","title":"Strict mode (warnings cause failure)","text":"<p>$ uuid-forge validate --strict</p>"},{"location":"api/cli/#uuid_forge.cli.info","title":"info","text":"<pre><code>info()\n</code></pre> <p>Display information about current configuration and usage.</p> <p>This command shows the current configuration loaded from environment variables, system information, and usage examples. Useful for debugging configuration issues.</p>"},{"location":"api/cli/#uuid_forge.cli.docs","title":"docs","text":"<pre><code>docs(\n    serve=Option(\n        True,\n        \"--serve/--build\",\n        help=\"Serve docs with live reload or just build\",\n    ),\n    host=Option(\"127.0.0.1\", \"--host\", \"-h\", help=\"Host to serve on\"),\n    port=Option(8000, \"--port\", \"-p\", help=\"Port to serve on\"),\n    open_browser=Option(\n        True, \"--open/--no-open\", help=\"Open browser automatically\"\n    ),\n)\n</code></pre> <p>Build or serve the documentation locally.</p> <p>This command builds the MkDocs documentation and optionally serves it with live reload. Perfect for local development and documentation preview. No Docker required!</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.docs--serve-docs-with-live-reload-default","title":"Serve docs with live reload (default)","text":"<p>$ uuid-forge docs</p>"},{"location":"api/cli/#uuid_forge.cli.docs--serve-on-different-port","title":"Serve on different port","text":"<p>$ uuid-forge docs --port 8080</p>"},{"location":"api/cli/#uuid_forge.cli.docs--build-without-serving","title":"Build without serving","text":"<p>$ uuid-forge docs --build</p>"},{"location":"api/cli/#uuid_forge.cli.docs--serve-on-all-interfaces","title":"Serve on all interfaces","text":"<p>$ uuid-forge docs --host 0.0.0.0 --port 8000</p>"},{"location":"api/cli/#uuid_forge.cli.test","title":"test","text":"<pre><code>test(\n    coverage=Option(\n        True, \"--coverage/--no-coverage\", help=\"Run with coverage reporting\"\n    ),\n    verbose=Option(False, \"--verbose\", \"-v\", help=\"Verbose test output\"),\n    pattern=Option(\n        None, \"--pattern\", \"-k\", help=\"Only run tests matching pattern\"\n    ),\n    fail_fast=Option(\n        False, \"--fail-fast\", \"-x\", help=\"Stop on first test failure\"\n    ),\n    parallel=Option(False, \"--parallel\", \"-n\", help=\"Run tests in parallel\"),\n)\n</code></pre> <p>Run the test suite with pytest.</p> <p>This command runs the project's test suite using pytest with various options for coverage, verbosity, and test selection. Perfect for local development and CI/CD pipelines.</p> <p>Examples:</p>"},{"location":"api/cli/#uuid_forge.cli.test--run-all-tests-with-coverage-default","title":"Run all tests with coverage (default)","text":"<p>$ uuid-forge test</p>"},{"location":"api/cli/#uuid_forge.cli.test--run-tests-without-coverage","title":"Run tests without coverage","text":"<p>$ uuid-forge test --no-coverage</p>"},{"location":"api/cli/#uuid_forge.cli.test--run-specific-test-pattern","title":"Run specific test pattern","text":"<p>$ uuid-forge test --pattern \"test_core\"</p>"},{"location":"api/cli/#uuid_forge.cli.test--verbose-output-and-fail-fast","title":"Verbose output and fail fast","text":"<p>$ uuid-forge test --verbose --fail-fast</p>"},{"location":"api/cli/#commands","title":"Commands","text":""},{"location":"api/cli/#generate","title":"generate","text":"<p>Generate a deterministic UUID for an entity.</p> <p>Signature: <pre><code>def generate(\n    entity_type: str,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    namespace: str | None = None,\n    salt: str | None = None,\n    use_env: bool = True,\n    attributes: list[str] | None = None,\n) -&gt; None\n</code></pre></p> <p>Arguments: - <code>entity_type</code> - Type of entity (e.g., 'invoice', 'order', 'user') [required]</p> <p>Options: - <code>--prefix, -p</code> - Human-readable prefix for the UUID - <code>--separator, -s</code> - Separator between prefix and UUID (default: -) - <code>--namespace, -n</code> - Custom namespace domain - <code>--salt</code> - Cryptographic salt - <code>--env/--no-env</code> - Load configuration from environment variables (default: True) - <code>--attr, -a</code> - Attributes in key=value format (repeatable)</p> <p>Example: <pre><code>uuid-forge generate invoice --attr region=EUR --attr number=12345\n</code></pre></p>"},{"location":"api/cli/#extract","title":"extract","text":"<p>Extract the UUID portion from a prefixed identifier.</p> <p>Signature: <pre><code>def extract(\n    prefixed_id: str\n) -&gt; None\n</code></pre></p> <p>Arguments: - <code>prefixed_id</code> - Prefixed identifier (e.g., \"INV-EUR-550e8400-...\") [required]</p> <p>Example: <pre><code>uuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n</code></pre></p>"},{"location":"api/cli/#new-salt","title":"new-salt","text":"<p>Generate a new cryptographically secure salt.</p> <p>Signature: <pre><code>def new_salt() -&gt; None\n</code></pre></p> <p>Example: <pre><code>uuid-forge new-salt\n</code></pre></p>"},{"location":"api/cli/#init","title":"init","text":"<p>Initialize a new configuration file with generated salt.</p> <p>Signature: <pre><code>def init(\n    file: str | None = None,\n    force: bool = False\n) -&gt; None\n</code></pre></p> <p>Options: - <code>--file, -f</code> - Configuration file path (default: .env) - <code>--force</code> - Overwrite existing file</p> <p>Example: <pre><code>uuid-forge init --file .env.production\n</code></pre></p>"},{"location":"api/cli/#validate","title":"validate","text":"<p>Validate current configuration for security best practices.</p> <p>Signature: <pre><code>def validate() -&gt; None\n</code></pre></p> <p>Example: <pre><code>uuid-forge validate\n</code></pre></p>"},{"location":"api/cli/#info","title":"info","text":"<p>Display information about current configuration and usage.</p> <p>Signature: <pre><code>def info() -&gt; None\n</code></pre></p> <p>Example: <pre><code>uuid-forge info\n</code></pre></p>"},{"location":"api/cli/#docs","title":"docs","text":"<p>Build or serve the documentation locally.</p> <p>Signature: <pre><code>def docs(\n    command: str = \"serve\"\n) -&gt; None\n</code></pre></p> <p>Arguments: - <code>command</code> - Either 'serve' or 'build' (default: serve)</p> <p>Example: <pre><code>uuid-forge docs serve\nuuid-forge docs build\n</code></pre></p>"},{"location":"api/cli/#test","title":"test","text":"<p>Run the test suite with pytest.</p> <p>Signature: <pre><code>def test(\n    args: list[str] | None = None\n) -&gt; None\n</code></pre></p> <p>Arguments: - <code>args</code> - Additional pytest arguments (optional)</p> <p>Example: <pre><code>uuid-forge test\nuuid-forge test --cov\n</code></pre></p>"},{"location":"api/cli/#environment-variables","title":"Environment Variables","text":"<p>The CLI respects the following environment variables:</p> Variable Type Description <code>UUID_FORGE_SALT</code> str Cryptographic salt for UUID generation <code>UUID_FORGE_NAMESPACE</code> str Default namespace domain"},{"location":"api/cli/#exit-codes","title":"Exit Codes","text":"Code Meaning 0 Success 1 Error (invalid input, missing configuration, etc.) 2 Validation failure"},{"location":"api/cli/#integration-with-python-api","title":"Integration with Python API","text":"<p>The CLI is built on top of the core Python API. All functionality available via CLI is also available programmatically:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid_forge.core import generate_salt, generate_uuid_with_prefix\nfrom uuid_forge.config import init_config_file, validate_config_security\n\n# Generate salt (equivalent to: uuid-forge new-salt)\nsalt = generate_salt()\n\n# Generate UUID (equivalent to: uuid-forge generate)\nconfig = IDConfig(namespace=Namespace(\"myapp.com\"), salt=salt)\ngenerator = UUIDGenerator(config)\nuuid = generator.generate(\"user\", email=\"alice@example.com\")\n\n# With prefix (equivalent to: uuid-forge generate --prefix)\nprefixed = generate_uuid_with_prefix(\n    entity_type=\"invoice\",\n    prefix=\"INV-EUR\",\n    namespace=Namespace(\"myapp.com\"),\n    salt=salt,\n    region=\"EUR\",\n    number=12345\n)\n</code></pre>"},{"location":"api/cli/#see-also","title":"See Also","text":"<ul> <li>CLI User Guide - Practical CLI usage examples</li> <li>Configuration Guide - Environment setup</li> <li>Core API Reference - Python API documentation</li> </ul>"},{"location":"api/config/","title":"IDConfig API Reference","text":"<p>Complete reference for UUID-Forge configuration system.</p>"},{"location":"api/config/#configuration-management","title":"Configuration Management","text":"<p>The configuration system in UUID-Forge provides utilities for loading and managing UUID generation settings.</p>"},{"location":"api/config/#configuration-methods","title":"Configuration Methods","text":""},{"location":"api/config/#load-configuration","title":"Load Configuration","text":"<p>Load configuration from various sources:</p> <pre><code>from uuid_forge.config import load_config_from_env\nfrom uuid_forge.core import IDConfig\n\n# Load from environment variables\nconfig = load_config_from_env()\n\n# Create configuration directly\nconfig = IDConfig(namespace=\"my-app\", salt=\"custom-salt\")\n</code></pre>"},{"location":"api/config/#validation","title":"Validation","text":"<p>Configuration is automatically validated:</p> <pre><code># Valid configuration\nconfig = IDConfig(\n    namespace=\"my-app\",\n    salt=\"custom-salt\"\n)\n\n# Invalid configuration raises ValueError\ntry:\n    config = IDConfig(namespace=\"invalid-uuid-string\")  # Invalid namespace\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"api/config/#configuration-options","title":"Configuration Options","text":""},{"location":"api/config/#core-settings","title":"Core Settings","text":"Option Type Default Description <code>namespace</code> <code>str</code> or <code>UUID</code> <code>None</code> Default namespace for UUID generation <code>version</code> <code>int</code> <code>5</code> UUID version (3, 4, or 5) <code>format</code> <code>str</code> <code>\"hex\"</code> Output format (<code>hex</code>, <code>urn</code>, <code>bytes</code>) <code>case</code> <code>str</code> <code>\"lower\"</code> Case for hex output (<code>upper</code>, <code>lower</code>) <code>separator</code> <code>str</code> <code>\"-\"</code> Separator character for hex format"},{"location":"api/config/#advanced-settings","title":"Advanced Settings","text":"Option Type Default Description <code>seed</code> <code>int</code> <code>None</code> Random seed for reproducible generation <code>clock_seq</code> <code>int</code> <code>None</code> Clock sequence for version 1 UUIDs <code>node</code> <code>int</code> <code>None</code> Node ID for version 1 UUIDs <code>json_encoder</code> <code>JSONEncoder</code> <code>None</code> Custom JSON encoder for object serialization"},{"location":"api/config/#configuration-file-format","title":"Configuration File Format","text":""},{"location":"api/config/#yaml-configuration","title":"YAML Configuration","text":"<pre><code># uuid_forge.yaml\nnamespace: \"my-application\"\nversion: 5\nformat: \"hex\"\ncase: \"lower\"\nseparator: \"-\"\n\n# Custom namespaces\nnamespaces:\n  users: \"550e8400-e29b-41d4-a716-446655440000\"\n  orders: \"550e8400-e29b-41d4-a716-446655440001\"\n  products: \"550e8400-e29b-41d4-a716-446655440002\"\n\n# Environment-specific settings\nenvironments:\n  development:\n    namespace: \"dev-app\"\n    seed: 12345\n  production:\n    namespace: \"prod-app\"\n    seed: null\n</code></pre>"},{"location":"api/config/#json-configuration","title":"JSON Configuration","text":"<pre><code>{\n  \"namespace\": \"my-application\",\n  \"version\": 5,\n  \"format\": \"hex\",\n  \"case\": \"lower\",\n  \"separator\": \"-\",\n  \"namespaces\": {\n    \"users\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"orders\": \"550e8400-e29b-41d4-a716-446655440001\"\n  }\n}\n</code></pre>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Configuration via environment variables:</p> Variable Description Example <code>UUID_FORGE_NAMESPACE</code> Default namespace <code>my-app</code> <code>UUID_FORGE_VERSION</code> UUID version <code>5</code> <code>UUID_FORGE_FORMAT</code> Output format <code>hex</code> <code>UUID_FORGE_CASE</code> Case for hex output <code>lower</code> <code>UUID_FORGE_SEPARATOR</code> Separator character <code>-</code> <code>UUID_FORGE_CONFIG_FILE</code> Configuration file path <code>/path/to/config.yaml</code>"},{"location":"api/config/#examples","title":"Examples","text":""},{"location":"api/config/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from uuid_forge import IDConfig, UUIDGenerator\n\n# Simple configuration\nconfig = IDConfig(\n    namespace=\"my-app\",\n    version=5\n)\n\nforge = UUIDGenerator(config)\nuuid_result = forge.generate(\"test\")\n</code></pre>"},{"location":"api/config/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>import json\nfrom datetime import datetime\n\nclass CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        return super().default(obj)\n\nconfig = IDConfig(\n    namespace=\"advanced-app\",\n    version=5,\n    format=\"hex\",\n    case=\"upper\",\n    separator=\"\",\n    json_encoder=CustomJSONEncoder\n)\n\nforge = UUIDGenerator(config)\n</code></pre>"},{"location":"api/config/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<pre><code>import os\n\ndef create_config():\n    env = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if env == \"production\":\n        return IDConfig(\n            namespace=\"prod-app\",\n            version=5,\n            format=\"hex\"\n        )\n    else:\n        return IDConfig(\n            namespace=\"dev-app\",\n            version=5,\n            format=\"hex\",\n            seed=12345  # Consistent for testing\n        )\n\nconfig = create_config()\nforge = UUIDGenerator(config)\n</code></pre>"},{"location":"api/config/#configuration-inheritance","title":"Configuration Inheritance","text":"<pre><code># Base configuration\nbase_config = IDConfig(\n    version=5,\n    format=\"hex\",\n    case=\"lower\"\n)\n\n# Service-specific configurations\nuser_config = IDConfig(\n    namespace=\"users\",\n    **base_config.to_dict()\n)\n\norder_config = IDConfig(\n    namespace=\"orders\",\n    **base_config.to_dict()\n)\n</code></pre>"},{"location":"api/config/#validation-rules","title":"Validation Rules","text":""},{"location":"api/config/#namespace-validation","title":"Namespace Validation","text":"<ul> <li>Must be a valid UUID string or UUID object</li> <li>Empty string is converted to <code>None</code></li> <li>Invalid UUID strings raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#version-validation","title":"Version Validation","text":"<ul> <li>Must be 3, 4, or 5</li> <li>Other values raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#format-validation","title":"Format Validation","text":"<ul> <li>Must be one of: <code>\"hex\"</code>, <code>\"urn\"</code>, <code>\"bytes\"</code></li> <li>Case-insensitive matching</li> <li>Invalid formats raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#case-validation","title":"Case Validation","text":"<ul> <li>Must be one of: <code>\"upper\"</code>, <code>\"lower\"</code></li> <li>Case-insensitive matching</li> <li>Invalid cases raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#configuration-precedence","title":"Configuration Precedence","text":"<p>Configuration is loaded in order of precedence:</p> <ol> <li>Explicit parameters - Passed to <code>IDConfig()</code> constructor</li> <li>Configuration file - Loaded from file path</li> <li>Environment variables - System environment</li> <li>Default values - Built-in defaults</li> </ol>"},{"location":"api/config/#error-handling","title":"Error Handling","text":"<pre><code>from uuid_forge.config import IDConfig, ConfigError\n\ntry:\n    config = IDConfig.load_from_file(\"invalid_config.yaml\")\nexcept ConfigError as e:\n    print(f\"Configuration error: {e}\")\nexcept FileNotFoundError:\n    print(\"Configuration file not found\")\n</code></pre>"},{"location":"api/config/#migration-and-compatibility","title":"Migration and Compatibility","text":""},{"location":"api/config/#version-migration","title":"Version Migration","text":"<pre><code>def migrate_config_v1_to_v2(old_config_dict):\n    \"\"\"Migrate configuration from v1 to v2 format\"\"\"\n    new_config = {}\n\n    # Map old keys to new keys\n    key_mapping = {\n        \"uuid_namespace\": \"namespace\",\n        \"uuid_version\": \"version\",\n        \"output_format\": \"format\"\n    }\n\n    for old_key, new_key in key_mapping.items():\n        if old_key in old_config_dict:\n            new_config[new_key] = old_config_dict[old_key]\n\n    return IDConfig(**new_config)\n</code></pre>"},{"location":"api/config/#backward-compatibility","title":"Backward Compatibility","text":"<p>UUID-Forge maintains backward compatibility for configuration:</p> <pre><code># Old style (still supported)\nconfig = IDConfig(\n    uuid_namespace=\"my-app\",  # Deprecated\n    uuid_version=5           # Deprecated\n)\n\n# New style (recommended)\nconfig = IDConfig(\n    namespace=\"my-app\",\n    version=5\n)\n</code></pre>"},{"location":"api/config/#testing-configuration","title":"Testing Configuration","text":"<pre><code>import pytest\nfrom uuid_forge.config import IDConfig\n\ndef test_config_validation():\n    \"\"\"Test configuration validation\"\"\"\n    # Valid configuration\n    config = IDConfig(namespace=\"test\", version=5)\n    assert config.namespace == \"test\"\n    assert config.version == 5\n\n    # Invalid version\n    with pytest.raises(ValueError):\n        IDConfig(version=99)\n\n    # Invalid format\n    with pytest.raises(ValueError):\n        IDConfig(format=\"invalid\")\n\ndef test_config_loading():\n    \"\"\"Test configuration loading from various sources\"\"\"\n    # From dict\n    config_dict = {\"namespace\": \"test\", \"version\": 5}\n    config = IDConfig(**config_dict)\n\n    # From environment (mock)\n    import os\n    os.environ[\"UUID_FORGE_NAMESPACE\"] = \"env-test\"\n    config = IDConfig.load_from_env()\n    assert config.namespace == \"env-test\"\n</code></pre>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core UUID generation functionality provided by <code>uuid_forge.core</code>.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The core module provides three main approaches to generating deterministic UUIDs:</p> <ol> <li>Functional API (recommended): Pure functions for UUID generation</li> <li>Object-Oriented API: Class-based wrapper for convenience</li> <li>Utility Functions: Helper functions for salt generation and UUID extraction</li> </ol>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#uuid_forge.core.IDConfig","title":"uuid_forge.core.IDConfig  <code>dataclass</code>","text":"<pre><code>IDConfig(namespace=NAMESPACE_DNS, salt='')\n</code></pre> <p>Configuration for deterministic UUID generation.</p> <p>This configuration ensures consistent UUID generation across different services and deployments. The namespace provides logical separation between different entity types or applications, while the salt adds security by preventing UUID prediction attacks.</p> <p>Attributes:</p> Name Type Description <code>namespace</code> <code>UUID | Namespace</code> <p>UUID namespace for generation. Can be a UUID object or a Namespace. Defaults to DNS-based namespace. For custom namespaces, use Namespace(\"domain.com\").</p> <code>salt</code> <code>str</code> <p>Random salt for security. CRITICAL: Keep this secret! Generate once per deployment and store securely in environment variables. Without a salt, UUIDs are predictable, which may be a security risk.</p> <p>Examples:</p> <pre><code>from uuid_forge.core import IDConfig, Namespace\n\n# Simple domain-based namespace\nconfig = IDConfig(\n    namespace=Namespace(\"mycompany.com\"),\n    salt=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\n)\n\n# Service-specific namespace\nconfig = IDConfig(\n    namespace=Namespace(\"users.mycompany.com\"),\n    salt=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\n)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; config = IDConfig(namespace=uuid.NAMESPACE_DNS, salt=\"test-salt\")\n&gt;&gt;&gt; config.namespace == uuid.NAMESPACE_DNS\nTrue\n&gt;&gt;&gt; config.salt == \"test-salt\"\nTrue\n&gt;&gt;&gt; # Test immutability - this should raise FrozenInstanceError\n&gt;&gt;&gt; config.salt = \"new-salt\"\nTraceback (most recent call last):\n...\nFrozenInstanceError: cannot assign to field 'salt'\n</code></pre> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Validate configuration after initialization.</p>"},{"location":"api/core/#uuid_forge.core.IDConfig-attributes","title":"Attributes","text":""},{"location":"api/core/#uuid_forge.core.IDConfig.namespace_uuid","title":"namespace_uuid  <code>property</code>","text":"<pre><code>namespace_uuid\n</code></pre> <p>Get the UUID representation of the namespace.</p>"},{"location":"api/core/#uuid_forge.core.IDConfig-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.IDConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    if not isinstance(self.namespace, uuid_module.UUID | Namespace):\n        raise TypeError(\n            f\"namespace must be a UUID or Namespace, got {type(self.namespace).__name__}\"\n        )\n</code></pre>"},{"location":"api/core/#primary-functions","title":"Primary Functions","text":""},{"location":"api/core/#generate_uuid_only","title":"generate_uuid_only","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_only","title":"uuid_forge.core.generate_uuid_only","text":"<pre><code>generate_uuid_only(entity_type, *args, config=None, **kwargs)\n</code></pre> <p>Generate a deterministic UUID from entity type and business data.</p> <p>This is the core function for generating idempotent UUIDs. Given the same inputs and configuration, it will always produce the same UUID. This enables zero-coordination ID generation across multiple services and storage systems.</p> <p>The function uses UUIDv5 (name-based, SHA-1) for deterministic generation, with an optional salt for security. The entity_type provides logical separation between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\"). This provides namespace separation between different entity types.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID. Can be any serializable data that uniquely identifies the entity.</p> <code>()</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt). IMPORTANT: In production, always provide a config with a salt for security.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID. Keys are sorted alphabetically to ensure consistency regardless of argument order.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID that will be identical for the same inputs and config.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\nimport uuid\nimport os\n\n# Production usage with config\nconfig = IDConfig(\n    namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n    salt=os.getenv(\"UUID_SALT\", \"\")\n)\n\n# Generate UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\n# Later, regenerate the same UUID from business data\nregenerated = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\nassert invoice_uuid == regenerated  # Always the same!\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_uuid_only, IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test basic generation\n&gt;&gt;&gt; uuid1 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Test idempotency\n&gt;&gt;&gt; uuid2 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid1 == uuid2  # Same inputs should produce same UUID\nTrue\n&gt;&gt;&gt; # Test with different inputs\n&gt;&gt;&gt; uuid3 = generate_uuid_only(\"test\", key=\"other\")\n&gt;&gt;&gt; uuid1 != uuid3  # Different inputs should produce different UUIDs\nTrue\n&gt;&gt;&gt; # Test with config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; uuid4 = generate_uuid_only(\"test\", key=\"value\", config=config)\n&gt;&gt;&gt; uuid5 = generate_uuid_only(\"test\", key=\"value\", config=config)\n&gt;&gt;&gt; uuid4 == uuid5  # Same config should produce same UUID\nTrue\n&gt;&gt;&gt; # Test that different config produces different UUID\n&gt;&gt;&gt; uuid6 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid4 != uuid6  # Different config should produce different UUID\nTrue\n&gt;&gt;&gt; # Test kwargs order doesn't matter\n&gt;&gt;&gt; uuid7 = generate_uuid_only(\"test\", a=1, b=2)\n&gt;&gt;&gt; uuid8 = generate_uuid_only(\"test\", b=2, a=1)\n&gt;&gt;&gt; uuid7 == uuid8  # Kwargs order shouldn't matter\nTrue\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_only(\n    entity_type: str, *args: Any, config: IDConfig | None = None, **kwargs: Any\n) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID from entity type and business data.\n\n    This is the core function for generating idempotent UUIDs. Given the same\n    inputs and configuration, it will always produce the same UUID. This enables\n    zero-coordination ID generation across multiple services and storage systems.\n\n    The function uses UUIDv5 (name-based, SHA-1) for deterministic generation,\n    with an optional salt for security. The entity_type provides logical separation\n    between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n            This provides namespace separation between different entity types.\n        *args: Positional arguments contributing to the UUID. Can be any\n            serializable data that uniquely identifies the entity.\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt). IMPORTANT: In production,\n            always provide a config with a salt for security.\n        **kwargs: Keyword arguments contributing to the UUID. Keys are sorted\n            alphabetically to ensure consistency regardless of argument order.\n\n    Returns:\n        A deterministic UUID that will be identical for the same inputs and config.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_only, IDConfig\n        import uuid\n        import os\n\n        # Production usage with config\n        config = IDConfig(\n            namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n            salt=os.getenv(\"UUID_SALT\", \"\")\n        )\n\n        # Generate UUID for an invoice\n        invoice_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        # Later, regenerate the same UUID from business data\n        regenerated = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        assert invoice_uuid == regenerated  # Always the same!\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_uuid_only, IDConfig\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; # Test basic generation\n        &gt;&gt;&gt; uuid1 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\n        True\n        &gt;&gt;&gt; # Test idempotency\n        &gt;&gt;&gt; uuid2 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; uuid1 == uuid2  # Same inputs should produce same UUID\n        True\n        &gt;&gt;&gt; # Test with different inputs\n        &gt;&gt;&gt; uuid3 = generate_uuid_only(\"test\", key=\"other\")\n        &gt;&gt;&gt; uuid1 != uuid3  # Different inputs should produce different UUIDs\n        True\n        &gt;&gt;&gt; # Test with config\n        &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n        &gt;&gt;&gt; uuid4 = generate_uuid_only(\"test\", key=\"value\", config=config)\n        &gt;&gt;&gt; uuid5 = generate_uuid_only(\"test\", key=\"value\", config=config)\n        &gt;&gt;&gt; uuid4 == uuid5  # Same config should produce same UUID\n        True\n        &gt;&gt;&gt; # Test that different config produces different UUID\n        &gt;&gt;&gt; uuid6 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; uuid4 != uuid6  # Different config should produce different UUID\n        True\n        &gt;&gt;&gt; # Test kwargs order doesn't matter\n        &gt;&gt;&gt; uuid7 = generate_uuid_only(\"test\", a=1, b=2)\n        &gt;&gt;&gt; uuid8 = generate_uuid_only(\"test\", b=2, a=1)\n        &gt;&gt;&gt; uuid7 == uuid8  # Kwargs order shouldn't matter\n        True\n    \"\"\"\n    if config is None:\n        config = IDConfig()\n    elif not isinstance(config, IDConfig):\n        raise TypeError(f\"config must be IDConfig, got {type(config).__name__}\")\n\n    # Build the name string from entity type, salt, and normalized inputs\n    parts = [entity_type]\n\n    if config.salt:\n        parts.append(f\"salt:{config.salt}\")\n\n    normalized = _normalize_input(*args, **kwargs)\n    if normalized:\n        parts.append(normalized)\n\n    name = \"|\".join(parts)\n\n    # Generate deterministic UUID\n    return uuid_module.uuid5(config.namespace_uuid, name)\n</code></pre>"},{"location":"api/core/#generate_uuid_with_prefix","title":"generate_uuid_with_prefix","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_with_prefix","title":"uuid_forge.core.generate_uuid_with_prefix","text":"<pre><code>generate_uuid_with_prefix(\n    entity_type, *args, prefix=None, separator=\"-\", config=None, **kwargs\n)\n</code></pre> <p>Generate a deterministic UUID with an optional human-readable prefix.</p> <p>This function extends generate_uuid_only by adding a human-readable prefix to the UUID. The prefix can be useful for: - Quick visual identification of entity types (e.g., \"INV-\" for invoices) - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices) - Making logs and debugging more human-friendly</p> <p>The prefix does NOT affect the UUID generation - it's purely cosmetic. The same business data will always produce the same UUID, regardless of prefix used.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\").</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID. If None, only the UUID is returned (as a string). Can include business context like region codes, year, or entity type abbreviations.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default config.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,</p> <code>str</code> <p>or just \"{uuid}\" if prefix is None.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_with_prefix, IDConfig\nimport os\n\nconfig = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n# With prefix\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Without prefix (just UUID as string)\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Custom separator\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    separator=\"_\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n&gt;&gt;&gt; # Test without prefix\n&gt;&gt;&gt; id1 = generate_uuid_with_prefix(\"test\", key=\"value\")\n&gt;&gt;&gt; \"-\" in id1  # Should be a UUID string\nTrue\n&gt;&gt;&gt; not id1.startswith(\"test\")  # No prefix\nTrue\n&gt;&gt;&gt; # Test with prefix\n&gt;&gt;&gt; id2 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; id2.startswith(\"TST-\")\nTrue\n&gt;&gt;&gt; # Test idempotency with prefix\n&gt;&gt;&gt; id3 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; id2 == id3  # Same inputs should produce same result\nTrue\n&gt;&gt;&gt; # Test that different prefixes don't change UUID part\n&gt;&gt;&gt; id4 = generate_uuid_with_prefix(\"test\", prefix=\"OTHER\", key=\"value\")\n&gt;&gt;&gt; uuid_part_2 = id2.split(\"-\", 1)[1]\n&gt;&gt;&gt; uuid_part_4 = id4.split(\"-\", 1)[1]\n&gt;&gt;&gt; uuid_part_2 == uuid_part_4  # UUID should be same regardless of prefix\nTrue\n&gt;&gt;&gt; # Test custom separator\n&gt;&gt;&gt; id5 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n&gt;&gt;&gt; id5.startswith(\"TST_\")  # Should use custom separator\nTrue\n&gt;&gt;&gt; # Test with config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; id6 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n&gt;&gt;&gt; id7 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n&gt;&gt;&gt; id6 == id7  # Config should be applied consistently\nTrue\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_with_prefix(\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    config: IDConfig | None = None,\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with an optional human-readable prefix.\n\n    This function extends generate_uuid_only by adding a human-readable prefix\n    to the UUID. The prefix can be useful for:\n    - Quick visual identification of entity types (e.g., \"INV-\" for invoices)\n    - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices)\n    - Making logs and debugging more human-friendly\n\n    The prefix does NOT affect the UUID generation - it's purely cosmetic.\n    The same business data will always produce the same UUID, regardless of\n    prefix used.\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID. If None, only\n            the UUID is returned (as a string). Can include business context\n            like region codes, year, or entity type abbreviations.\n        separator: Character(s) to use between prefix and UUID. Default is \"-\".\n        config: Configuration for UUID generation. If None, uses default config.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,\n        or just \"{uuid}\" if prefix is None.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n        import os\n\n        config = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n        # With prefix\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Without prefix (just UUID as string)\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n        # Custom separator\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV\",\n            separator=\"_\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n        &gt;&gt;&gt; # Test without prefix\n        &gt;&gt;&gt; id1 = generate_uuid_with_prefix(\"test\", key=\"value\")\n        &gt;&gt;&gt; \"-\" in id1  # Should be a UUID string\n        True\n        &gt;&gt;&gt; not id1.startswith(\"test\")  # No prefix\n        True\n        &gt;&gt;&gt; # Test with prefix\n        &gt;&gt;&gt; id2 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; id2.startswith(\"TST-\")\n        True\n        &gt;&gt;&gt; # Test idempotency with prefix\n        &gt;&gt;&gt; id3 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; id2 == id3  # Same inputs should produce same result\n        True\n        &gt;&gt;&gt; # Test that different prefixes don't change UUID part\n        &gt;&gt;&gt; id4 = generate_uuid_with_prefix(\"test\", prefix=\"OTHER\", key=\"value\")\n        &gt;&gt;&gt; uuid_part_2 = id2.split(\"-\", 1)[1]\n        &gt;&gt;&gt; uuid_part_4 = id4.split(\"-\", 1)[1]\n        &gt;&gt;&gt; uuid_part_2 == uuid_part_4  # UUID should be same regardless of prefix\n        True\n        &gt;&gt;&gt; # Test custom separator\n        &gt;&gt;&gt; id5 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n        &gt;&gt;&gt; id5.startswith(\"TST_\")  # Should use custom separator\n        True\n        &gt;&gt;&gt; # Test with config\n        &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n        &gt;&gt;&gt; id6 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n        &gt;&gt;&gt; id7 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n        &gt;&gt;&gt; id6 == id7  # Config should be applied consistently\n        True\n    \"\"\"\n    generated_uuid = generate_uuid_only(entity_type, *args, config=config, **kwargs)\n    uuid_str = str(generated_uuid)\n\n    if prefix:\n        return f\"{prefix}{separator}{uuid_str}\"\n    return uuid_str\n</code></pre>"},{"location":"api/core/#extract_uuid_from_prefixed","title":"extract_uuid_from_prefixed","text":""},{"location":"api/core/#uuid_forge.core.extract_uuid_from_prefixed","title":"uuid_forge.core.extract_uuid_from_prefixed","text":"<pre><code>extract_uuid_from_prefixed(prefixed_id, separator='-')\n</code></pre> <p>Extract the UUID from a prefixed identifier.</p> <p>This function parses a prefixed identifier string (created with generate_uuid_with_prefix) and extracts just the UUID portion. It intelligently handles both prefixed and non-prefixed UUIDs.</p> <p>Parameters:</p> Name Type Description Default <code>prefixed_id</code> <code>str</code> <p>The prefixed identifier string. Can be either: - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\" - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"</p> required <code>separator</code> <code>str</code> <p>The separator used between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <p>Returns:</p> Type Description <code>UUID</code> <p>The extracted UUID object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid UUID can be found in the input string.</p> Example <pre><code>from uuid_forge.core import (\n    generate_uuid_with_prefix,\n    extract_uuid_from_prefixed,\n    IDConfig\n)\n\nconfig = IDConfig(salt=\"my-secret-salt\")\n\n# Generate a prefixed ID\nprefixed = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Extract the UUID\nextracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n# Regenerate from business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n\nassert extracted_uuid == regenerated_uuid\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import (\n...     generate_uuid_with_prefix,\n...     extract_uuid_from_prefixed,\n...     generate_uuid_only\n... )\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test with prefixed UUID\n&gt;&gt;&gt; prefixed = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n&gt;&gt;&gt; isinstance(extracted, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Verify extracted UUID matches original\n&gt;&gt;&gt; original = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; extracted == original\nTrue\n&gt;&gt;&gt; # Test with plain UUID string\n&gt;&gt;&gt; plain_uuid = str(generate_uuid_only(\"test\", key=\"other\"))\n&gt;&gt;&gt; extracted2 = extract_uuid_from_prefixed(plain_uuid)\n&gt;&gt;&gt; isinstance(extracted2, uuid.UUID)\nTrue\n&gt;&gt;&gt; str(extracted2) == plain_uuid\nTrue\n&gt;&gt;&gt; # Test with custom separator\n&gt;&gt;&gt; prefixed_custom = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n&gt;&gt;&gt; extracted3 = extract_uuid_from_prefixed(prefixed_custom, separator=\"_\")\n</code></pre> <p>extracted3 == original True</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def extract_uuid_from_prefixed(prefixed_id: str, separator: str = \"-\") -&gt; uuid_module.UUID:\n    \"\"\"Extract the UUID from a prefixed identifier.\n\n    This function parses a prefixed identifier string (created with\n    generate_uuid_with_prefix) and extracts just the UUID portion.\n    It intelligently handles both prefixed and non-prefixed UUIDs.\n\n    Args:\n        prefixed_id: The prefixed identifier string. Can be either:\n            - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n            - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"\n        separator: The separator used between prefix and UUID. Default is \"-\".\n\n    Returns:\n        The extracted UUID object.\n\n    Raises:\n        ValueError: If no valid UUID can be found in the input string.\n\n    Example:\n        ```python\n        from uuid_forge.core import (\n            generate_uuid_with_prefix,\n            extract_uuid_from_prefixed,\n            IDConfig\n        )\n\n        config = IDConfig(salt=\"my-secret-salt\")\n\n        # Generate a prefixed ID\n        prefixed = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Extract the UUID\n        extracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n        # Regenerate from business data\n        regenerated_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n\n        assert extracted_uuid == regenerated_uuid\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import (\n        ...     generate_uuid_with_prefix,\n        ...     extract_uuid_from_prefixed,\n        ...     generate_uuid_only\n        ... )\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; # Test with prefixed UUID\n        &gt;&gt;&gt; prefixed = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n        &gt;&gt;&gt; isinstance(extracted, uuid.UUID)\n        True\n        &gt;&gt;&gt; # Verify extracted UUID matches original\n        &gt;&gt;&gt; original = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; extracted == original\n        True\n        &gt;&gt;&gt; # Test with plain UUID string\n        &gt;&gt;&gt; plain_uuid = str(generate_uuid_only(\"test\", key=\"other\"))\n        &gt;&gt;&gt; extracted2 = extract_uuid_from_prefixed(plain_uuid)\n        &gt;&gt;&gt; isinstance(extracted2, uuid.UUID)\n        True\n        &gt;&gt;&gt; str(extracted2) == plain_uuid\n        True\n        &gt;&gt;&gt; # Test with custom separator\n        &gt;&gt;&gt; prefixed_custom = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n        &gt;&gt;&gt; extracted3 = extract_uuid_from_prefixed(prefixed_custom, separator=\"_\")\n    &gt;&gt;&gt; extracted3 == original\n    True\n    &gt;&gt;&gt; # Test with invalid input\n    &gt;&gt;&gt; extract_uuid_from_prefixed(\"not-a-uuid\")  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: No valid UUID found in 'not-a-uuid'\n    \"\"\"\n    # Split by separator and try to find UUID pattern\n    parts = prefixed_id.split(separator)\n\n    # Try each part from the end (UUID is typically at the end)\n    for i in range(len(parts)):\n        # Join remaining parts in case UUID has dashes\n        potential_uuid = separator.join(parts[i:])\n        try:\n            return uuid_module.UUID(potential_uuid)\n        except ValueError:\n            continue\n\n    raise ValueError(f\"No valid UUID found in '{prefixed_id}'\")\n</code></pre>"},{"location":"api/core/#uuid_forge.core.extract_uuid_from_prefixed--test-with-invalid-input","title":"Test with invalid input","text":"<p>extract_uuid_from_prefixed(\"not-a-uuid\")  # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): ... ValueError: No valid UUID found in 'not-a-uuid'</p>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#generate_salt","title":"generate_salt","text":""},{"location":"api/core/#uuid_forge.core.generate_salt","title":"uuid_forge.core.generate_salt","text":"<pre><code>generate_salt(length=32)\n</code></pre> <p>Generate a cryptographically secure random salt for UUID generation.</p> <p>This function creates a URL-safe, base64-encoded random string suitable for use as a salt in IDConfig. The salt should be generated once per deployment and stored securely in environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the generated salt in bytes. Default is 32 bytes, which produces a 43-character base64 string.</p> <code>32</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL-safe base64-encoded string suitable for use as a salt.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If length is less than 16 bytes (minimum recommended).</p> Example <pre><code>from uuid_forge.core import generate_salt\n\n# Generate a new salt for your deployment\nsalt = generate_salt()\n# Add this to your .env file: UUID_SALT={salt}\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_salt\n&gt;&gt;&gt; salt = generate_salt()\n&gt;&gt;&gt; isinstance(salt, str)\nTrue\n&gt;&gt;&gt; len(salt) &gt; 0\nTrue\n&gt;&gt;&gt; # Test different lengths\n&gt;&gt;&gt; salt_16 = generate_salt(16)\n&gt;&gt;&gt; salt_64 = generate_salt(64)\n&gt;&gt;&gt; len(salt_16) &lt; len(salt_64)\nTrue\n&gt;&gt;&gt; # Test minimum length validation\n&gt;&gt;&gt; generate_salt(15)\nTraceback (most recent call last):\n...\nValueError: Salt length must be at least 16 bytes for security, got 15\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_salt(length: int = 32) -&gt; str:\n    \"\"\"Generate a cryptographically secure random salt for UUID generation.\n\n    This function creates a URL-safe, base64-encoded random string suitable\n    for use as a salt in IDConfig. The salt should be generated once per\n    deployment and stored securely in environment variables.\n\n    Args:\n        length: Length of the generated salt in bytes. Default is 32 bytes,\n            which produces a 43-character base64 string.\n\n    Returns:\n        A URL-safe base64-encoded string suitable for use as a salt.\n\n    Raises:\n        ValueError: If length is less than 16 bytes (minimum recommended).\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_salt\n\n        # Generate a new salt for your deployment\n        salt = generate_salt()\n        # Add this to your .env file: UUID_SALT={salt}\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_salt\n        &gt;&gt;&gt; salt = generate_salt()\n        &gt;&gt;&gt; isinstance(salt, str)\n        True\n        &gt;&gt;&gt; len(salt) &gt; 0\n        True\n        &gt;&gt;&gt; # Test different lengths\n        &gt;&gt;&gt; salt_16 = generate_salt(16)\n        &gt;&gt;&gt; salt_64 = generate_salt(64)\n        &gt;&gt;&gt; len(salt_16) &lt; len(salt_64)\n        True\n        &gt;&gt;&gt; # Test minimum length validation\n        &gt;&gt;&gt; generate_salt(15)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Salt length must be at least 16 bytes for security, got 15\n    \"\"\"\n    if length &lt; 16:\n        raise ValueError(f\"Salt length must be at least 16 bytes for security, got {length}\")\n\n    return secrets.token_urlsafe(length)\n</code></pre>"},{"location":"api/core/#object-oriented-api","title":"Object-Oriented API","text":""},{"location":"api/core/#uuidgenerator","title":"UUIDGenerator","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator","title":"uuid_forge.core.UUIDGenerator","text":"<pre><code>UUIDGenerator(config=None)\n</code></pre> <p>Object-oriented convenience wrapper for UUID generation.</p> <p>This class provides a stateful interface for UUID generation, holding a configuration that's applied to all generated UUIDs. This is useful when you're generating many UUIDs with the same configuration, as it reduces boilerplate and ensures consistency.</p> <p>The functional API (generate_uuid_only, generate_uuid_with_prefix) is recommended for most use cases. Use this class when you need: - Multiple UUIDs with the same configuration - Encapsulation of configuration in a service/repository - Dependency injection patterns</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>The IDConfig used for all UUID generation operations.</p> Example <pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\nimport uuid\nimport os\n\n# Create generator with production config\ngenerator = UUIDGenerator(\n    config=IDConfig(\n        namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n        salt=os.getenv(\"UUID_SALT\", \"\")\n    )\n)\n\n# Generate multiple UUIDs with same config\ninvoice_uuid = generator.generate(\"invoice\", region=\"EUR\", number=123)\norder_uuid = generator.generate(\"order\", customer_id=456)\n\n# With prefixes\nprefixed_invoice = generator.generate_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    region=\"EUR\",\n    number=123\n)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import UUIDGenerator, IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test with default config\n&gt;&gt;&gt; gen = UUIDGenerator()\n&gt;&gt;&gt; uuid1 = gen.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Test idempotency\n&gt;&gt;&gt; uuid2 = gen.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid1 == uuid2\nTrue\n&gt;&gt;&gt; # Test with custom config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; gen_custom = UUIDGenerator(config=config)\n&gt;&gt;&gt; uuid3 = gen_custom.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid4 = gen_custom.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid3 == uuid4\nTrue\n&gt;&gt;&gt; # Different config produces different UUID\n&gt;&gt;&gt; uuid1 != uuid3\nTrue\n&gt;&gt;&gt; # Test generate_with_prefix\n&gt;&gt;&gt; prefixed = gen.generate_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; prefixed.startswith(\"TST-\")\nTrue\n&gt;&gt;&gt; # Verify UUID part matches\n&gt;&gt;&gt; from uuid_forge.core import extract_uuid_from_prefixed\n&gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n&gt;&gt;&gt; extracted == uuid1\nTrue\n</code></pre> <p>Initialize the UUID generator with a configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt).</p> <code>None</code> <p>Methods:</p> Name Description <code>generate</code> <p>Generate a deterministic UUID using this generator's configuration.</p> <code>generate_with_prefix</code> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __init__(self, config: IDConfig | None = None) -&gt; None:\n    \"\"\"Initialize the UUID generator with a configuration.\n\n    Args:\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt).\n    \"\"\"\n    self.config = config or IDConfig()\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate","title":"generate","text":"<pre><code>generate(entity_type, *args, **kwargs)\n</code></pre> <p>Generate a deterministic UUID using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_only with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate(self, entity_type: str, *args: Any, **kwargs: Any) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_only with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A deterministic UUID.\n    \"\"\"\n    return generate_uuid_only(entity_type, *args, config=self.config, **kwargs)\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate_with_prefix","title":"generate_with_prefix","text":"<pre><code>generate_with_prefix(entity_type, *args, prefix=None, separator='-', **kwargs)\n</code></pre> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_with_prefix with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID.</p> <code>'-'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with optional prefix and UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_with_prefix(\n    self,\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with prefix using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_with_prefix with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID.\n        separator: Character(s) to use between prefix and UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string with optional prefix and UUID.\n    \"\"\"\n    return generate_uuid_with_prefix(\n        entity_type, *args, prefix=prefix, separator=separator, config=self.config, **kwargs\n    )\n</code></pre>"},{"location":"api/core/#protocols","title":"Protocols","text":""},{"location":"api/core/#representable","title":"Representable","text":""},{"location":"api/core/#uuid_forge.core.Representable","title":"uuid_forge.core.Representable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can be represented as strings.</p> <p>Any object implementing repr satisfies this protocol and can be used directly with UUID generation functions.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return string representation of object.</p>"},{"location":"api/core/#uuid_forge.core.Representable-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.Representable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return string representation of object.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#usage-examples","title":"Usage Examples","text":""},{"location":"api/core/#basic-uuid-generation","title":"Basic UUID Generation","text":"<pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\n\n# Create configuration\nconfig = IDConfig(salt=\"production-secret-salt\")\n\n# Generate UUID\nuser_uuid = generate_uuid_only(\n    \"user\",\n    config=config,\n    email=\"alice@example.com\"\n)\n\nprint(user_uuid)  # UUID object\n</code></pre>"},{"location":"api/core/#with-human-readable-prefix","title":"With Human-Readable Prefix","text":"<pre><code>from uuid_forge.core import generate_uuid_with_prefix\n\n# Generate prefixed ID\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nprint(invoice_id)  # \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"api/core/#using-the-oo-api","title":"Using the OO API","text":"<pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\n\n# Create generator with configuration\ngenerator = UUIDGenerator(\n    config=IDConfig(salt=\"production-secret-salt\")\n)\n\n# Generate multiple UUIDs with same config\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\n</code></pre>"},{"location":"api/core/#extracting-uuids","title":"Extracting UUIDs","text":"<pre><code>from uuid_forge.core import extract_uuid_from_prefixed\n\n# Extract UUID from prefixed string\nprefixed = \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\nuuid = extract_uuid_from_prefixed(prefixed)\n\nprint(uuid)  # UUID('550e8400-e29b-41d4-a716-446655440000')\n</code></pre>"},{"location":"api/core/#type-information","title":"Type Information","text":"<p>All functions in the core module are fully typed. Import types for type hints:</p> <pre><code>from uuid import UUID\nfrom uuid_forge.core import IDConfig, Representable\nfrom typing import Optional\n\ndef process_entity(\n    entity_type: str,\n    config: Optional[IDConfig] = None,\n    **kwargs: Any\n) -&gt; UUID:\n    return generate_uuid_only(entity_type, config=config, **kwargs)\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>All functions in the core module are thread-safe. They have no shared mutable state and can be called concurrently from multiple threads.</p>"},{"location":"api/core/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>UUID generation is fast: ~10 microseconds per call</li> <li>No I/O operations are performed</li> <li>Memory usage is minimal (&lt; 1KB per call)</li> <li>Consider caching UUIDs if generating millions per second</li> </ul>"},{"location":"api/core/#security-notes","title":"Security Notes","text":"<p>Always Use a Salt in Production</p> <p>Without a salt, UUIDs are predictable and may pose a security risk. Always configure a cryptographic salt using <code>generate_salt()</code>.</p> <p>Keep Your Salt Secret</p> <p>The salt is effectively a secret key. Anyone with your salt can predict your UUIDs. Store it securely:</p> <ul> <li>Environment variables</li> <li>Secret management systems (AWS Secrets Manager, Vault, etc.)</li> <li>Never commit to version control</li> </ul>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Loading configuration from environment</li> <li>CLI Reference - Command-line interface</li> <li>Best Practices - Production guidelines</li> </ul>"},{"location":"development/contributing/","title":"Contributing to UUID-Forge","text":"<p>Thank you for your interest in contributing to UUID-Forge! This guide will help you get started with development and contribution.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>uv for dependency management</li> <li>Git for version control</li> </ul>"},{"location":"development/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>uv sync --dev\n</code></pre> <ol> <li>Activate the virtual environment:</li> </ol> <pre><code>source .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre> <ol> <li>Install pre-commit hooks: <pre><code>uv run pre-commit install\n</code></pre></li> </ol>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Run the full test suite:</p> <pre><code>uv run pytest\n</code></pre> <p>Run with coverage:</p> <pre><code>uv run pytest --cov=uuid_forge --cov-report=html\n</code></pre> <p>Run specific test categories:</p> <pre><code># Unit tests only\nuv run pytest tests/ -k \"not integration\"\n\n# Integration tests only\nuv run pytest tests/ -k \"integration\"\n\n# Performance tests\nuv run pytest tests/ -k \"performance\"\n</code></pre>"},{"location":"development/contributing/#code-quality","title":"Code Quality","text":"<p>We use several tools to maintain code quality:</p> <p>Formatting:</p> <pre><code>uv run black src tests\nuv run isort src tests\n</code></pre> <p>Linting:</p> <pre><code>uv run ruff check src tests\nuv run mypy src\n</code></pre> <p>All quality checks:</p> <pre><code>uv run pre-commit run --all-files\n</code></pre>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>uuid-forge/\n\u251c\u2500\u2500 src/uuid_forge/          # Main package\n\u2502   \u251c\u2500\u2500 __init__.py          # Package initialization\n\u2502   \u251c\u2500\u2500 core.py              # Core UUID generation logic\n\u2502   \u251c\u2500\u2500 config.py            # Configuration management\n\u2502   \u2514\u2500\u2500 cli.py               # Command-line interface\n\u251c\u2500\u2500 tests/                   # Test suite\n\u2502   \u251c\u2500\u2500 test_core.py         # Core functionality tests\n\u2502   \u251c\u2500\u2500 test_config.py       # Configuration tests\n\u2502   \u251c\u2500\u2500 test_cli.py          # CLI tests\n\u2502   \u2514\u2500\u2500 conftest.py          # Test configuration\n\u251c\u2500\u2500 docs/                    # Documentation\n\u251c\u2500\u2500 pyproject.toml           # Project configuration\n\u2514\u2500\u2500 README.md               # Project overview\n</code></pre>"},{"location":"development/contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all functions and methods</li> <li>Write descriptive docstrings (Google style)</li> <li>Keep functions and classes focused and small</li> <li>Use meaningful variable and function names</li> </ul>"},{"location":"development/contributing/#example-code-style","title":"Example Code Style","text":"<pre><code>def generate_uuid_from_data(\n    data: dict[str, Any],\n    namespace: str | None = None\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID from structured data.\n\n    Args:\n        data: Dictionary containing the data to generate UUID from\n        namespace: Optional namespace for UUID generation\n\n    Returns:\n        Generated UUID as a string\n\n    Raises:\n        ValueError: If data is empty or invalid\n\n    Example:\n        &gt;&gt;&gt; generate_uuid_from_data({\"user\": \"john@example.com\"})\n        '550e8400-e29b-41d4-a716-446655440000'\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data cannot be empty\")\n\n    # Implementation here...\n    return uuid_string\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update documentation for new features</li> <li>Include examples in docstrings</li> <li>Add entries to CHANGELOG.md</li> <li>Update README.md if needed</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>All contributions must include tests:</p> <ul> <li>Unit tests for individual functions/methods</li> <li>Integration tests for feature workflows</li> <li>Property-based tests for edge cases (using Hypothesis)</li> <li>Performance tests for optimization claims</li> </ul> <p>Example test structure:</p> <pre><code>def test_uuid_generation_deterministic():\n    \"\"\"Test that UUID generation is deterministic.\"\"\"\n    generator = UUIDGenerator(IDConfig(namespace=Namespace(\"test\"), salt=\"v1\"))\n\n    # Generate UUID multiple times\n    uuid1 = generator.generate(\"test-data\")\n    uuid2 = generator.generate(\"test-data\")\n\n    # Should be identical\n    assert uuid1 == uuid2\n    assert isinstance(uuid1, str)\n    assert len(uuid1) == 36  # Standard UUID length\n</code></pre>"},{"location":"development/contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ul> <li>Description: Clear description of the bug</li> <li>Steps to reproduce: Minimal example to reproduce the issue</li> <li>Expected behavior: What you expected to happen</li> <li>Actual behavior: What actually happened</li> <li>Environment: Python version, OS, package versions</li> <li>Stack trace: Full error output if applicable</li> </ul>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For new features, please provide:</p> <ul> <li>Use case: Why is this feature needed?</li> <li>Proposed API: How should the feature work?</li> <li>Alternatives: Other ways to achieve the same goal</li> <li>Breaking changes: Will this break existing code?</li> </ul>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<p>Before submitting a pull request:</p> <ol> <li>Fork the repository and create a feature branch</li> <li>Write tests for your changes</li> <li>Update documentation as needed</li> <li>Run all tests and quality checks</li> <li>Write a clear commit message</li> </ol> <p>Pull request checklist:</p> <ul> <li> Tests pass locally</li> <li> Code follows style guidelines</li> <li> Documentation updated</li> <li> CHANGELOG.md updated</li> <li> No breaking changes (or clearly documented)</li> </ul>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code>: Stable release branch</li> <li><code>develop</code>: Development integration branch</li> <li><code>feature/*</code>: Feature development branches</li> <li><code>bugfix/*</code>: Bug fix branches</li> <li><code>hotfix/*</code>: Critical fixes for production</li> </ul>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commit format:</p> <pre><code>type(scope): description\n\nOptional longer description\n\nCloses #issue-number\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Test changes</li> <li><code>chore</code>: Build/maintenance tasks</li> </ul> <p>Examples:</p> <pre><code>feat(core): add support for custom hash algorithms\n\nfix(cli): handle empty input gracefully\n\ndocs(api): update configuration examples\n</code></pre>"},{"location":"development/contributing/#release-process","title":"Release Process","text":""},{"location":"development/contributing/#version-numbers","title":"Version Numbers","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Incompatible API changes</li> <li>MINOR: New functionality (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"development/contributing/#release-steps","title":"Release Steps","text":"<ol> <li>Update version in <code>pyproject.toml</code></li> <li>Update <code>CHANGELOG.md</code></li> <li>Create release tag</li> <li>Build and publish to PyPI</li> <li>Create GitHub release</li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":""},{"location":"development/contributing/#community-support","title":"Community Support","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: Questions and general discussion</li> <li>Documentation: Comprehensive guides and API reference</li> </ul>"},{"location":"development/contributing/#development-questions","title":"Development Questions","text":"<p>If you have questions about development:</p> <ol> <li>Check existing issues and discussions</li> <li>Read the documentation thoroughly</li> <li>Look at existing code for patterns</li> <li>Ask specific questions with examples</li> </ol>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>CHANGELOG.md for significant contributions</li> <li>README.md contributors section</li> <li>GitHub contributors graph</li> <li>Release notes for major contributions</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project follows a Code of Conduct. By participating, you agree to abide by its terms:</p> <ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Help create a welcoming environment</li> <li>Report unacceptable behavior</li> </ul> <p>Thank you for contributing to UUID-Forge! Your contributions help make deterministic UUID generation better for everyone.</p>"},{"location":"development/release/","title":"Release Process","text":"<p>Comprehensive guide for maintainers on how to prepare, execute, and follow up on UUID-Forge releases.</p>"},{"location":"development/release/#release-overview","title":"Release Overview","text":"<p>UUID-Forge follows Semantic Versioning and uses an automated release process with proper testing, documentation, and distribution.</p>"},{"location":"development/release/#version-types","title":"Version Types","text":"<ul> <li>MAJOR (X.0.0): Breaking changes to public API</li> <li>MINOR (X.Y.0): New features, backward compatible</li> <li>PATCH (X.Y.Z): Bug fixes, backward compatible</li> </ul>"},{"location":"development/release/#pre-release-checklist","title":"Pre-Release Checklist","text":""},{"location":"development/release/#1-code-quality-verification","title":"1. Code Quality Verification","text":"<pre><code># Run full test suite\nuv run pytest\n\n# Check code coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n# Ensure coverage is &gt;95%\n\n# Run type checking\nuv run mypy src\n\n# Run linting\nuv run ruff check src tests\n\n# Format code\nuv run black src tests\nuv run isort src tests\n\n# Run pre-commit hooks\nuv run pre-commit run --all-files\n</code></pre>"},{"location":"development/release/#2-documentation-updates","title":"2. Documentation Updates","text":"<pre><code># Build documentation locally\nuv run mkdocs build --strict\n\n# Serve documentation for review\nuv run mkdocs serve\n\n# Check for broken links\nuv run mkdocs build --strict 2&gt;&amp;1 | grep WARNING\n</code></pre> <p>Update these files:</p> <ul> <li><code>CHANGELOG.md</code> - Add new version entry</li> <li><code>README.md</code> - Update examples if needed</li> <li><code>docs/</code> - Update any relevant documentation</li> <li><code>pyproject.toml</code> - Verify metadata is current</li> </ul>"},{"location":"development/release/#3-version-verification","title":"3. Version Verification","text":"<pre><code># Check current version\nuv run python -c \"from uuid_forge import __version__; print(__version__)\"\n\n# Verify version in all files matches\ngrep -r \"version.*=\" pyproject.toml\ngrep -r \"__version__\" src/uuid_forge/\n</code></pre>"},{"location":"development/release/#release-preparation","title":"Release Preparation","text":""},{"location":"development/release/#1-update-version-numbers","title":"1. Update Version Numbers","text":"<p>pyproject.toml:</p> <pre><code>[project]\nversion = \"1.2.3\"\n</code></pre> <p>src/uuid_forge/_version.py:</p> <pre><code>__version__ = \"1.2.3\"\n</code></pre>"},{"location":"development/release/#2-update-changelogmd","title":"2. Update CHANGELOG.md","text":"<pre><code>## [1.2.3] - 2024-01-15\n\n### Added\n\n- New feature descriptions\n- New functionality\n\n### Changed\n\n- Modified behavior descriptions\n- Updated dependencies\n\n### Fixed\n\n- Bug fix descriptions\n- Performance improvements\n\n### Deprecated\n\n- Features marked for removal\n\n### Removed\n\n- Removed features\n\n### Security\n\n- Security improvements\n</code></pre>"},{"location":"development/release/#3-create-release-branch","title":"3. Create Release Branch","text":"<pre><code># Create release branch\ngit checkout -b release/v1.2.3\n\n# Commit version updates\ngit add .\ngit commit -m \"chore: prepare release v1.2.3\"\n\n# Push release branch\ngit push origin release/v1.2.3\n</code></pre>"},{"location":"development/release/#release-execution","title":"Release Execution","text":""},{"location":"development/release/#1-final-testing","title":"1. Final Testing","text":"<pre><code># Install in clean environment\npython -m venv test-release\nsource test-release/bin/activate\npip install .\n\n# Test CLI functionality\nuuid-forge --version\nuuid-forge generate \"test-release\"\n\n# Test Python API\npython -c \"from uuid_forge import UUIDGenerator; print(UUIDGenerator().generate('test'))\"\n\n# Deactivate test environment\ndeactivate\nrm -rf test-release\n</code></pre>"},{"location":"development/release/#2-create-release-pr","title":"2. Create Release PR","text":"<p>Create a Pull Request from <code>release/v1.2.3</code> to <code>main</code>:</p> <p>PR Title: <code>Release v1.2.3</code></p> <p>PR Description:</p> <pre><code>## Release v1.2.3\n\n### Changes\n\n- Summary of major changes\n- Link to detailed CHANGELOG.md\n\n### Pre-release Checklist\n\n- [x] All tests passing\n- [x] Documentation updated\n- [x] Version numbers updated\n- [x] CHANGELOG.md updated\n- [x] Manual testing completed\n\n### Post-merge Actions\n\n- [ ] Create GitHub release\n- [ ] Build and publish to PyPI\n- [ ] Update documentation site\n- [ ] Announce release\n</code></pre>"},{"location":"development/release/#3-merge-and-tag","title":"3. Merge and Tag","text":"<p>After PR approval and merge:</p> <pre><code># Switch to main and pull latest\ngit checkout main\ngit pull origin main\n\n# Create and push tag\ngit tag -a v1.2.3 -m \"Release v1.2.3\"\ngit push origin v1.2.3\n</code></pre>"},{"location":"development/release/#automated-release-pipeline","title":"Automated Release Pipeline","text":""},{"location":"development/release/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>.github/workflows/release.yml:</p> <pre><code>name: Release\n\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Install dependencies\n        run: uv sync --dev\n\n      - name: Run tests\n        run: uv run pytest --cov=uuid_forge\n\n      - name: Build documentation\n        run: uv run mkdocs build --strict\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Build package\n        run: uv build\n\n      - name: Store build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n  publish-pypi:\n    needs: build\n    runs-on: ubuntu-latest\n    environment: release\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n      - name: Publish to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n        with:\n          password: ${{ secrets.PYPI_API_TOKEN }}\n\n  github-release:\n    needs: [test, build]\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: dist/*\n          generate_release_notes: true\n          draft: false\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n  deploy-docs:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Install dependencies\n        run: uv sync --dev\n\n      - name: Deploy documentation\n        run: |\n          git config user.name github-actions\n          git config user.email github-actions@github.com\n          uv run mike deploy --push --update-aliases ${{ github.ref_name }} latest\n</code></pre>"},{"location":"development/release/#manual-release-steps","title":"Manual Release Steps","text":"<p>If automated release fails, follow these manual steps:</p>"},{"location":"development/release/#1-build-package","title":"1. Build Package","text":"<pre><code># Clean previous builds\nrm -rf dist/ build/\n\n# Build package\nuv build\n\n# Verify build\nls -la dist/\n# Should see: uuid_forge-1.2.3.tar.gz and uuid_forge-1.2.3-py3-none-any.whl\n</code></pre>"},{"location":"development/release/#2-test-package","title":"2. Test Package","text":"<pre><code># Test installation from built package\npip install dist/uuid_forge-1.2.3-py3-none-any.whl\n\n# Test functionality\npython -c \"from uuid_forge import UUIDGenerator; print('OK')\"\nuuid-forge --version\n\n# Uninstall test installation\npip uninstall uuid-forge -y\n</code></pre>"},{"location":"development/release/#3-upload-to-pypi","title":"3. Upload to PyPI","text":"<pre><code># Install twine if not available\npip install twine\n\n# Check package\nuv run twine check dist/*\n\n# Upload to Test PyPI first\nuv run twine upload --repository testpypi dist/*\n\n# Test installation from Test PyPI\npip install --index-url https://test.pypi.org/simple/ uuid-forge==1.2.3\n\n# If test successful, upload to production PyPI\nuv run twine upload dist/*\n</code></pre>"},{"location":"development/release/#4-create-github-release","title":"4. Create GitHub Release","text":"<ol> <li>Go to GitHub repository releases page</li> <li>Click \"Create a new release\"</li> <li>Choose the tag <code>v1.2.3</code></li> <li>Title: <code>v1.2.3</code></li> <li>Description: Copy from CHANGELOG.md</li> <li>Attach built files from <code>dist/</code></li> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release/#post-release-tasks","title":"Post-Release Tasks","text":""},{"location":"development/release/#1-update-documentation","title":"1. Update Documentation","text":"<pre><code># Deploy documentation with version\nuv run mike deploy v1.2.3 latest --update-aliases --push\n\n# Verify documentation is live\nopen https://yourusername.github.io/uuid-forge/\n</code></pre>"},{"location":"development/release/#2-verify-package-distribution","title":"2. Verify Package Distribution","text":"<pre><code># Test installation from PyPI\npip install uuid-forge==1.2.3\n\n# Verify functionality\npython -c \"from uuid_forge import __version__; print(__version__)\"\nuuid-forge --version\n\n# Clean up\npip uninstall uuid-forge -y\n</code></pre>"},{"location":"development/release/#3-update-development-environment","title":"3. Update Development Environment","text":"<pre><code># Switch to develop branch\ngit checkout develop\n\n# Merge main into develop\ngit merge main\n\n# Push updated develop\ngit push origin develop\n\n# Clean up release branch\ngit branch -d release/v1.2.3\ngit push origin --delete release/v1.2.3\n</code></pre>"},{"location":"development/release/#4-prepare-next-development","title":"4. Prepare Next Development","text":"<p>Update version for development:</p> <pre><code># pyproject.toml\n[project]\nversion = \"1.2.4-dev\"\n</code></pre> <pre><code># src/uuid_forge/_version.py\n__version__ = \"1.2.4-dev\"\n</code></pre> <pre><code># Commit development version\ngit add .\ngit commit -m \"chore: bump version to 1.2.4-dev\"\ngit push origin develop\n</code></pre>"},{"location":"development/release/#release-communication","title":"Release Communication","text":""},{"location":"development/release/#1-announcement-channels","title":"1. Announcement Channels","text":"<p>GitHub Release Notes: Automatically generated PyPI Description: Updated from README.md Documentation: Updated automatically</p>"},{"location":"development/release/#2-social-media-optional","title":"2. Social Media (Optional)","text":"<p>Twitter:</p> <pre><code>\ud83c\udf89 UUID-Forge v1.2.3 is now available!\n\n\u2728 New features:\n- Feature 1\n- Feature 2\n\n\ud83d\udc1b Bug fixes and improvements\n\nInstall: pip install uuid-forge==1.2.3\n\n#Python #UUID #OpenSource\n</code></pre>"},{"location":"development/release/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"development/release/#hotfix-release","title":"Hotfix Release","text":"<p>For critical bugs in production:</p> <pre><code># Create hotfix branch from main\ngit checkout main\ngit checkout -b hotfix/v1.2.4\n\n# Make minimal fix\n# Update version to 1.2.4\n# Update CHANGELOG.md\n\n# Test thoroughly\nuv run pytest\n\n# Create PR to main\n# After merge, follow normal release process\n</code></pre>"},{"location":"development/release/#release-rollback","title":"Release Rollback","text":"<p>If critical issues are discovered:</p> <pre><code># Remove from PyPI (contact PyPI support)\n# Create new patch release with fix\n# Update documentation to recommend new version\n</code></pre>"},{"location":"development/release/#failed-release-recovery","title":"Failed Release Recovery","text":"<p>If release process fails:</p> <ol> <li>Check CI/CD logs for specific failure</li> <li>Fix issue in code or configuration</li> <li>Delete failed tag if necessary:    <pre><code>git tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n</code></pre></li> <li>Create new tag and retry release</li> </ol>"},{"location":"development/release/#release-metrics","title":"Release Metrics","text":"<p>Track these metrics for each release:</p> <ul> <li>Download counts from PyPI</li> <li>GitHub release downloads</li> <li>Documentation page views</li> <li>Issue reports post-release</li> <li>Community feedback</li> </ul>"},{"location":"development/release/#security-considerations","title":"Security Considerations","text":""},{"location":"development/release/#release-security","title":"Release Security","text":"<ul> <li>Sign releases with GPG keys</li> <li>Verify dependencies are up to date</li> <li>Scan for vulnerabilities before release</li> <li>Use secure CI/CD practices</li> </ul>"},{"location":"development/release/#dependency-management","title":"Dependency Management","text":"<pre><code># Update dependencies before release\nuv sync --upgrade\n\n# Check for security vulnerabilities\nuv run pip-audit\n\n# Review dependency changes\nuv run pip list --outdated\n</code></pre>"},{"location":"development/release/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release/#common-issues","title":"Common Issues","text":"<p>Version Mismatch:</p> <ul> <li>Ensure all files have consistent version numbers</li> <li>Check both <code>pyproject.toml</code> and <code>_version.py</code></li> </ul> <p>Build Failures:</p> <ul> <li>Clean build directories: <code>rm -rf dist/ build/</code></li> <li>Check for missing dependencies</li> <li>Verify Python version compatibility</li> </ul> <p>Upload Failures:</p> <ul> <li>Check PyPI credentials</li> <li>Verify package name availability</li> <li>Ensure proper file permissions</li> </ul> <p>Documentation Deployment:</p> <ul> <li>Check GitHub Pages settings</li> <li>Verify mike configuration</li> <li>Test documentation build locally</li> </ul>"},{"location":"development/release/#next-steps","title":"Next Steps","text":"<p>After successful release:</p> <ul> <li>Monitor for issues and feedback</li> <li>Plan next release features</li> <li>Update project roadmap</li> <li>Review and improve release process</li> </ul> <p>For more information:</p> <ul> <li>Contributing Guidelines</li> <li>Development Setup</li> <li>Testing Guide</li> </ul>"},{"location":"development/setup/","title":"Development Setup","text":"<p>Set up your development environment for contributing to UUID-Forge.</p>"},{"location":"development/setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher: UUID-Forge requires modern Python features</li> <li>uv: Fast Python package installer and resolver</li> <li>Git: Version control system</li> <li>Code Editor: VS Code, PyCharm, or your preferred editor</li> </ul>"},{"location":"development/setup/#installation","title":"Installation","text":""},{"location":"development/setup/#1-install-uv","title":"1. Install uv","text":"<p>If you don't have uv installed:</p> <pre><code># On macOS/Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or via pip\npip install uv\n</code></pre>"},{"location":"development/setup/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n</code></pre>"},{"location":"development/setup/#3-set-up-development-environment","title":"3. Set Up Development Environment","text":"<pre><code># Create virtual environment and install dependencies\nuv sync --dev\n\n# Activate virtual environment\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre>"},{"location":"development/setup/#4-install-pre-commit-hooks","title":"4. Install Pre-commit Hooks","text":"<pre><code>uv run pre-commit install\n</code></pre>"},{"location":"development/setup/#development-dependencies","title":"Development Dependencies","text":"<p>The development environment includes:</p>"},{"location":"development/setup/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>typer: CLI framework</li> <li>rich: Rich text and beautiful formatting</li> <li>pydantic: Data validation (if used)</li> </ul>"},{"location":"development/setup/#development-tools","title":"Development Tools","text":"<ul> <li>pytest: Testing framework</li> <li>pytest-cov: Coverage reporting</li> <li>pytest-benchmark: Performance testing</li> <li>hypothesis: Property-based testing</li> </ul>"},{"location":"development/setup/#code-quality","title":"Code Quality","text":"<ul> <li>black: Code formatting</li> <li>isort: Import sorting</li> <li>ruff: Fast Python linter</li> <li>mypy: Static type checking</li> <li>pre-commit: Git hooks for code quality</li> </ul>"},{"location":"development/setup/#documentation","title":"Documentation","text":"<ul> <li>mkdocs: Documentation generator</li> <li>mkdocs-material: Material theme for MkDocs</li> <li>mkdocstrings: API documentation from docstrings</li> </ul>"},{"location":"development/setup/#project-structure","title":"Project Structure","text":"<pre><code>uuid-forge/\n\u251c\u2500\u2500 .github/                 # GitHub workflows and templates\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u251c\u2500\u2500 ci.yml          # Continuous integration\n\u2502       \u2514\u2500\u2500 release.yml     # Release automation\n\u251c\u2500\u2500 .vscode/                # VS Code configuration\n\u2502   \u251c\u2500\u2500 settings.json       # Editor settings\n\u2502   \u2514\u2500\u2500 launch.json         # Debug configuration\n\u251c\u2500\u2500 docs/                   # Documentation source\n\u2502   \u251c\u2500\u2500 index.md           # Homepage\n\u2502   \u251c\u2500\u2500 getting-started/   # Getting started guides\n\u2502   \u251c\u2500\u2500 guide/             # User guides\n\u2502   \u251c\u2500\u2500 api/               # API reference\n\u2502   \u251c\u2500\u2500 use-cases/         # Use case examples\n\u2502   \u2514\u2500\u2500 development/       # Development docs\n\u251c\u2500\u2500 src/uuid_forge/         # Main package\n\u2502   \u251c\u2500\u2500 __init__.py        # Package initialization\n\u2502   \u251c\u2500\u2500 core.py            # Core UUID generation\n\u2502   \u251c\u2500\u2500 config.py          # Configuration management\n\u2502   \u2514\u2500\u2500 cli.py             # Command-line interface\n\u251c\u2500\u2500 tests/                  # Test suite\n\u2502   \u251c\u2500\u2500 conftest.py        # Test configuration\n\u2502   \u251c\u2500\u2500 test_core.py       # Core functionality tests\n\u2502   \u251c\u2500\u2500 test_config.py     # Configuration tests\n\u2502   \u251c\u2500\u2500 test_cli.py        # CLI tests\n\u2502   \u2514\u2500\u2500 integration/       # Integration tests\n\u251c\u2500\u2500 .gitignore             # Git ignore patterns\n\u251c\u2500\u2500 .pre-commit-config.yaml # Pre-commit configuration\n\u251c\u2500\u2500 mkdocs.yml             # Documentation configuration\n\u251c\u2500\u2500 pyproject.toml         # Project configuration\n\u2514\u2500\u2500 README.md              # Project overview\n</code></pre>"},{"location":"development/setup/#development-workflow","title":"Development Workflow","text":""},{"location":"development/setup/#1-create-feature-branch","title":"1. Create Feature Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/setup/#2-make-changes","title":"2. Make Changes","text":"<p>Edit code following the project conventions:</p> <ul> <li>Type hints: Use type hints for all functions</li> <li>Docstrings: Google-style docstrings</li> <li>Testing: Write tests for new functionality</li> <li>Documentation: Update docs for user-facing changes</li> </ul>"},{"location":"development/setup/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_core.py\n\n# Run tests matching pattern\nuv run pytest -k \"test_uuid_generation\"\n</code></pre>"},{"location":"development/setup/#4-check-code-quality","title":"4. Check Code Quality","text":"<pre><code># Format code\nuv run black src tests\n\n# Sort imports\nuv run isort src tests\n\n# Check linting\nuv run ruff check src tests\n\n# Type checking\nuv run mypy src\n\n# Run all pre-commit hooks\nuv run pre-commit run --all-files\n</code></pre>"},{"location":"development/setup/#5-build-documentation","title":"5. Build Documentation","text":"<pre><code># Build documentation\nuv run mkdocs build\n\n# Serve documentation locally\nuv run mkdocs serve\n</code></pre>"},{"location":"development/setup/#6-commit-changes","title":"6. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add new UUID generation feature\"\n</code></pre> <p>The pre-commit hooks will automatically run and ensure code quality.</p>"},{"location":"development/setup/#ide-configuration","title":"IDE Configuration","text":""},{"location":"development/setup/#vs-code-setup","title":"VS Code Setup","text":"<p>Recommended VS Code extensions:</p> <pre><code>{\n  \"recommendations\": [\n    \"ms-python.python\",\n    \"ms-python.black-formatter\",\n    \"ms-python.isort\",\n    \"charliermarsh.ruff\",\n    \"ms-python.mypy-type-checker\",\n    \"ms-python.pytest\",\n    \"yzhang.markdown-all-in-one\"\n  ]\n}\n</code></pre> <p>VS Code settings (<code>.vscode/settings.json</code>):</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \"./.venv/bin/python\",\n  \"python.formatting.provider\": \"black\",\n  \"python.linting.enabled\": true,\n  \"python.linting.ruffEnabled\": true,\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestPath\": \"./.venv/bin/pytest\",\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre>"},{"location":"development/setup/#pycharm-setup","title":"PyCharm Setup","text":"<ol> <li>Open Project: Open the <code>uuid-forge</code> directory</li> <li>Configure Interpreter: Set Python interpreter to <code>.venv/bin/python</code></li> <li>Enable Tools:</li> <li>Code \u2192 Reformat Code (Black)</li> <li>Code \u2192 Optimize Imports (isort)</li> <li>Enable type checking in settings</li> </ol>"},{"location":"development/setup/#testing","title":"Testing","text":""},{"location":"development/setup/#test-categories","title":"Test Categories","text":"<p>Unit Tests: Test individual functions and classes</p> <pre><code>uv run pytest tests/test_core.py::test_uuid_generation\n</code></pre> <p>Integration Tests: Test component interactions</p> <pre><code>uv run pytest tests/integration/\n</code></pre> <p>Property Tests: Test with generated data using Hypothesis</p> <pre><code>uv run pytest tests/test_properties.py\n</code></pre> <p>Performance Tests: Benchmark performance</p> <pre><code>uv run pytest tests/test_performance.py --benchmark-only\n</code></pre>"},{"location":"development/setup/#writing-tests","title":"Writing Tests","text":"<p>Example test structure:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\nclass TestUUIDGeneration:\n    def setUp(self):\n        self.generator = UUIDGenerator(IDConfig(namespace=Namespace(\"test\"), salt=\"v1\"))\n\n    def test_deterministic_generation(self):\n        \"\"\"Test that UUID generation is deterministic.\"\"\"\n        uuid1 = self.generator.generate(\"test-input\")\n        uuid2 = self.generator.generate(\"test-input\")\n\n        assert uuid1 == uuid2\n        assert len(uuid1) == 36\n\n    @pytest.mark.parametrize(\"input_data\", [\n        \"string\",\n        {\"key\": \"value\"},\n        [\"list\", \"data\"],\n        42\n    ])\n    def test_various_input_types(self, input_data):\n        \"\"\"Test UUID generation with various input types.\"\"\"\n        uuid_result = self.generator.generate(input_data)\n\n        assert isinstance(uuid_result, str)\n        assert len(uuid_result) == 36\n</code></pre>"},{"location":"development/setup/#test-configuration","title":"Test Configuration","text":"<p>The <code>conftest.py</code> file contains shared test fixtures:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\n@pytest.fixture\ndef test_generator():\n    \"\"\"Provide a test UUID generator.\"\"\"\n    return UUIDGenerator(IDConfig(namespace=Namespace(\"test-namespace\"), salt=\"v1\"))\n\n@pytest.fixture\ndef sample_data():\n    \"\"\"Provide sample test data.\"\"\"\n    return {\n        \"users\": [\n            {\"email\": \"user1@test.com\", \"name\": \"User 1\"},\n            {\"email\": \"user2@test.com\", \"name\": \"User 2\"}\n        ],\n        \"orders\": [\n            {\"id\": \"order1\", \"total\": 100.0},\n            {\"id\": \"order2\", \"total\": 200.0}\n        ]\n    }\n</code></pre>"},{"location":"development/setup/#debugging","title":"Debugging","text":""},{"location":"development/setup/#vs-code-debugging","title":"VS Code Debugging","text":"<p>Launch configuration (<code>.vscode/launch.json</code>):</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: Current File\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${file}\",\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"env\": {\n        \"PYTHONPATH\": \"${workspaceFolder}/src\"\n      }\n    },\n    {\n      \"name\": \"Python: Test Current File\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"pytest\",\n      \"args\": [\"${file}\"],\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    },\n    {\n      \"name\": \"UUID-Forge CLI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"uuid_forge.cli\",\n      \"args\": [\"generate\", \"test-input\"],\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    }\n  ]\n}\n</code></pre>"},{"location":"development/setup/#debug-configuration","title":"Debug Configuration","text":"<p>Enable debug logging:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Use in code\nlogger.debug(\"Debug information\")\n</code></pre>"},{"location":"development/setup/#performance-profiling","title":"Performance Profiling","text":""},{"location":"development/setup/#profile-code-performance","title":"Profile Code Performance","text":"<pre><code># Profile with cProfile\npython -m cProfile -o profile.stats -m uuid_forge.cli generate \"test-data\"\n\n# Analyze profile\npython -c \"import pstats; pstats.Stats('profile.stats').sort_stats('cumulative').print_stats(10)\"\n</code></pre>"},{"location":"development/setup/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Install memory profiler\nuv add --dev memory-profiler\n\n# Profile memory usage\npython -m memory_profiler uuid_forge/core.py\n</code></pre>"},{"location":"development/setup/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\n@pytest.mark.benchmark\ndef test_uuid_generation_performance(benchmark):\n    \"\"\"Benchmark UUID generation performance.\"\"\"\n    generator = UUIDGenerator(IDConfig(namespace=Namespace(\"benchmark\"), salt=\"v1\"))\n\n    result = benchmark(generator.generate, \"benchmark-data\")\n\n    assert len(result) == 36\n</code></pre>"},{"location":"development/setup/#documentation-development","title":"Documentation Development","text":""},{"location":"development/setup/#local-documentation-server","title":"Local Documentation Server","text":"<pre><code># Start local server with auto-reload\nuv run mkdocs serve\n\n# Build documentation\nuv run mkdocs build\n\n# Deploy to GitHub Pages (maintainers only)\nuv run mkdocs gh-deploy\n</code></pre>"},{"location":"development/setup/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Add links between related sections</li> <li>Follow the existing style and structure</li> </ul>"},{"location":"development/setup/#common-tasks","title":"Common Tasks","text":""},{"location":"development/setup/#add-new-dependency","title":"Add New Dependency","text":"<pre><code># Add runtime dependency\nuv add package-name\n\n# Add development dependency\nuv add --dev package-name\n\n# Update lockfile\nuv lock\n</code></pre>"},{"location":"development/setup/#update-dependencies","title":"Update Dependencies","text":"<pre><code># Update all dependencies\nuv sync --upgrade\n\n# Update specific package\nuv add package-name@latest\n</code></pre>"},{"location":"development/setup/#release-preparation","title":"Release Preparation","text":"<pre><code># Update version in pyproject.toml\n# Update CHANGELOG.md\n# Run full test suite\nuv run pytest\n\n# Build package\nuv build\n\n# Check package\nuv run twine check dist/*\n</code></pre>"},{"location":"development/setup/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check existing docs first</li> <li>Issues: Search GitHub issues for similar problems</li> <li>Discussions: Use GitHub Discussions for questions</li> <li>Code Review: Submit PRs for feedback</li> </ul> <p>For development questions, include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Full error messages</li> <li>Minimal reproduction example</li> </ul>"},{"location":"development/testing/","title":"Development Testing","text":"<p>Comprehensive guide to testing practices and infrastructure for UUID-Forge development.</p>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>UUID-Forge follows a comprehensive testing strategy that ensures:</p> <ul> <li>Correctness: All functionality works as specified</li> <li>Determinism: UUIDs are consistently generated</li> <li>Performance: Generation is fast and efficient</li> <li>Reliability: Code works across different environments</li> <li>Maintainability: Tests are clear and maintainable</li> </ul>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":""},{"location":"development/testing/#test-organization","title":"Test Organization","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Shared test configuration\n\u251c\u2500\u2500 test_core.py             # Core functionality tests\n\u251c\u2500\u2500 test_config.py           # Configuration tests\n\u251c\u2500\u2500 test_cli.py              # CLI tests\n\u251c\u2500\u2500 test_init.py             # Package initialization tests\n\u251c\u2500\u2500 test_version.py          # Version tests\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 test_database.py     # Database integration\n\u2502   \u251c\u2500\u2500 test_api.py          # API integration\n\u2502   \u2514\u2500\u2500 test_cli_integration.py # CLI integration\n\u251c\u2500\u2500 performance/             # Performance tests\n\u2502   \u251c\u2500\u2500 test_benchmarks.py   # Benchmark tests\n\u2502   \u2514\u2500\u2500 test_memory.py       # Memory usage tests\n\u2514\u2500\u2500 property/                # Property-based tests\n    \u251c\u2500\u2500 test_determinism.py  # Determinism properties\n    \u2514\u2500\u2500 test_uniqueness.py   # Uniqueness properties\n</code></pre>"},{"location":"development/testing/#test-categories","title":"Test Categories","text":"<p>Unit Tests: Test individual functions and classes in isolation Integration Tests: Test component interactions and workflows Property Tests: Test mathematical properties using generated data Performance Tests: Benchmark and validate performance requirements Regression Tests: Prevent previously fixed bugs from reoccurring</p>"},{"location":"development/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"development/testing/#core-functionality-tests","title":"Core Functionality Tests","text":"<pre><code>import pytest\nimport uuid\nfrom uuid_forge.core import UUIDGenerator, IDConfig\n\nclass TestUUIDGenerator:\n    \"\"\"Test core UUID generation functionality.\"\"\"\n\n    def setUp(self):\n        self.config = IDConfig(namespace=\"test-namespace\")\n        self.generator = UUIDGenerator(self.config)\n\n    def test_deterministic_generation(self):\n        \"\"\"Test that same input produces same UUID.\"\"\"\n        input_data = \"test-input\"\n\n        uuid1 = self.generator.generate(input_data)\n        uuid2 = self.generator.generate(input_data)\n\n        assert uuid1 == uuid2\n        assert isinstance(uuid1, str)\n        assert len(uuid1) == 36\n\n    def test_different_inputs_different_uuids(self):\n        \"\"\"Test that different inputs produce different UUIDs.\"\"\"\n        uuid1 = self.generator.generate(\"input1\")\n        uuid2 = self.generator.generate(\"input2\")\n\n        assert uuid1 != uuid2\n\n    def test_valid_uuid_format(self):\n        \"\"\"Test that generated UUIDs have valid format.\"\"\"\n        uuid_result = self.generator.generate(\"test\")\n\n        # Should be parseable as UUID\n        parsed_uuid = uuid.UUID(uuid_result)\n        assert str(parsed_uuid) == uuid_result\n\n        # Should have correct format\n        assert len(uuid_result) == 36\n        assert uuid_result.count('-') == 4\n\n    @pytest.mark.parametrize(\"input_data\", [\n        \"string\",\n        {\"key\": \"value\"},\n        [\"list\", \"item\"],\n        42,\n        3.14,\n        True,\n        None\n    ])\n    def test_various_input_types(self, input_data):\n        \"\"\"Test UUID generation with various input types.\"\"\"\n        uuid_result = self.generator.generate(input_data)\n\n        assert isinstance(uuid_result, str)\n        assert len(uuid_result) == 36\n\n        # Same input should produce same UUID\n        uuid_again = self.generator.generate(input_data)\n        assert uuid_result == uuid_again\n\n    def test_namespace_isolation(self):\n        \"\"\"Test that different namespaces produce different UUIDs.\"\"\"\n        config1 = IDConfig(namespace=\"namespace1\")\n        config2 = IDConfig(namespace=\"namespace2\")\n\n        gen1 = UUIDGenerator(config1)\n        gen2 = UUIDGenerator(config2)\n\n        input_data = \"same-input\"\n        uuid1 = gen1.generate(input_data)\n        uuid2 = gen2.generate(input_data)\n\n        assert uuid1 != uuid2\n\n    def test_empty_input_handling(self):\n        \"\"\"Test handling of empty inputs.\"\"\"\n        empty_inputs = [\"\", {}, [], None]\n\n        for empty_input in empty_inputs:\n            uuid_result = self.generator.generate(empty_input)\n            assert isinstance(uuid_result, str)\n            assert len(uuid_result) == 36\n</code></pre>"},{"location":"development/testing/#configuration-tests","title":"Configuration Tests","text":"<pre><code>from uuid_forge.config import load_config_from_env, init_config_file\nfrom uuid_forge.core import IDConfig\nimport os\nimport tempfile\n\nclass TestConfiguration:\n    \"\"\"Test configuration loading and validation.\"\"\"\n\n    def test_default_config(self):\n        \"\"\"Test default configuration values.\"\"\"\n        config = IDConfig()\n\n        assert config.namespace is not None\n        assert isinstance(config.salt, str)\n        assert len(config.salt) &gt; 0\n\n    def test_custom_namespace(self):\n        \"\"\"Test custom namespace configuration.\"\"\"\n        custom_namespace = \"custom-test-namespace\"\n        config = IDConfig(namespace=custom_namespace)\n\n        assert config.namespace == custom_namespace\n\n    def test_environment_config_loading(self):\n        \"\"\"Test loading configuration from environment variables.\"\"\"\n        test_namespace = \"env-test-namespace\"\n        test_salt = \"env-test-salt\"\n\n        # Set environment variables\n        os.environ[\"UUID_FORGE_NAMESPACE\"] = test_namespace\n        os.environ[\"UUID_FORGE_SALT\"] = test_salt\n\n        try:\n            config = load_config_from_env()\n            assert config.namespace == test_namespace\n            assert config.salt == test_salt\n        finally:\n            # Cleanup\n            del os.environ[\"UUID_FORGE_NAMESPACE\"]\n            del os.environ[\"UUID_FORGE_SALT\"]\n\n    def test_config_file_creation(self):\n        \"\"\"Test configuration file creation.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            config_path = os.path.join(temp_dir, \"test_config.yaml\")\n\n            init_config_file(config_path)\n\n            assert os.path.exists(config_path)\n\n            # File should contain expected content\n            with open(config_path, 'r') as f:\n                content = f.read()\n                assert \"namespace:\" in content\n                assert \"salt:\" in content\n</code></pre>"},{"location":"development/testing/#cli-tests","title":"CLI Tests","text":"<pre><code>from typer.testing import CliRunner\nfrom uuid_forge.cli import app\nimport json\n\nclass TestCLI:\n    \"\"\"Test command-line interface.\"\"\"\n\n    def setUp(self):\n        self.runner = CliRunner()\n\n    def test_generate_command(self):\n        \"\"\"Test basic UUID generation command.\"\"\"\n        result = self.runner.invoke(app, [\"generate\", \"test-input\"])\n\n        assert result.exit_code == 0\n        output = result.stdout.strip()\n        assert len(output) == 36\n        assert output.count('-') == 4\n\n    def test_generate_multiple_inputs(self):\n        \"\"\"Test generating UUIDs for multiple inputs.\"\"\"\n        result = self.runner.invoke(app, [\n            \"generate\", \"input1\", \"input2\", \"input3\"\n        ])\n\n        assert result.exit_code == 0\n        lines = result.stdout.strip().split('\\n')\n        assert len(lines) == 3\n\n        # All should be valid UUIDs\n        for line in lines:\n            assert len(line) == 36\n            assert line.count('-') == 4\n\n        # All should be different\n        assert len(set(lines)) == 3\n\n    def test_namespace_option(self):\n        \"\"\"Test namespace option.\"\"\"\n        result1 = self.runner.invoke(app, [\n            \"generate\", \"--namespace\", \"ns1\", \"test\"\n        ])\n        result2 = self.runner.invoke(app, [\n            \"generate\", \"--namespace\", \"ns2\", \"test\"\n        ])\n\n        assert result1.exit_code == 0\n        assert result2.exit_code == 0\n\n        uuid1 = result1.stdout.strip()\n        uuid2 = result2.stdout.strip()\n\n        # Different namespaces should produce different UUIDs\n        assert uuid1 != uuid2\n\n    def test_config_commands(self):\n        \"\"\"Test configuration management commands.\"\"\"\n        # Test config show\n        result = self.runner.invoke(app, [\"config\", \"show\"])\n        assert result.exit_code == 0\n\n        # Output should contain configuration information\n        assert \"namespace\" in result.stdout.lower()\n\n    def test_version_command(self):\n        \"\"\"Test version command.\"\"\"\n        result = self.runner.invoke(app, [\"--version\"])\n        assert result.exit_code == 0\n        assert \"uuid-forge\" in result.stdout.lower()\n\n    def test_help_commands(self):\n        \"\"\"Test help commands.\"\"\"\n        result = self.runner.invoke(app, [\"--help\"])\n        assert result.exit_code == 0\n        assert \"generate\" in result.stdout\n\n        result = self.runner.invoke(app, [\"generate\", \"--help\"])\n        assert result.exit_code == 0\n        assert \"namespace\" in result.stdout\n</code></pre>"},{"location":"development/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"development/testing/#database-integration","title":"Database Integration","text":"<pre><code>import pytest\nimport sqlite3\nfrom uuid_forge import UUIDGenerator\n\nclass TestDatabaseIntegration:\n    \"\"\"Test integration with database systems.\"\"\"\n\n    @pytest.fixture\n    def test_db(self):\n        \"\"\"Create test database.\"\"\"\n        conn = sqlite3.connect(\":memory:\")\n        cursor = conn.cursor()\n\n        cursor.execute(\"\"\"\n            CREATE TABLE users (\n                id TEXT PRIMARY KEY,\n                email TEXT UNIQUE NOT NULL,\n                name TEXT NOT NULL\n            )\n        \"\"\")\n\n        cursor.execute(\"\"\"\n            CREATE TABLE orders (\n                id TEXT PRIMARY KEY,\n                user_id TEXT NOT NULL,\n                total REAL NOT NULL,\n                FOREIGN KEY (user_id) REFERENCES users (id)\n            )\n        \"\"\")\n\n        conn.commit()\n        yield conn\n        conn.close()\n\n    def test_user_order_relationship(self, test_db):\n        \"\"\"Test maintaining relationships with deterministic UUIDs.\"\"\"\n        user_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"db-users\"), salt=\"v1\"))\n        order_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"db-orders\"), salt=\"v1\"))\n\n        cursor = test_db.cursor()\n\n        # Create user with deterministic UUID\n        user_email = \"dbtest@example.com\"\n        user_id = user_gen.generate(\"user\", email=user_email)\n\n        cursor.execute(\n            \"INSERT INTO users (id, email, name) VALUES (?, ?, ?)\",\n            (user_id, user_email, \"Test User\")\n        )\n\n        # Create order with deterministic UUID\n        order_data = {\n            \"user_id\": user_id,\n            \"total\": 100.50,\n            \"items\": [\"item1\", \"item2\"]\n        }\n        order_id = order_gen.generate(order_data)\n\n        cursor.execute(\n            \"INSERT INTO orders (id, user_id, total) VALUES (?, ?, ?)\",\n            (order_id, user_id, 100.50)\n        )\n\n        test_db.commit()\n\n        # Verify relationship\n        cursor.execute(\"\"\"\n            SELECT u.email, o.total\n            FROM users u\n            JOIN orders o ON u.id = o.user_id\n            WHERE u.id = ?\n        \"\"\", (user_id,))\n\n        result = cursor.fetchone()\n        assert result is not None\n        assert result[0] == user_email\n        assert result[1] == 100.50\n\n        # Verify UUIDs are deterministic\n        user_id_2 = user_gen.generate(\"user\", email=user_email)\n        order_id_2 = order_gen.generate(order_data)\n\n        assert user_id == user_id_2\n        assert order_id == order_id_2\n</code></pre>"},{"location":"development/testing/#api-integration","title":"API Integration","text":"<pre><code>import pytest\nimport requests_mock\nfrom uuid_forge import UUIDGenerator\n\nclass TestAPIIntegration:\n    \"\"\"Test integration with API services.\"\"\"\n\n    def test_rest_api_integration(self):\n        \"\"\"Test integration with REST API.\"\"\"\n        user_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"api-users\"), salt=\"v1\"))\n\n        with requests_mock.Mocker() as m:\n            user_email = \"apitest@example.com\"\n            user_id = user_gen.generate(\"user\", email=user_email)\n\n            # Mock API response\n            m.post(\n                \"http://api.example.com/users\",\n                json={\"id\": user_id, \"email\": user_email},\n                status_code=201\n            )\n\n            # Test API call\n            response = requests.post(\n                \"http://api.example.com/users\",\n                json={\"email\": user_email}\n            )\n\n            assert response.status_code == 201\n            data = response.json()\n            assert data[\"id\"] == user_id\n            assert data[\"email\"] == user_email\n</code></pre>"},{"location":"development/testing/#property-based-testing","title":"Property-Based Testing","text":""},{"location":"development/testing/#determinism-properties","title":"Determinism Properties","text":"<pre><code>from hypothesis import given, strategies as st\nfrom uuid_forge import UUIDGenerator\nimport uuid\n\nclass TestDeterminismProperties:\n    \"\"\"Test determinism properties using Hypothesis.\"\"\"\n\n    def setUp(self):\n        self.generator = UUIDGenerator(IDConfig(namespace=Namespace(\"property-test\"), salt=\"v1\"))\n\n    @given(st.text(min_size=1))\n    def test_determinism_property(self, input_text):\n        \"\"\"Property: Same input always produces same output.\"\"\"\n        uuid1 = self.generator.generate(input_text)\n        uuid2 = self.generator.generate(input_text)\n\n        assert uuid1 == uuid2\n\n    @given(st.text(min_size=1))\n    def test_valid_uuid_property(self, input_text):\n        \"\"\"Property: All outputs are valid UUIDs.\"\"\"\n        uuid_result = self.generator.generate(input_text)\n\n        # Should be parseable as UUID\n        parsed = uuid.UUID(uuid_result)\n        assert str(parsed) == uuid_result\n\n        # Should have correct length and format\n        assert len(uuid_result) == 36\n        assert uuid_result.count('-') == 4\n\n    @given(st.lists(st.text(min_size=1), min_size=2, unique=True))\n    def test_uniqueness_property(self, input_list):\n        \"\"\"Property: Different inputs produce different UUIDs.\"\"\"\n        uuids = [self.generator.generate(inp) for inp in input_list]\n\n        # All UUIDs should be unique\n        assert len(set(uuids)) == len(uuids)\n\n    @given(st.dictionaries(st.text(), st.text(), min_size=1))\n    def test_dict_determinism_property(self, input_dict):\n        \"\"\"Property: Dictionary inputs produce deterministic UUIDs.\"\"\"\n        uuid1 = self.generator.generate(input_dict)\n        uuid2 = self.generator.generate(input_dict)\n\n        assert uuid1 == uuid2\n</code></pre>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/testing/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\nimport time\n\nclass TestPerformance:\n    \"\"\"Test performance requirements.\"\"\"\n\n    def setUp(self):\n        self.generator = UUIDGenerator(IDConfig(namespace=Namespace(\"perf-test\"), salt=\"v1\"))\n\n    @pytest.mark.benchmark\n    def test_single_generation_speed(self, benchmark):\n        \"\"\"Benchmark single UUID generation.\"\"\"\n        result = benchmark(self.generator.generate, \"benchmark-input\")\n\n        assert len(result) == 36\n\n    def test_batch_generation_performance(self):\n        \"\"\"Test batch generation performance.\"\"\"\n        test_inputs = [f\"input-{i}\" for i in range(1000)]\n\n        start_time = time.time()\n        uuids = [self.generator.generate(inp) for inp in test_inputs]\n        end_time = time.time()\n\n        generation_time = end_time - start_time\n\n        # Should generate 1000 UUIDs in under 100ms\n        assert generation_time &lt; 0.1\n        assert len(uuids) == 1000\n        assert len(set(uuids)) == 1000  # All unique\n\n    def test_memory_efficiency(self):\n        \"\"\"Test memory usage during generation.\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        # Generate many UUIDs\n        large_inputs = [f\"input-{i}\" for i in range(10000)]\n        uuids = [self.generator.generate(inp) for inp in large_inputs]\n\n        peak_memory = process.memory_info().rss\n        memory_increase = peak_memory - initial_memory\n\n        # Memory increase should be reasonable\n        assert memory_increase &lt; 50 * 1024 * 1024  # Less than 50MB\n        assert len(uuids) == 10000\n\n    @pytest.mark.slow\n    def test_large_scale_performance(self):\n        \"\"\"Test performance with large-scale generation.\"\"\"\n        # Generate 100,000 UUIDs\n        start_time = time.time()\n\n        uuids = []\n        for i in range(100000):\n            uuid_result = self.generator.generate(f\"large-scale-{i}\")\n            uuids.append(uuid_result)\n\n        end_time = time.time()\n        total_time = end_time - start_time\n\n        # Should complete in reasonable time\n        assert total_time &lt; 10.0  # Less than 10 seconds\n        assert len(uuids) == 100000\n        assert len(set(uuids)) == 100000  # All unique\n</code></pre>"},{"location":"development/testing/#memory-profiling","title":"Memory Profiling","text":"<pre><code>import pytest\nfrom memory_profiler import profile\nfrom uuid_forge import UUIDGenerator\n\nclass TestMemoryUsage:\n    \"\"\"Test memory usage patterns.\"\"\"\n\n    @profile\n    def test_memory_profile_batch_generation(self):\n        \"\"\"Profile memory usage during batch generation.\"\"\"\n        generator = UUIDGenerator(IDConfig(namespace=Namespace(\"memory-test\"), salt=\"v1\"))\n\n        # Generate many UUIDs to observe memory pattern\n        uuids = []\n        for i in range(10000):\n            uuid_result = generator.generate(f\"memory-test-{i}\")\n            uuids.append(uuid_result)\n\n        return len(uuids)\n</code></pre>"},{"location":"development/testing/#test-configuration-and-fixtures","title":"Test Configuration and Fixtures","text":""},{"location":"development/testing/#shared-test-configuration","title":"Shared Test Configuration","text":"<pre><code># conftest.py\nimport pytest\nfrom uuid_forge import UUIDGenerator\nfrom uuid_forge.core import IDConfig\nimport tempfile\nimport os\n\n@pytest.fixture\ndef test_generator():\n    \"\"\"Provide a test UUID generator with consistent namespace.\"\"\"\n    config = IDConfig(namespace=\"test-namespace\")\n    return UUIDGenerator(config)\n\n@pytest.fixture\ndef temp_config_file():\n    \"\"\"Provide a temporary configuration file.\"\"\"\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:\n        f.write(\"\"\"\nnamespace: test-config-namespace\nsalt: test-config-salt\n\"\"\")\n        config_path = f.name\n\n    yield config_path\n\n    # Cleanup\n    os.unlink(config_path)\n\n@pytest.fixture\ndef sample_test_data():\n    \"\"\"Provide sample test data.\"\"\"\n    return {\n        \"users\": [\n            {\"email\": \"user1@test.com\", \"name\": \"User One\"},\n            {\"email\": \"user2@test.com\", \"name\": \"User Two\"},\n            {\"email\": \"user3@test.com\", \"name\": \"User Three\"}\n        ],\n        \"orders\": [\n            {\"id\": \"order1\", \"user_email\": \"user1@test.com\", \"total\": 100.0},\n            {\"id\": \"order2\", \"user_email\": \"user2@test.com\", \"total\": 200.0}\n        ]\n    }\n\n@pytest.fixture(scope=\"session\")\ndef performance_generator():\n    \"\"\"Provide a generator for performance tests.\"\"\"\n    config = IDConfig(namespace=\"performance-test\")\n    return UUIDGenerator(config)\n\n# Test markers\npytest.mark.slow = pytest.mark.mark_slow(\"Slow running tests\")\npytest.mark.benchmark = pytest.mark.benchmark(\"Benchmark tests\")\npytest.mark.integration = pytest.mark.integration(\"Integration tests\")\n</code></pre>"},{"location":"development/testing/#test-execution","title":"Test Execution","text":""},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test categories\nuv run pytest -m \"not slow\"  # Skip slow tests\nuv run pytest -m benchmark   # Only benchmark tests\nuv run pytest -m integration # Only integration tests\n\n# Run with coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_core.py\n\n# Run specific test\nuv run pytest tests/test_core.py::TestUUIDGenerator::test_deterministic_generation\n\n# Run tests matching pattern\nuv run pytest -k \"test_uuid\"\n\n# Run tests with verbose output\nuv run pytest -v\n\n# Run tests with detailed output\nuv run pytest -vv\n\n# Stop on first failure\nuv run pytest -x\n\n# Run failed tests from last run\nuv run pytest --lf\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Test Suite\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [\"3.11\", \"3.12\"]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install uv\n        run: |\n          pip install uv\n\n      - name: Install dependencies\n        run: |\n          uv sync --dev\n\n      - name: Run tests\n        run: |\n          uv run pytest --cov=uuid_forge --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n</code></pre>"},{"location":"development/testing/#test-best-practices","title":"Test Best Practices","text":""},{"location":"development/testing/#writing-good-tests","title":"Writing Good Tests","text":"<ol> <li>Clear Names: Test names should describe what is being tested</li> <li>Single Responsibility: Each test should test one thing</li> <li>Deterministic: Tests should not depend on external factors</li> <li>Fast: Unit tests should run quickly</li> <li>Independent: Tests should not depend on each other</li> </ol>"},{"location":"development/testing/#test-organization_1","title":"Test Organization","text":"<ol> <li>Group Related Tests: Use classes to group related test methods</li> <li>Use Fixtures: Share setup code using pytest fixtures</li> <li>Parametrize Tests: Use <code>@pytest.mark.parametrize</code> for similar tests</li> <li>Mark Tests: Use pytest marks to categorize tests</li> </ol>"},{"location":"development/testing/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Unit Tests: Aim for &gt;95% code coverage</li> <li>Integration Tests: Cover critical workflows</li> <li>Property Tests: Validate mathematical properties</li> <li>Performance Tests: Ensure performance requirements</li> </ul>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"development/testing/#debug-failing-tests","title":"Debug Failing Tests","text":"<pre><code># Run with pdb debugger\nuv run pytest --pdb\n\n# Run specific failing test with verbose output\nuv run pytest tests/test_core.py::test_failing -vv\n\n# Show local variables in traceback\nuv run pytest --tb=long\n</code></pre>"},{"location":"development/testing/#test-output-analysis","title":"Test Output Analysis","text":"<pre><code># Show print statements\nuv run pytest -s\n\n# Show test duration\nuv run pytest --durations=10\n\n# Generate HTML coverage report\nuv run pytest --cov=uuid_forge --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"development/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Release Process - Preparing releases</li> <li>Contributing - Contributing guidelines</li> <li>Best Practices - Code best practices</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>UUID-Forge provides flexible configuration options to suit different use cases and environments.</p>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>UUID-Forge looks for configuration in the following locations (in order of precedence):</p> <ol> <li><code>uuid_forge.yaml</code> in the current directory</li> <li><code>~/.uuid_forge.yaml</code> in the user's home directory</li> <li><code>/etc/uuid_forge.yaml</code> system-wide configuration</li> </ol>"},{"location":"getting-started/configuration/#configuration-format","title":"Configuration Format","text":"<pre><code># uuid_forge.yaml\nnamespace: \"my-application\"\nversion: 1\nformat: \"hex\"\ncase: \"lower\"\nseparator: \"-\"\n\n# Custom namespaces for different contexts\nnamespaces:\n  users: \"550e8400-e29b-41d4-a716-446655440000\"\n  orders: \"550e8400-e29b-41d4-a716-446655440001\"\n  products: \"550e8400-e29b-41d4-a716-446655440002\"\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#core-settings","title":"Core Settings","text":"<ul> <li><code>namespace</code>: Default namespace UUID (string or UUID)</li> <li><code>version</code>: UUID version to generate (1, 3, 4, or 5)</li> <li><code>format</code>: Output format (<code>hex</code>, <code>urn</code>, <code>bytes</code>)</li> <li><code>case</code>: Case for hex output (<code>upper</code>, <code>lower</code>)</li> <li><code>separator</code>: Separator character for hex format</li> </ul>"},{"location":"getting-started/configuration/#advanced-settings","title":"Advanced Settings","text":"<ul> <li><code>seed</code>: Random seed for reproducible generation</li> <li><code>clock_seq</code>: Clock sequence for version 1 UUIDs</li> <li><code>node</code>: Node ID for version 1 UUIDs</li> </ul>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Configuration can also be set via environment variables:</p> <pre><code>export UUID_FORGE_NAMESPACE=\"my-app\"\nexport UUID_FORGE_VERSION=5\nexport UUID_FORGE_FORMAT=\"hex\"\n</code></pre>"},{"location":"getting-started/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig\n\n# Create configuration\nconfig = IDConfig(\n    namespace=\"my-application\",\n    version=5,\n    format=\"hex\",\n    case=\"lower\"\n)\n\n# Initialize with configuration\nforge = UUIDGenerator(config)\n\n# Or use default configuration\nforge = UUIDGenerator()\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>UUID-Forge validates all configuration values and provides helpful error messages for invalid settings.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Understand UUID generation principles</li> <li>Basic Usage - Start generating UUIDs</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>UUID-Forge can be installed using various package managers. Choose the method that best fits your workflow.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>pip, uv, or poetry (depending on your preferred installation method)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code>uv add uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#using-poetry","title":"Using poetry","text":"<pre><code>poetry add uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to UUID-Forge or install from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n\n# Install in development mode\nuv sync --dev\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation by running:</p> <pre><code>python -c \"import uuid_forge; print(uuid_forge.__version__)\"\n</code></pre> <p>Or use the CLI:</p> <pre><code>uuid-forge --version\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get up and running in 5 minutes</li> <li>Configuration - Learn about configuration options</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with UUID-Forge in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of UUIDs</li> <li>A text editor or IDE</li> </ul>"},{"location":"getting-started/quickstart/#step-1-installation","title":"Step 1: Installation","text":"<p>Install UUID-Forge using your preferred package manager:</p> uv (recommended)pippoetry <pre><code>uv add uuid-forge\n</code></pre> <pre><code>pip install uuid-forge\n</code></pre> <pre><code>poetry add uuid-forge\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-generate-a-salt","title":"Step 2: Generate a Salt","text":"<p>Security first! Generate a cryptographic salt for production use:</p> <pre><code>uuid-forge new-salt\n</code></pre> <p>This will output something like:</p> <pre><code>xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\n</code></pre> <p>Keep This Secret!</p> <p>Store this salt securely and never commit it to version control.</p>"},{"location":"getting-started/quickstart/#set-environment-variable","title":"Set Environment Variable","text":"<p>Add the salt to your environment:</p> <pre><code>export UUID_FORGE_SALT='xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB'\n</code></pre> <p>Or create a <code>.env</code> file:</p> <pre><code>uuid-forge init\n</code></pre> <p>This creates a <code>.env</code> file with a generated salt and usage instructions.</p>"},{"location":"getting-started/quickstart/#step-3-your-first-uuid","title":"Step 3: Your First UUID","text":"<p>Create a Python file <code>example.py</code>:</p> <pre><code>from uuid_forge import generate_uuid_only, load_config_from_env\n\n# Load configuration from environment\nconfig = load_config_from_env()\n\n# Generate a deterministic UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(f\"Invoice UUID: {invoice_uuid}\")\n</code></pre> <p>Run it:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-verify-idempotency","title":"Step 4: Verify Idempotency","text":"<p>The magic of UUID-Forge is that the same inputs always produce the same UUID. Add this to your script:</p> <pre><code># Regenerate the UUID from the same business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\n# They're identical!\nassert invoice_uuid == regenerated_uuid\nprint(\"\u2713 UUIDs are identical!\")\n</code></pre> <p>Run again:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n\u2713 UUIDs are identical!\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-use-across-systems","title":"Step 5: Use Across Systems","text":"<p>Now use this UUID consistently across all your storage systems:</p> <pre><code>import psycopg2\nimport boto3\nimport redis\n\n# Database - Primary key\ndb = psycopg2.connect(\"...\")\ncursor = db.cursor()\ncursor.execute(\n    \"INSERT INTO invoices (id, region, number, amount) VALUES (%s, %s, %s, %s)\",\n    (invoice_uuid, \"EUR\", 12345, 1500.50)\n)\n\n# S3 - Object storage\ns3 = boto3.client('s3')\ns3.put_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{invoice_uuid}.pdf',\n    Body=pdf_data\n)\n\n# Redis - Cache\nr = redis.Redis()\nr.setex(\n    f'invoice:{invoice_uuid}',\n    3600,  # 1 hour TTL\n    json.dumps({'region': 'EUR', 'number': 12345})\n)\n\nprint(f\"\u2713 Stored invoice {invoice_uuid} in Postgres, S3, and Redis\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-retrieve-without-lookups","title":"Step 6: Retrieve Without Lookups","text":"<p>The real power: retrieve from any system without database lookups!</p> <pre><code># User requests invoice by business data\nrequested_region = \"EUR\"\nrequested_number = 12345\n\n# Regenerate UUID from business data (no database query!)\nlookup_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=requested_region,\n    invoice_number=requested_number\n)\n\n# Now access any storage system directly\npdf_data = s3.get_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{lookup_uuid}.pdf'\n)\n\ncached_data = r.get(f'invoice:{lookup_uuid}')\n\ndb_record = cursor.execute(\n    \"SELECT * FROM invoices WHERE id = %s\",\n    (lookup_uuid,)\n).fetchone()\n\nprint(\"\u2713 Retrieved from all systems without any UUID lookups!\")\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#pattern-1-with-prefixes-for-human-readability","title":"Pattern 1: With Prefixes for Human Readability","text":"<pre><code>from uuid_forge import generate_uuid_with_prefix\n\n# Generate with prefix\nprefixed_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(prefixed_id)\n# Output: INV-EUR-550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"getting-started/quickstart/#pattern-2-using-the-oo-api","title":"Pattern 2: Using the OO API","text":"<pre><code>from uuid_forge import UUIDGenerator\n\n# Create generator once\ngenerator = UUIDGenerator(config=config)\n\n# Generate multiple UUIDs\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\nshipment_uuid = generator.generate(\"shipment\", order_id=str(order_uuid))\n</code></pre>"},{"location":"getting-started/quickstart/#pattern-3-different-entity-types","title":"Pattern 3: Different Entity Types","text":"<pre><code># Each entity type has its own UUID space\nuser_uuid = generate_uuid_only(\"user\", config=config, email=\"alice@example.com\")\norder_uuid = generate_uuid_only(\"order\", config=config, user_id=str(user_uuid), number=123)\ninvoice_uuid = generate_uuid_only(\"invoice\", config=config, order_id=str(order_uuid))\n\n# Same business data, different entity types = different UUIDs\nassert user_uuid != order_uuid != invoice_uuid\n</code></pre>"},{"location":"getting-started/quickstart/#cli-usage","title":"CLI Usage","text":"<p>UUID-Forge includes a powerful CLI for quick UUID generation:</p> <pre><code># Generate UUID\nuuid-forge generate invoice --attr region=EUR --attr number=12345\n\n# With prefix\nuuid-forge generate invoice --prefix INV-EUR --attr region=EUR --attr number=12345\n\n# Extract UUID from prefixed ID\nuuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Validate configuration\nuuid-forge validate\n\n# Show current configuration\nuuid-forge info\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics, explore:</p> <ul> <li>Core Concepts - Understand how it works</li> <li>Best Practices - Production guidelines</li> <li>Use Cases - Real-world examples</li> <li>API Reference - Complete documentation</li> </ul>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#issue-no-salt-configured-warning","title":"Issue: \"No salt configured\" warning","text":"<p>Solution: Set the <code>UUID_FORGE_SALT</code> environment variable or use <code>uuid-forge init</code> to create a config file.</p>"},{"location":"getting-started/quickstart/#issue-different-uuids-on-different-machines","title":"Issue: Different UUIDs on different machines","text":"<p>Solution: Ensure all machines use the same salt and namespace configuration.</p>"},{"location":"getting-started/quickstart/#issue-uuids-change-after-restart","title":"Issue: UUIDs change after restart","text":"<p>Solution: Verify environment variables are set correctly and persistently.</p>"},{"location":"getting-started/quickstart/#get-help","title":"Get Help","text":"<ul> <li>GitHub Issues</li> <li>GitHub Discussions</li> <li>API Reference</li> </ul>"},{"location":"guide/advanced-usage/","title":"Advanced Usage","text":"<p>Explore the advanced features and customization options of UUID-Forge for complex use cases.</p>"},{"location":"guide/advanced-usage/#custom-namespaces-and-hierarchies","title":"Custom Namespaces and Hierarchies","text":""},{"location":"guide/advanced-usage/#creating-namespace-hierarchies","title":"Creating Namespace Hierarchies","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\n# Create a root namespace for your organization\norg_namespace = Namespace(\"mycompany.com\")\n\n# Create service-specific namespaces using the Namespace class\nuser_service_ns = Namespace(\"mycompany.com/user-service\")\norder_service_ns = Namespace(\"mycompany.com/order-service\")\n\n# Configure generators for each service\nuser_config = IDConfig(namespace=user_service_ns, salt=\"user-service-v1\")\norder_config = IDConfig(namespace=order_service_ns, salt=\"order-service-v1\")\n\nuser_generator = UUIDGenerator(user_config)\norder_generator = UUIDGenerator(order_config)\n\n# Generate UUIDs in each service\nuser_uuid = user_generator.generate(\"user\", email=\"alice@example.com\")\norder_uuid = order_generator.generate(\"order\", order_id=12345)\n</code></pre>"},{"location":"guide/advanced-usage/#namespace-factories","title":"Namespace Factories","text":"<pre><code>from uuid_forge import Namespace, IDConfig, UUIDGenerator\n\nclass ServiceNamespaceFactory:\n    \"\"\"Factory for creating service-specific UUID generators\"\"\"\n    def __init__(self, organization_domain: str, base_salt: str = \"v1\"):\n        self.organization = organization_domain\n        self.base_salt = base_salt\n        self._generators = {}\n\n    def get_generator(self, service_name: str) -&gt; UUIDGenerator:\n        \"\"\"Get or create a generator for a specific service\"\"\"\n        if service_name not in self._generators:\n            namespace = Namespace(f\"{self.organization}/{service_name}\")\n            config = IDConfig(\n                namespace=namespace,\n                salt=f\"{service_name}-{self.base_salt}\"\n            )\n            self._generators[service_name] = UUIDGenerator(config)\n        return self._generators[service_name]\n\n# Usage\nfactory = ServiceNamespaceFactory(\"mycompany.com\")\nuser_gen = factory.get_generator(\"users\")\nproduct_gen = factory.get_generator(\"products\")\norder_gen = factory.get_generator(\"orders\")\n\n# Each service generates UUIDs in its own namespace\nuser_uuid = user_gen.generate(\"user\", id=123)\nproduct_uuid = product_gen.generate(\"product\", sku=\"ABC-123\")\n</code></pre>"},{"location":"guide/advanced-usage/#complex-data-processing","title":"Complex Data Processing","text":""},{"location":"guide/advanced-usage/#multi-attribute-uuid-generation","title":"Multi-Attribute UUID Generation","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Configure generator\nconfig = IDConfig(namespace=Namespace(\"mycompany.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\n# Generate UUIDs from multiple attributes\n# All attributes are combined deterministically\nuser_uuid = generator.generate(\n    \"user\",\n    id=12345,\n    email=\"john@example.com\",\n    region=\"us-west\"\n)\n\n# Same attributes in different order produce the same UUID\nsame_uuid = generator.generate(\n    \"user\",\n    region=\"us-west\",\n    email=\"john@example.com\",\n    id=12345\n)\n\nassert user_uuid == same_uuid  # \u2705 Deterministic\n\n# Complex nested data can be flattened\norder_uuid = generator.generate(\n    \"order\",\n    user_id=12345,\n    user_email=\"john@example.com\",\n    order_date=\"2024-01-15\",\n    order_version=\"2.1\",\n    theme=\"dark\",\n    notifications=True\n)\n</code></pre>"},{"location":"guide/advanced-usage/#date-and-time-handling","title":"Date and Time Handling","text":"<pre><code>from datetime import datetime, date\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nconfig = IDConfig(namespace=Namespace(\"events.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\n# Use ISO format strings for consistent date/time handling\nevent_uuid = generator.generate(\n    \"event\",\n    user_id=123,\n    timestamp=\"2024-01-15T10:30:00Z\",  # ISO format\n    event_type=\"login\"\n)\n\n# For Python datetime objects, convert to ISO format\nnow = datetime.utcnow()\nevent_uuid = generator.generate(\n    \"event\",\n    user_id=123,\n    timestamp=now.isoformat(),\n    event_type=\"login\"\n)\n\n# Date-based partitioning\ntoday = date.today()\ndaily_uuid = generator.generate(\n    \"daily_report\",\n    date=today.isoformat(),\n    region=\"us-west\"\n)\n</code></pre>"},{"location":"guide/advanced-usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/advanced-usage/#batch-processing","title":"Batch Processing","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Create generator once, reuse for many UUIDs\nconfig = IDConfig(namespace=Namespace(\"items.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\n# Efficient batch processing\ndef process_batch(items, entity_type=\"item\"):\n    \"\"\"Generate UUIDs for a batch of items\"\"\"\n    return [\n        (item_id, generator.generate(entity_type, id=item_id))\n        for item_id in items\n    ]\n\n# Process large datasets efficiently\nlarge_dataset = list(range(10000))\nresults = process_batch(large_dataset)\n\n# Batch with different attributes\nuser_data = [\n    {\"email\": \"user1@example.com\", \"region\": \"us\"},\n    {\"email\": \"user2@example.com\", \"region\": \"eu\"},\n    {\"email\": \"user3@example.com\", \"region\": \"asia\"},\n]\n\nuser_uuids = [\n    generator.generate(\"user\", **user)\n    for user in user_data\n]\n</code></pre>"},{"location":"guide/advanced-usage/#reusing-generators","title":"Reusing Generators","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nclass EntityUUIDManager:\n    \"\"\"Manager for generating UUIDs across multiple entity types\"\"\"\n\n    def __init__(self, namespace: str, salt: str):\n        config = IDConfig(namespace=Namespace(namespace), salt=salt)\n        self.generator = UUIDGenerator(config)\n\n    def user_uuid(self, email: str) -&gt; UUID:\n        \"\"\"Generate user UUID from email\"\"\"\n        return self.generator.generate(\"user\", email=email)\n\n    def order_uuid(self, user_email: str, order_id: int) -&gt; UUID:\n        \"\"\"Generate order UUID from user and order ID\"\"\"\n        return self.generator.generate(\"order\", user_email=user_email, order_id=order_id)\n\n    def product_uuid(self, sku: str) -&gt; UUID:\n        \"\"\"Generate product UUID from SKU\"\"\"\n        return self.generator.generate(\"product\", sku=sku)\n\n# Create once, use throughout application\nmanager = EntityUUIDManager(\"myapp.com\", \"prod-v1\")\n\n# Fast UUID generation for any entity\nuser_uuid = manager.user_uuid(\"alice@example.com\")\norder_uuid = manager.order_uuid(\"alice@example.com\", 12345)\nproduct_uuid = manager.product_uuid(\"WIDGET-001\")\n</code></pre>"},{"location":"guide/advanced-usage/#namespace-versioning-and-migration","title":"Namespace Versioning and Migration","text":""},{"location":"guide/advanced-usage/#versioning-with-salts","title":"Versioning with Salts","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Version 1 of your UUID generation\nconfig_v1 = IDConfig(namespace=Namespace(\"myapp.com\"), salt=\"v1\")\ngenerator_v1 = UUIDGenerator(config_v1)\n\n# Later, when you need to change UUID generation (e.g., schema change)\nconfig_v2 = IDConfig(namespace=Namespace(\"myapp.com\"), salt=\"v2\")\ngenerator_v2 = UUIDGenerator(config_v2)\n\n# Same input, different UUIDs due to different salt\nemail = \"user@example.com\"\nuuid_v1 = generator_v1.generate(\"user\", email=email)\nuuid_v2 = generator_v2.generate(\"user\", email=email)\n\nassert uuid_v1 != uuid_v2  # Different UUIDs for migration purposes\n</code></pre>"},{"location":"guide/advanced-usage/#migration-strategy","title":"Migration Strategy","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Dict\nfrom uuid import UUID\n\nclass UUIDMigrationManager:\n    \"\"\"Manage UUID migrations between versions\"\"\"\n\n    def __init__(self, namespace: str):\n        self.namespace = namespace\n        self.generators = {}\n\n    def get_generator(self, version: str) -&gt; UUIDGenerator:\n        \"\"\"Get or create a generator for a specific version\"\"\"\n        if version not in self.generators:\n            config = IDConfig(\n                namespace=Namespace(self.namespace),\n                salt=version\n            )\n            self.generators[version] = UUIDGenerator(config)\n        return self.generators[version]\n\n    def create_migration_map(\n        self,\n        items: list,\n        old_version: str,\n        new_version: str,\n        entity_type: str,\n        key_field: str\n    ) -&gt; Dict[UUID, UUID]:\n        \"\"\"Create a mapping from old UUIDs to new UUIDs\"\"\"\n        old_gen = self.get_generator(old_version)\n        new_gen = self.get_generator(new_version)\n\n        migration_map = {}\n        for item in items:\n            old_uuid = old_gen.generate(entity_type, **{key_field: item})\n            new_uuid = new_gen.generate(entity_type, **{key_field: item})\n            migration_map[old_uuid] = new_uuid\n\n        return migration_map\n\n# Usage\nmanager = UUIDMigrationManager(\"myapp.com\")\n\n# Migrate user UUIDs from v1 to v2\nuser_emails = [\"alice@example.com\", \"bob@example.com\", \"carol@example.com\"]\nmigration_map = manager.create_migration_map(\n    items=user_emails,\n    old_version=\"v1\",\n    new_version=\"v2\",\n    entity_type=\"user\",\n    key_field=\"email\"\n)\n\n# Update database\nfor old_uuid, new_uuid in migration_map.items():\n    # db.execute(\"UPDATE users SET id = %s WHERE id = %s\", (new_uuid, old_uuid))\n    pass\n</code></pre>"},{"location":"guide/advanced-usage/#integration-patterns","title":"Integration Patterns","text":""},{"location":"guide/advanced-usage/#database-integration-with-sqlalchemy","title":"Database Integration with SQLAlchemy","text":"<pre><code>import sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.dialects.postgresql import UUID as PGUUID\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nBase = declarative_base()\n\n# Create a shared generator for user entities\nuser_config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\nuser_uuid_generator = UUIDGenerator(user_config)\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = sa.Column(PGUUID(as_uuid=True), primary_key=True)\n    email = sa.Column(sa.String, unique=True, nullable=False)\n    region = sa.Column(sa.String, nullable=False)\n\n    def __init__(self, email: str, region: str):\n        self.email = email\n        self.region = region\n        # Generate deterministic UUID from email and region\n        self.id = user_uuid_generator.generate(\"user\", email=email, region=region)\n\n# Usage\nuser = User(email=\"john@example.com\", region=\"us-west\")\n# user.id is now a deterministic UUID: same email+region = same UUID\nprint(user.id)  # UUID('...')\n\n# Later, recreate the same UUID without database lookup\nsame_uuid = user_uuid_generator.generate(\"user\", email=\"john@example.com\", region=\"us-west\")\nassert user.id == same_uuid\n</code></pre>"},{"location":"guide/advanced-usage/#database-integration-with-django","title":"Database Integration with Django","text":"<pre><code>from django.db import models\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\n# Configure generator at module level\nproduct_config = IDConfig(namespace=Namespace(\"products.myshop.com\"), salt=\"v1\")\nproduct_uuid_generator = UUIDGenerator(product_config)\n\nclass Product(models.Model):\n    id = models.UUIDField(primary_key=True, editable=False)\n    sku = models.CharField(max_length=100, unique=True)\n    name = models.CharField(max_length=200)\n    category = models.CharField(max_length=100)\n\n    def save(self, *args, **kwargs):\n        # Generate UUID before first save\n        if not self.id:\n            self.id = product_uuid_generator.generate(\n                \"product\",\n                sku=self.sku,\n                category=self.category\n            )\n        super().save(*args, **kwargs)\n\n# Usage\nproduct = Product(sku=\"WIDGET-001\", name=\"Premium Widget\", category=\"widgets\")\nproduct.save()\n# product.id is now a deterministic UUID\n\n# Regenerate UUID for lookups\nproduct_uuid = product_uuid_generator.generate(\n    \"product\",\n    sku=\"WIDGET-001\",\n    category=\"widgets\"\n)\nproduct = Product.objects.get(id=product_uuid)\n</code></pre>"},{"location":"guide/advanced-usage/#message-queue-integration","title":"Message Queue Integration","text":"<pre><code>import json\nfrom datetime import datetime\nfrom uuid import UUID\nfrom typing import Dict, Set, Any\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nclass MessageHandler:\n    \"\"\"Handle message queue messages with deduplication\"\"\"\n\n    def __init__(self, queue_namespace: str):\n        config = IDConfig(namespace=Namespace(queue_namespace), salt=\"v1\")\n        self.generator = UUIDGenerator(config)\n        self.processed_ids: Set[UUID] = set()\n\n    def create_message(self, user_id: int, event_type: str, data: Dict[str, Any]) -&gt; Dict[str, Any]:\n        \"\"\"Create a message with deterministic ID for deduplication\"\"\"\n        # Generate UUID from user, event type, and data\n        message_id = self.generator.generate(\n            \"message\",\n            user_id=user_id,\n            event_type=event_type,\n            data=json.dumps(data, sort_keys=True)  # Ensure consistent ordering\n        )\n\n        return {\n            \"id\": str(message_id),\n            \"user_id\": user_id,\n            \"event_type\": event_type,\n            \"data\": data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n\n    def is_duplicate(self, user_id: int, event_type: str, data: Dict[str, Any]) -&gt; bool:\n        \"\"\"Check if message has already been processed\"\"\"\n        message_id = self.generator.generate(\n            \"message\",\n            user_id=user_id,\n            event_type=event_type,\n            data=json.dumps(data, sort_keys=True)\n        )\n        return message_id in self.processed_ids\n\n    def mark_processed(self, user_id: int, event_type: str, data: Dict[str, Any]):\n        \"\"\"Mark a message as processed\"\"\"\n        message_id = self.generator.generate(\n            \"message\",\n            user_id=user_id,\n            event_type=event_type,\n            data=json.dumps(data, sort_keys=True)\n        )\n        self.processed_ids.add(message_id)\n\n# Usage\nhandler = MessageHandler(\"events.myapp.com\")\n\n# Create message\nmessage = handler.create_message(\n    user_id=123,\n    event_type=\"user.login\",\n    data={\"ip\": \"192.168.1.1\", \"device\": \"mobile\"}\n)\n\n# Check for duplicates before processing\nif not handler.is_duplicate(123, \"user.login\", {\"ip\": \"192.168.1.1\", \"device\": \"mobile\"}):\n    # Process message\n    print(f\"Processing message {message['id']}\")\n    handler.mark_processed(123, \"user.login\", {\"ip\": \"192.168.1.1\", \"device\": \"mobile\"})\nelse:\n    print(\"Duplicate message, skipping\")\n</code></pre>"},{"location":"guide/advanced-usage/#configuration-management","title":"Configuration Management","text":""},{"location":"guide/advanced-usage/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\ndef create_generator_from_env(service_name: str) -&gt; UUIDGenerator:\n    \"\"\"Create a UUID generator from environment variables\"\"\"\n    # Get namespace from environment or use default\n    namespace_domain = os.getenv('UUID_NAMESPACE_DOMAIN', 'myapp.com')\n    namespace = Namespace(f\"{namespace_domain}/{service_name}\")\n\n    # Get salt from environment with version/environment suffix\n    environment = os.getenv('APP_ENVIRONMENT', 'production')  # dev, staging, production\n    version = os.getenv('UUID_VERSION', 'v1')\n    salt = f\"{service_name}-{environment}-{version}\"\n\n    config = IDConfig(namespace=namespace, salt=salt)\n    return UUIDGenerator(config)\n\n# Usage: different environments get different UUIDs\n# Production\n# os.environ['APP_ENVIRONMENT'] = 'production'\n# os.environ['UUID_NAMESPACE_DOMAIN'] = 'mycompany.com'\n\nprod_generator = create_generator_from_env('users')\n\n# Staging - same inputs, different UUIDs\n# os.environ['APP_ENVIRONMENT'] = 'staging'\n\nstaging_generator = create_generator_from_env('users')\n\n# Same user data generates different UUIDs in different environments\nemail = \"test@example.com\"\nprod_uuid = prod_generator.generate(\"user\", email=email)\nstaging_uuid = staging_generator.generate(\"user\", email=email)\n\nassert prod_uuid != staging_uuid  # Different environments = different UUIDs\n</code></pre>"},{"location":"guide/advanced-usage/#multi-tenant-configuration","title":"Multi-Tenant Configuration","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Dict\n\nclass TenantUUIDManager:\n    \"\"\"Manage UUID generation for multi-tenant applications\"\"\"\n\n    def __init__(self, base_namespace: str):\n        self.base_namespace = base_namespace\n        self.generators: Dict[str, UUIDGenerator] = {}\n\n    def get_generator(self, tenant_id: str) -&gt; UUIDGenerator:\n        \"\"\"Get or create a generator for a specific tenant\"\"\"\n        if tenant_id not in self.generators:\n            # Each tenant gets its own namespace\n            namespace = Namespace(f\"{self.base_namespace}/tenant/{tenant_id}\")\n            config = IDConfig(namespace=namespace, salt=f\"tenant-{tenant_id}-v1\")\n            self.generators[tenant_id] = UUIDGenerator(config)\n        return self.generators[tenant_id]\n\n    def generate_for_tenant(self, tenant_id: str, entity_type: str, **kwargs):\n        \"\"\"Generate a UUID for a specific tenant\"\"\"\n        generator = self.get_generator(tenant_id)\n        return generator.generate(entity_type, **kwargs)\n\n# Usage\nmanager = TenantUUIDManager(\"saas.myapp.com\")\n\n# Tenant A\ntenant_a_user = manager.generate_for_tenant(\n    \"tenant-a\",\n    \"user\",\n    email=\"john@tenanta.com\"\n)\n\n# Tenant B - same email, different UUID\ntenant_b_user = manager.generate_for_tenant(\n    \"tenant-b\",\n    \"user\",\n    email=\"john@tenanta.com\"  # Same email, but different tenant\n)\n\nassert tenant_a_user != tenant_b_user  # Tenant isolation\n</code></pre>"},{"location":"guide/advanced-usage/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Master the command-line interface</li> <li>Best Practices - Learn optimization techniques</li> <li>Use Cases - See real-world applications</li> </ul>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental ways to use UUID-Forge in your applications.</p>"},{"location":"guide/basic-usage/#quick-start","title":"Quick Start","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig\nimport os\n\n# Create a generator with configuration\nconfig = IDConfig(salt=os.getenv(\"UUID_FORGE_SALT\"))\ngenerator = UUIDGenerator(config=config)\n\n# Generate a UUID from entity type and business data\nuser_id = generator.generate(\"user\", email=\"john.doe@example.com\")\nprint(user_id)  # 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/basic-usage/#creating-uuids-from-business-data","title":"Creating UUIDs from Business Data","text":""},{"location":"guide/basic-usage/#basic-entity-generation","title":"Basic Entity Generation","text":"<pre><code># User entity by email\nuser_uuid = generator.generate(\"user\", email=\"user@example.com\")\n\n# Order entity by customer and timestamp\norder_uuid = generator.generate(\"order\", customer_id=\"12345\", timestamp=\"2024-01-15\")\n\n# Product entity by SKU\nproduct_uuid = generator.generate(\"product\", sku=\"WIDGET-001\")\n</code></pre>"},{"location":"guide/basic-usage/#multiple-attributes","title":"Multiple Attributes","text":"<pre><code># Invoice with multiple identifying attributes\ninvoice_uuid = generator.generate(\n    \"invoice\",\n    region=\"EUR\",\n    year=2024,\n    quarter=\"Q1\",\n    number=12345\n)\n\n# User with multiple identifiers\nuser_uuid = generator.generate(\n    \"user\",\n    email=\"john@example.com\",\n    username=\"john_doe\",\n    department=\"engineering\"\n)\n</code></pre>"},{"location":"guide/basic-usage/#using-different-entity-types","title":"Using Different Entity Types","text":"<pre><code># Each entity type creates a separate UUID namespace\nuser_uuid = generator.generate(\"user\", identifier=\"alice@example.com\")\norder_uuid = generator.generate(\"order\", identifier=\"alice@example.com\")\ninvoice_uuid = generator.generate(\"invoice\", identifier=\"alice@example.com\")\n\n# All different UUIDs, even though the identifier is the same\nassert user_uuid != order_uuid != invoice_uuid\n</code></pre>"},{"location":"guide/basic-usage/#working-with-uuid-objects","title":"Working with UUID Objects","text":"<pre><code>from uuid_forge import UUID\n\n# The generate() method returns a standard UUID object\nuser_uuid = generator.generate(\"user\", email=\"alice@example.com\")\n\n# Access UUID properties\nprint(user_uuid.hex)        # Hex string without dashes\nprint(user_uuid.bytes)      # Raw bytes\nprint(str(user_uuid))       # Standard hyphenated format\nprint(user_uuid.urn)        # URN format\nprint(user_uuid.int)        # Integer representation\n\n# UUID comparison and operations\nanother_uuid = generator.generate(\"user\", email=\"bob@example.com\")\nprint(user_uuid &lt; another_uuid)  # UUIDs are comparable\n</code></pre>"},{"location":"guide/basic-usage/#using-different-namespaces","title":"Using Different Namespaces","text":"<pre><code>from uuid_forge import Namespace\n\n# Different namespaces produce different UUIDs for same input\nusers_config = IDConfig(\n    namespace=Namespace(\"users.mycompany.com\"),\n    salt=os.getenv(\"UUID_FORGE_SALT\")\n)\norders_config = IDConfig(\n    namespace=Namespace(\"orders.mycompany.com\"),\n    salt=os.getenv(\"UUID_FORGE_SALT\")\n)\n\nuser_generator = UUIDGenerator(config=users_config)\norder_generator = UUIDGenerator(config=orders_config)\n\n# Same business data, different namespaces = different UUIDs\nuser_uuid = user_generator.generate(\"user\", email=\"john@example.com\")\norder_uuid = order_generator.generate(\"order\", email=\"john@example.com\")\n\nprint(user_uuid != order_uuid)  # True\n</code></pre>"},{"location":"guide/basic-usage/#batch-generation","title":"Batch Generation","text":"<pre><code># Generate multiple UUIDs efficiently\nemails = [\n    \"user1@example.com\",\n    \"user2@example.com\",\n    \"user3@example.com\"\n]\n\n# All with same entity type\nuser_uuids = [generator.generate(\"user\", email=email) for email in emails]\n\n# Different entity types\nentities = [\n    (\"user\", {\"email\": \"user1@example.com\"}),\n    (\"admin\", {\"email\": \"admin@example.com\"}),\n    (\"guest\", {\"session_id\": \"12345\"}),\n]\nuuids = [generator.generate(entity_type, **attrs) for entity_type, attrs in entities]\n</code></pre>"},{"location":"guide/basic-usage/#working-with-uuids-across-systems","title":"Working with UUIDs Across Systems","text":"<pre><code># Generate UUID in one system\ninvoice_uuid = generator.generate(\"invoice\", region=\"EUR\", number=12345)\n\n# Store in database\ndb.execute(\n    \"INSERT INTO invoices (id, region, number) VALUES (%s, %s, %s)\",\n    (invoice_uuid, \"EUR\", 12345)\n)\n\n# Later, in a different service/system, regenerate the same UUID\n# No database lookup needed!\nsame_uuid = generator.generate(\"invoice\", region=\"EUR\", number=12345)\n\n# Retrieve from S3 directly\ns3_object = s3.get_object(\n    Bucket=\"invoices\",\n    Key=f\"invoices/{same_uuid}.pdf\"\n)\n</code></pre>"},{"location":"guide/basic-usage/#using-with-prefixes","title":"Using with Prefixes","text":"<pre><code>from uuid_forge import generate_uuid_with_prefix, extract_uuid_from_prefixed\n\n# Generate with human-readable prefix\nprefixed_id = generator.generate_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345\n)\nprint(prefixed_id)  # INV-EUR-550e8400-e29b-41d4-a716-446655440000\n\n# Extract UUID when needed\nuuid_only = extract_uuid_from_prefixed(prefixed_id)\nprint(uuid_only)  # 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/basic-usage/#uuid-properties-and-operations","title":"UUID Properties and Operations","text":"<pre><code># Generate a UUID\nuser_uuid = generator.generate(\"user\", email=\"alice@example.com\")\n\n# UUID is a standard Python uuid.UUID object\nprint(isinstance(user_uuid, UUID))  # True\n\n# String conversion\nprint(str(user_uuid))  # Standard format with hyphens\n\n# UUIDs are hashable and can be used in sets/dicts\nuuid_set = {user_uuid}\nuuid_dict = {user_uuid: \"alice\"}\n\n# UUIDs are comparable\nuuid1 = generator.generate(\"user\", email=\"alice@example.com\")\nuuid2 = generator.generate(\"user\", email=\"bob@example.com\")\nprint(uuid1 &lt; uuid2)  # Deterministic comparison\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage - Explore advanced features and customization</li> <li>CLI Reference - Learn about command-line usage</li> <li>Best Practices - Optimize your UUID generation patterns</li> </ul>"},{"location":"guide/best-practices/","title":"Best Practices","text":"<p>Learn the optimal patterns and practices for using UUID-Forge effectively in production systems.</p>"},{"location":"guide/best-practices/#uuid-generation-fundamentals","title":"UUID Generation Fundamentals","text":""},{"location":"guide/best-practices/#understanding-deterministic-uuids","title":"Understanding Deterministic UUIDs","text":"<p>UUID-Forge generates UUIDv5 deterministic identifiers:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Configure generator with namespace and salt\nconfig = IDConfig(\n    namespace=Namespace(\"myapp.com\"),\n    salt=\"v1\"\n)\ngenerator = UUIDGenerator(config)\n\n# Same inputs always produce the same UUID\nuuid1 = generator.generate(\"user\", email=\"alice@example.com\")\nuuid2 = generator.generate(\"user\", email=\"alice@example.com\")\nassert uuid1 == uuid2  # \u2705 Always deterministic\n</code></pre> <p>Benefits:</p> <ul> <li>UUIDv5 uses strong SHA-1 hashing</li> <li>Excellent collision resistance</li> <li>Industry standard for deterministic UUIDs</li> <li>No database lookups needed to find existing IDs</li> </ul>"},{"location":"guide/best-practices/#when-to-use-deterministic-uuids","title":"When to Use Deterministic UUIDs","text":"<p>\u2705 Good Use Cases:</p> <ul> <li>Distributed systems needing consistent IDs</li> <li>Event deduplication in message queues</li> <li>Cache keys that need to be regenerated</li> <li>Cross-service entity identification</li> <li>Idempotent API operations</li> </ul> <p>\u274c Not Suitable For:</p> <ul> <li>Security tokens or session IDs (use random UUIDs)</li> <li>Cryptographic keys (use proper key generation)</li> <li>When inputs might contain PII that shouldn't be hashed</li> </ul>"},{"location":"guide/best-practices/#namespace-design","title":"Namespace Design","text":""},{"location":"guide/best-practices/#hierarchical-namespaces","title":"Hierarchical Namespaces","text":"<p>Design namespaces hierarchically for better organization:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Root namespace for your organization\nROOT_DOMAIN = \"mycompany.com\"\n\n# Service-specific namespaces with hierarchical structure\nuser_service_config = IDConfig(\n    namespace=Namespace(f\"{ROOT_DOMAIN}/user-service\"),\n    salt=\"user-service-v1\"\n)\norder_service_config = IDConfig(\n    namespace=Namespace(f\"{ROOT_DOMAIN}/order-service\"),\n    salt=\"order-service-v1\"\n)\nproduct_service_config = IDConfig(\n    namespace=Namespace(f\"{ROOT_DOMAIN}/product-service\"),\n    salt=\"product-service-v1\"\n)\n\n# Environment-specific separation through salts\ndev_user_config = IDConfig(\n    namespace=Namespace(f\"{ROOT_DOMAIN}/user-service\"),\n    salt=\"user-service-dev\"\n)\nprod_user_config = IDConfig(\n    namespace=Namespace(f\"{ROOT_DOMAIN}/user-service\"),\n    salt=\"user-service-prod\"\n)\n\n# Create generators\nuser_generator = UUIDGenerator(user_service_config)\norder_generator = UUIDGenerator(order_service_config)\n</code></pre>"},{"location":"guide/best-practices/#namespace-naming-conventions","title":"Namespace Naming Conventions","text":"<p>Follow consistent, URL-like naming patterns:</p> <pre><code>from uuid_forge import Namespace\n\n# \u2705 Good: Clear, hierarchical domain-style naming\ngood_namespaces = [\n    Namespace(\"mycompany.com/users/profiles\"),\n    Namespace(\"mycompany.com/users/auth\"),\n    Namespace(\"mycompany.com/orders/processing\"),\n    Namespace(\"mycompany.com/orders/fulfillment\"),\n]\n\n# \u274c Avoid: Ambiguous or flat naming\n# \"ns1\", \"namespace_a\", \"temp_ns\", \"users\"\n\n# \u2705 Include version in the salt instead\nconfig = IDConfig(\n    namespace=Namespace(\"mycompany.com/users\"),\n    salt=\"v2\"  # Version here for easier migration\n)\n</code></pre>"},{"location":"guide/best-practices/#namespace-strategy-for-multi-service-architectures","title":"Namespace Strategy for Multi-Service Architectures","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Dict\n\nclass ServiceNamespaceManager:\n    \"\"\"Central manager for service namespaces\"\"\"\n\n    def __init__(self, organization: str, environment: str = \"production\"):\n        self.organization = organization\n        self.environment = environment\n        self.generators: Dict[str, UUIDGenerator] = {}\n\n    def get_generator(self, service: str, version: str = \"v1\") -&gt; UUIDGenerator:\n        \"\"\"Get generator for a service\"\"\"\n        key = f\"{service}-{version}\"\n        if key not in self.generators:\n            config = IDConfig(\n                namespace=Namespace(f\"{self.organization}/{service}\"),\n                salt=f\"{self.environment}-{version}\"\n            )\n            self.generators[key] = UUIDGenerator(config)\n        return self.generators[key]\n\n# Usage\nmanager = ServiceNamespaceManager(\"mycompany.com\", \"production\")\nuser_gen = manager.get_generator(\"users\", \"v1\")\norder_gen = manager.get_generator(\"orders\", \"v1\")\n</code></pre>"},{"location":"guide/best-practices/#input-data-preparation","title":"Input Data Preparation","text":""},{"location":"guide/best-practices/#canonical-representation","title":"Canonical Representation","text":"<p>Ensure consistent input representation for deterministic UUIDs:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nconfig = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\ndef prepare_user_attributes(user_data: dict) -&gt; dict:\n    \"\"\"Prepare user data for consistent UUID generation\"\"\"\n    return {\n        \"email\": user_data[\"email\"].lower().strip(),\n        \"username\": user_data[\"username\"].lower().strip(),\n        \"department\": user_data.get(\"department\", \"\").lower().strip()\n    }\n\n# Use prepared attributes\nraw_data = {\"email\": \" Alice@Example.COM \", \"username\": \"ALICE\", \"department\": \"Engineering\"}\nclean_attrs = prepare_user_attributes(raw_data)\nuser_uuid = generator.generate(\"user\", **clean_attrs)\n</code></pre>"},{"location":"guide/best-practices/#handle-optional-and-null-values","title":"Handle Optional and Null Values","text":"<p>Be consistent with optional, null, and empty values:</p> <pre><code>def normalize_attributes(data: dict) -&gt; dict:\n    \"\"\"Normalize attributes for UUID generation\"\"\"\n    normalized = {}\n\n    for key, value in data.items():\n        if value is None:\n            normalized[key] = \"\"  # Consistent null representation\n        elif isinstance(value, str):\n            normalized[key] = value.strip().lower()\n        elif isinstance(value, (int, float, bool)):\n            normalized[key] = value\n        else:\n            # Convert other types to string\n            normalized[key] = str(value)\n\n    return normalized\n\n# Usage\nraw_attrs = {\n    \"email\": \"user@example.com\",\n    \"age\": 30,\n    \"verified\": True,\n    \"middle_name\": None,  # Optional field\n}\n\nclean_attrs = normalize_attributes(raw_attrs)\nuser_uuid = generator.generate(\"user\", **clean_attrs)\n</code></pre>"},{"location":"guide/best-practices/#attribute-ordering-and-consistency","title":"Attribute Ordering and Consistency","text":"<p>UUID-Forge handles attribute ordering automatically:</p> <pre><code># These all produce the SAME UUID - order doesn't matter\nuuid1 = generator.generate(\"user\", email=\"a@example.com\", id=123, region=\"us\")\nuuid2 = generator.generate(\"user\", region=\"us\", id=123, email=\"a@example.com\")\nuuid3 = generator.generate(\"user\", id=123, email=\"a@example.com\", region=\"us\")\n\nassert uuid1 == uuid2 == uuid3  # \u2705 All identical\n\n# But different attribute VALUES produce different UUIDs\nuuid4 = generator.generate(\"user\", email=\"a@example.com\", id=123, region=\"eu\")\nassert uuid1 != uuid4  # \u2705 Different region = different UUID\n</code></pre>"},{"location":"guide/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/best-practices/#reuse-generator-instances","title":"Reuse Generator Instances","text":"<p>Create <code>UUIDGenerator</code> instances once and reuse them:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# \u2705 Good: Create once, reuse many times\nclass UserService:\n    def __init__(self):\n        config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n        self.generator = UUIDGenerator(config)\n\n    def create_user_uuid(self, email: str, region: str):\n        return self.generator.generate(\"user\", email=email, region=region)\n\n# \u274c Avoid: Creating new instances repeatedly\ndef create_user_uuid_bad(email: str, region: str):\n    # Inefficient - creates new generator every call\n    config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n    generator = UUIDGenerator(config)\n    return generator.generate(\"user\", email=email, region=region)\n</code></pre>"},{"location":"guide/best-practices/#batch-processing","title":"Batch Processing","text":"<p>Process multiple items efficiently by reusing the generator:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import List, Dict\nfrom uuid import UUID\n\ndef process_users_batch(users: List[Dict[str, str]]) -&gt; List[Dict]:\n    \"\"\"Process multiple users efficiently\"\"\"\n    config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n    generator = UUIDGenerator(config)\n\n    return [\n        {\n            \"uuid\": generator.generate(\"user\", **user),\n            \"data\": user\n        }\n        for user in users\n    ]\n\n# Process thousands of items efficiently\nusers = [\n    {\"email\": \"user1@example.com\", \"region\": \"us\"},\n    {\"email\": \"user2@example.com\", \"region\": \"eu\"},\n    # ... thousands more\n]\nresults = process_users_batch(users)\n</code></pre>"},{"location":"guide/best-practices/#caching-for-repeated-lookups","title":"Caching for Repeated Lookups","text":"<p>Cache UUIDs when the same inputs are queried frequently:</p> <pre><code>from functools import lru_cache\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass CachedUUIDService:\n    def __init__(self, namespace: str, salt: str):\n        config = IDConfig(namespace=Namespace(namespace), salt=salt)\n        self.generator = UUIDGenerator(config)\n\n    @lru_cache(maxsize=10000)\n    def get_user_uuid(self, email: str) -&gt; UUID:\n        \"\"\"Cache frequently accessed user UUIDs\"\"\"\n        return self.generator.generate(\"user\", email=email)\n\n    @lru_cache(maxsize=10000)\n    def get_product_uuid(self, sku: str) -&gt; UUID:\n        \"\"\"Cache frequently accessed product UUIDs\"\"\"\n        return self.generator.generate(\"product\", sku=sku)\n\n    def clear_caches(self):\n        \"\"\"Clear all caches when needed\"\"\"\n        self.get_user_uuid.cache_clear()\n        self.get_product_uuid.cache_clear()\n\n# Usage\nservice = CachedUUIDService(\"myapp.com\", \"v1\")\n\n# First call - generates UUID\nuuid1 = service.get_user_uuid(\"alice@example.com\")\n\n# Second call - returned from cache (fast!)\nuuid2 = service.get_user_uuid(\"alice@example.com\")\n\nassert uuid1 == uuid2\n</code></pre>"},{"location":"guide/best-practices/#when-not-to-cache","title":"When NOT to Cache","text":"<p>Don't cache when:</p> <ul> <li>Inputs are highly varied (low cache hit rate)</li> <li>Memory is constrained</li> <li>UUID generation is already fast enough (it's very fast!)</li> </ul> <p>Do cache when:</p> <ul> <li>Same inputs queried frequently</li> <li>Lookup patterns are predictable</li> <li>Cache hit rate will be high (&gt;50%)</li> </ul>"},{"location":"guide/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"guide/best-practices/#robust-input-validation","title":"Robust Input Validation","text":"<p>Validate inputs before UUID generation:</p> <pre><code>import logging\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\nfrom typing import Optional\n\nlogger = logging.getLogger(__name__)\n\ndef safe_generate_uuid(\n    generator: UUIDGenerator,\n    entity_type: str,\n    **attributes\n) -&gt; Optional[UUID]:\n    \"\"\"Safely generate UUID with proper error handling\"\"\"\n    try:\n        # Validate entity type\n        if not entity_type or not isinstance(entity_type, str):\n            raise ValueError(\"entity_type must be a non-empty string\")\n\n        # Validate attributes\n        if not attributes:\n            raise ValueError(\"At least one attribute must be provided\")\n\n        # Check for None or empty string values\n        for key, value in attributes.items():\n            if value is None or (isinstance(value, str) and not value.strip()):\n                raise ValueError(f\"Attribute '{key}' cannot be None or empty\")\n\n        return generator.generate(entity_type, **attributes)\n\n    except ValueError as e:\n        logger.error(f\"Invalid input for UUID generation: {e}\")\n        raise\n    except Exception as e:\n        logger.error(f\"Unexpected error during UUID generation: {e}\")\n        raise\n\n# Usage\nconfig = IDConfig(namespace=Namespace(\"myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\ntry:\n    user_uuid = safe_generate_uuid(\n        generator,\n        \"user\",\n        email=\"alice@example.com\",\n        region=\"us\"\n    )\nexcept ValueError as e:\n    print(f\"Validation error: {e}\")\n</code></pre>"},{"location":"guide/best-practices/#environment-based-fallback","title":"Environment-Based Fallback","text":"<p>Handle different environments with fallback configurations:</p> <pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Optional\n\ndef create_generator_with_fallback(\n    service_name: str,\n    primary_namespace: Optional[str] = None,\n    fallback_namespace: str = \"default.local\"\n) -&gt; UUIDGenerator:\n    \"\"\"Create generator with environment-based fallback\"\"\"\n    try:\n        # Try to get namespace from environment\n        namespace_domain = (\n            primary_namespace\n            or os.environ.get(\"UUID_NAMESPACE_DOMAIN\")\n            or fallback_namespace\n        )\n\n        config = IDConfig(\n            namespace=Namespace(f\"{namespace_domain}/{service_name}\"),\n            salt=os.environ.get(\"UUID_SALT_VERSION\", \"v1\")\n        )\n\n        logger.info(f\"Created UUID generator for {service_name} with namespace {namespace_domain}\")\n        return UUIDGenerator(config)\n\n    except Exception as e:\n        logger.warning(f\"Failed to create primary generator: {e}, using fallback\")\n        # Use fallback configuration\n        config = IDConfig(\n            namespace=Namespace(f\"{fallback_namespace}/{service_name}\"),\n            salt=\"v1\"\n        )\n        return UUIDGenerator(config)\n\n# Usage\ngenerator = create_generator_with_fallback(\"users\", primary_namespace=\"mycompany.com\")\n</code></pre>"},{"location":"guide/best-practices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"guide/best-practices/#deterministic-testing","title":"Deterministic Testing","text":"<p>Leverage determinism for reliable, reproducible tests:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\ndef test_user_uuid_generation_is_deterministic():\n    \"\"\"Test that UUID generation is deterministic\"\"\"\n    config = IDConfig(namespace=Namespace(\"test.myapp.com\"), salt=\"test-v1\")\n    generator = UUIDGenerator(config)\n\n    # Generate UUID multiple times with same inputs\n    uuid1 = generator.generate(\"user\", email=\"test@example.com\", name=\"Test User\")\n    uuid2 = generator.generate(\"user\", email=\"test@example.com\", name=\"Test User\")\n\n    # Should be identical\n    assert uuid1 == uuid2\n    assert isinstance(uuid1, UUID)\n\ndef test_different_inputs_produce_different_uuids():\n    \"\"\"Test that different inputs produce different UUIDs\"\"\"\n    config = IDConfig(namespace=Namespace(\"test.myapp.com\"), salt=\"test-v1\")\n    generator = UUIDGenerator(config)\n\n    uuid1 = generator.generate(\"user\", email=\"alice@example.com\")\n    uuid2 = generator.generate(\"user\", email=\"bob@example.com\")\n\n    # Different inputs = different UUIDs\n    assert uuid1 != uuid2\n\ndef test_attribute_order_independence():\n    \"\"\"Test that attribute order doesn't matter\"\"\"\n    config = IDConfig(namespace=Namespace(\"test.myapp.com\"), salt=\"test-v1\")\n    generator = UUIDGenerator(config)\n\n    uuid1 = generator.generate(\"user\", email=\"test@example.com\", id=123, region=\"us\")\n    uuid2 = generator.generate(\"user\", region=\"us\", id=123, email=\"test@example.com\")\n\n    # Same attributes in different order = same UUID\n    assert uuid1 == uuid2\n</code></pre>"},{"location":"guide/best-practices/#test-data-management","title":"Test Data Management","text":"<p>Use consistent test fixtures:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Test fixtures\n@pytest.fixture\ndef test_generator():\n    \"\"\"Create a generator for testing\"\"\"\n    config = IDConfig(namespace=Namespace(\"test.example.com\"), salt=\"test-v1\")\n    return UUIDGenerator(config)\n\n@pytest.fixture\ndef test_users():\n    \"\"\"Sample test users\"\"\"\n    return [\n        {\"email\": \"user1@test.com\", \"region\": \"us\"},\n        {\"email\": \"user2@test.com\", \"region\": \"eu\"},\n        {\"email\": \"user3@test.com\", \"region\": \"asia\"},\n    ]\n\ndef test_batch_uuid_generation(test_generator, test_users):\n    \"\"\"Test batch UUID generation\"\"\"\n    uuids = [\n        test_generator.generate(\"user\", **user)\n        for user in test_users\n    ]\n\n    # All UUIDs should be unique (different inputs)\n    assert len(set(uuids)) == len(uuids)\n\n    # All should be valid UUID objects\n    for uuid_obj in uuids:\n        assert isinstance(uuid_obj, UUID)\n\ndef test_uuid_regeneration(test_generator, test_users):\n    \"\"\"Test that UUIDs can be regenerated\"\"\"\n    # Generate UUIDs for all users\n    original_uuids = [\n        test_generator.generate(\"user\", **user)\n        for user in test_users\n    ]\n\n    # Regenerate UUIDs for same users\n    regenerated_uuids = [\n        test_generator.generate(\"user\", **user)\n        for user in test_users\n    ]\n\n    # Should be identical\n    assert original_uuids == regenerated_uuids\n</code></pre>"},{"location":"guide/best-practices/#production-deployment","title":"Production Deployment","text":""},{"location":"guide/best-practices/#configuration-management","title":"Configuration Management","text":"<p>Use environment-specific configuration:</p> <pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nimport logging\n\nlogger = logging.getLogger(__name__)\n\ndef create_production_generator(service_name: str) -&gt; UUIDGenerator:\n    \"\"\"Create generator with production configuration from environment\"\"\"\n    # Get configuration from environment variables\n    namespace_domain = os.environ.get(\n        \"UUID_NAMESPACE_DOMAIN\",\n        \"myapp.com\"  # fallback\n    )\n\n    environment = os.environ.get(\"APP_ENVIRONMENT\", \"production\")\n    version = os.environ.get(\"UUID_VERSION\", \"v1\")\n\n    # Create configuration\n    config = IDConfig(\n        namespace=Namespace(f\"{namespace_domain}/{service_name}\"),\n        salt=f\"{environment}-{version}\"\n    )\n\n    logger.info(\n        f\"Created UUID generator: service={service_name}, \"\n        f\"namespace={namespace_domain}, env={environment}, version={version}\"\n    )\n\n    return UUIDGenerator(config)\n\n# Usage\nuser_generator = create_production_generator(\"users\")\norder_generator = create_production_generator(\"orders\")\n</code></pre>"},{"location":"guide/best-practices/#monitoring-and-logging","title":"Monitoring and Logging","text":"<p>Monitor UUID generation in production:</p> <pre><code>import logging\nimport time\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\nfrom typing import Any\n\nlogger = logging.getLogger(__name__)\n\nclass MonitoredUUIDGenerator:\n    \"\"\"UUID generator with monitoring and metrics\"\"\"\n\n    def __init__(self, namespace: str, salt: str):\n        config = IDConfig(namespace=Namespace(namespace), salt=salt)\n        self.generator = UUIDGenerator(config)\n        self.generation_count = 0\n        self.total_time = 0.0\n\n    def generate(self, entity_type: str, **attributes) -&gt; UUID:\n        \"\"\"Generate UUID with monitoring\"\"\"\n        start_time = time.time()\n\n        try:\n            result = self.generator.generate(entity_type, **attributes)\n            self.generation_count += 1\n\n            duration = time.time() - start_time\n            self.total_time += duration\n\n            # Log every 1000 generations\n            if self.generation_count % 1000 == 0:\n                avg_time = self.total_time / self.generation_count\n                logger.info(\n                    f\"UUID stats: count={self.generation_count}, \"\n                    f\"avg_time={avg_time*1000:.2f}ms\"\n                )\n\n            return result\n\n        except Exception as e:\n            logger.error(f\"UUID generation failed: entity_type={entity_type}, error={e}\")\n            raise\n\n    def get_stats(self) -&gt; dict:\n        \"\"\"Get generation statistics\"\"\"\n        return {\n            \"generation_count\": self.generation_count,\n            \"total_time_seconds\": self.total_time,\n            \"average_time_ms\": (self.total_time / self.generation_count * 1000)\n            if self.generation_count &gt; 0\n            else 0,\n        }\n\n# Usage\ngenerator = MonitoredUUIDGenerator(\"myapp.com/users\", \"prod-v1\")\n\n# Generate many UUIDs\nfor i in range(10000):\n    uuid = generator.generate(\"user\", id=i, region=\"us\")\n\n# Check stats\nstats = generator.get_stats()\nprint(f\"Generated {stats['generation_count']} UUIDs\")\nprint(f\"Average time: {stats['average_time_ms']:.2f}ms\")\n</code></pre>"},{"location":"guide/best-practices/#security-considerations","title":"Security Considerations","text":""},{"location":"guide/best-practices/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>\u26a0\ufe0f Important: UUID-Forge UUIDs are deterministic. Anyone with the same inputs can generate the same UUID.</p> <p>Do NOT use for:</p> <ul> <li>Session tokens</li> <li>Authentication tokens</li> <li>Password reset tokens</li> <li>API keys</li> <li>Cryptographic keys</li> </ul> <p>Best Practices:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom datetime import date\n\nconfig = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\ndef generate_user_uuid_safe(user_data: dict):\n    \"\"\"Generate UUID using only non-sensitive identifiers\"\"\"\n    # \u2705 Safe: Use non-sensitive business identifiers\n    safe_attributes = {\n        \"user_id\": user_data[\"id\"],  # Internal ID\n        \"account_type\": user_data[\"account_type\"],  # Public info\n        \"created_date\": user_data[\"created_at\"].date().isoformat()  # Public info\n    }\n\n    # \u274c NEVER include in UUIDs:\n    # - passwords (even hashed)\n    # - social security numbers\n    # - credit card numbers\n    # - health information\n    # - other PII that shouldn't be deterministically exposed\n\n    return generator.generate(\"user\", **safe_attributes)\n\n# Good: Email addresses CAN be used if acceptable in your use case\ndef generate_user_uuid_from_email(email: str):\n    \"\"\"Generate UUID from email (if appropriate for your security model)\"\"\"\n    # This is deterministic - same email always produces same UUID\n    # Only use if this behavior is acceptable in your system\n    return generator.generate(\"user\", email=email.lower())\n</code></pre>"},{"location":"guide/best-practices/#namespace-isolation-by-security-context","title":"Namespace Isolation by Security Context","text":"<p>Isolate UUIDs by security level or access context:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Dict\nfrom enum import Enum\n\nclass SecurityContext(Enum):\n    PUBLIC = \"public\"\n    INTERNAL = \"internal\"\n    ADMIN = \"admin\"\n\nclass ContextualUUIDGenerator:\n    \"\"\"Generate UUIDs with security context isolation\"\"\"\n\n    def __init__(self, base_namespace: str):\n        self.generators: Dict[SecurityContext, UUIDGenerator] = {}\n\n        # Create separate generators for each context\n        for context in SecurityContext:\n            config = IDConfig(\n                namespace=Namespace(f\"{base_namespace}/{context.value}\"),\n                salt=f\"{context.value}-v1\"\n            )\n            self.generators[context] = UUIDGenerator(config)\n\n    def generate(self, context: SecurityContext, entity_type: str, **attributes):\n        \"\"\"Generate UUID for a specific security context\"\"\"\n        return self.generators[context].generate(entity_type, **attributes)\n\n# Usage\nmanager = ContextualUUIDGenerator(\"myapp.com\")\n\n# Public-facing resource UUIDs\npublic_uuid = manager.generate(\n    SecurityContext.PUBLIC,\n    \"article\",\n    slug=\"hello-world\"\n)\n\n# Internal system UUIDs\ninternal_uuid = manager.generate(\n    SecurityContext.INTERNAL,\n    \"audit_log\",\n    user_id=123,\n    action=\"login\"\n)\n\n# Admin-only resource UUIDs\nadmin_uuid = manager.generate(\n    SecurityContext.ADMIN,\n    \"system_config\",\n    key=\"database_connection\"\n)\n\n# Same inputs, different contexts = different UUIDs\nassert public_uuid != internal_uuid != admin_uuid\n</code></pre>"},{"location":"guide/best-practices/#migration-and-versioning","title":"Migration and Versioning","text":""},{"location":"guide/best-practices/#salt-based-version-migration","title":"Salt-Based Version Migration","text":"<p>Use salts to version your UUID generation scheme:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom typing import Dict, Tuple\nfrom uuid import UUID\n\nclass UUIDMigrationService:\n    \"\"\"Manage UUID schema migrations using salts\"\"\"\n\n    def __init__(self, namespace: str):\n        self.namespace = namespace\n        self.generators = {}\n\n    def get_generator(self, version: str) -&gt; UUIDGenerator:\n        \"\"\"Get generator for a specific version\"\"\"\n        if version not in self.generators:\n            config = IDConfig(\n                namespace=Namespace(self.namespace),\n                salt=version\n            )\n            self.generators[version] = UUIDGenerator(config)\n        return self.generators[version]\n\n    def migrate_entity(\n        self,\n        entity_type: str,\n        old_version: str,\n        new_version: str,\n        **attributes\n    ) -&gt; Tuple[UUID, UUID]:\n        \"\"\"Generate both old and new UUIDs for migration\"\"\"\n        old_gen = self.get_generator(old_version)\n        new_gen = self.get_generator(new_version)\n\n        old_uuid = old_gen.generate(entity_type, **attributes)\n        new_uuid = new_gen.generate(entity_type, **attributes)\n\n        return old_uuid, new_uuid\n\n# Usage: Migrating from v1 to v2 UUID scheme\nmigration = UUIDMigrationService(\"users.myapp.com\")\n\n# Generate migration mapping\nusers = [\n    {\"email\": \"alice@example.com\", \"region\": \"us\"},\n    {\"email\": \"bob@example.com\", \"region\": \"eu\"},\n]\n\nmigration_map = {}\nfor user in users:\n    old_uuid, new_uuid = migration.migrate_entity(\n        \"user\",\n        old_version=\"v1\",\n        new_version=\"v2\",\n        **user\n    )\n    migration_map[old_uuid] = new_uuid\n    print(f\"Migrate {old_uuid} -&gt; {new_uuid}\")\n\n# Update database\n# for old_uuid, new_uuid in migration_map.items():\n#     db.execute(\"UPDATE users SET id = %s WHERE id = %s\", (new_uuid, old_uuid))\n</code></pre>"},{"location":"guide/best-practices/#zero-downtime-migration-strategy","title":"Zero-Downtime Migration Strategy","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\nfrom typing import Optional\n\nclass DualVersionUUIDGenerator:\n    \"\"\"Support both old and new UUID versions during migration\"\"\"\n\n    def __init__(self, namespace: str, old_salt: str, new_salt: str):\n        old_config = IDConfig(namespace=Namespace(namespace), salt=old_salt)\n        new_config = IDConfig(namespace=Namespace(namespace), salt=new_salt)\n\n        self.old_generator = UUIDGenerator(old_config)\n        self.new_generator = UUIDGenerator(new_config)\n        self.use_new_version = False  # Feature flag\n\n    def generate(self, entity_type: str, **attributes) -&gt; UUID:\n        \"\"\"Generate UUID using current version\"\"\"\n        if self.use_new_version:\n            return self.new_generator.generate(entity_type, **attributes)\n        return self.old_generator.generate(entity_type, **attributes)\n\n    def lookup_uuid(self, entity_type: str, **attributes) -&gt; UUID:\n        \"\"\"Try new version first, fallback to old for lookups\"\"\"\n        if self.use_new_version:\n            return self.new_generator.generate(entity_type, **attributes)\n\n        # During migration, might need to check both versions\n        return self.old_generator.generate(entity_type, **attributes)\n\n# Migration phases:\n# Phase 1: Deploy code with both generators, use_new_version=False\ndual = DualVersionUUIDGenerator(\"users.myapp.com\", \"v1\", \"v2\")\n\n# Phase 2: Run migration script to update all UUIDs in database\n\n# Phase 3: Enable new version via feature flag\ndual.use_new_version = True\n\n# Phase 4: After verification, remove old generator code\n</code></pre>"},{"location":"guide/best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":""},{"location":"guide/best-practices/#inconsistent-input-normalization","title":"\u274c Inconsistent Input Normalization","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nconfig = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\n# \u274c DON'T: Inconsistent casing and whitespace\nuuid1 = generator.generate(\"user\", email=\"User@Example.Com \")\nuuid2 = generator.generate(\"user\", email=\"user@example.com\")\n# These will be DIFFERENT because inputs differ!\n\n# \u2705 DO: Always normalize inputs\ndef normalize_email(email: str) -&gt; str:\n    return email.lower().strip()\n\nuuid1 = generator.generate(\"user\", email=normalize_email(\"User@Example.Com \"))\nuuid2 = generator.generate(\"user\", email=normalize_email(\"user@example.com\"))\n# Now these are the SAME \u2713\n</code></pre>"},{"location":"guide/best-practices/#creating-new-generator-instances-repeatedly","title":"\u274c Creating New Generator Instances Repeatedly","text":"<pre><code># \u274c DON'T: Create new generator every call (inefficient)\ndef get_user_uuid_bad(user_email: str):\n    config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n    generator = UUIDGenerator(config)  # New instance every time!\n    return generator.generate(\"user\", email=user_email)\n\n# \u2705 DO: Create once, reuse many times\nclass UserService:\n    def __init__(self):\n        config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n        self.generator = UUIDGenerator(config)  # Created once\n\n    def get_user_uuid(self, user_email: str):\n        return self.generator.generate(\"user\", email=user_email)\n</code></pre>"},{"location":"guide/best-practices/#mixing-saltsnamespaces-for-same-entity","title":"\u274c Mixing Salts/Namespaces for Same Entity","text":"<pre><code># \u274c DON'T: Use different configurations for the same entity type\nconfig_a = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\nconfig_b = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v2\")\n\ngen_a = UUIDGenerator(config_a)\ngen_b = UUIDGenerator(config_b)\n\n# These will be DIFFERENT UUIDs for the same user!\nuuid_a = gen_a.generate(\"user\", email=\"alice@example.com\")\nuuid_b = gen_b.generate(\"user\", email=\"alice@example.com\")\nassert uuid_a != uuid_b  # Different salts = different UUIDs\n\n# \u2705 DO: Use consistent configuration throughout your application\n</code></pre>"},{"location":"guide/best-practices/#including-timestamps-in-deterministic-uuids","title":"\u274c Including Timestamps in Deterministic UUIDs","text":"<pre><code>from datetime import datetime\n\n# \u274c DON'T: Include current timestamp (non-deterministic!)\ndef create_event_uuid_bad(event_type: str, user_id: int):\n    return generator.generate(\n        \"event\",\n        event_type=event_type,\n        user_id=user_id,\n        timestamp=datetime.utcnow().isoformat()  # Changes every call!\n    )\n\n# This defeats the purpose - UUIDs will be different every time!\n\n# \u2705 DO: Only include deterministic attributes\ndef create_event_uuid_good(event_type: str, user_id: int, event_date: str):\n    return generator.generate(\n        \"event\",\n        event_type=event_type,\n        user_id=user_id,\n        event_date=event_date  # Use date, not timestamp\n    )\n</code></pre>"},{"location":"guide/best-practices/#forgetting-entity-type-parameter","title":"\u274c Forgetting Entity Type Parameter","text":"<pre><code># \u274c DON'T: Forget the entity_type parameter\n# uuid = generator.generate(email=\"alice@example.com\")  # TypeError!\n\n# \u2705 DO: Always include entity_type as first argument\nuuid = generator.generate(\"user\", email=\"alice@example.com\")\n</code></pre>"},{"location":"guide/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>Use Cases - See real-world implementation examples</li> <li>API Reference - Detailed API documentation</li> <li>Development - Contributing to UUID-Forge</li> </ul>"},{"location":"guide/cli/","title":"CLI Reference","text":"<p>UUID-Forge provides a powerful command-line interface for generating deterministic UUIDs, managing configuration, and validating security settings.</p>"},{"location":"guide/cli/#installation","title":"Installation","text":"<p>The CLI is installed automatically with UUID-Forge:</p> <pre><code>pip install uuid-forge\n</code></pre> <p>or with uv:</p> <pre><code>uv add uuid-forge\n</code></pre>"},{"location":"guide/cli/#available-commands","title":"Available Commands","text":"<p>UUID-Forge CLI provides the following commands:</p> <ul> <li><code>generate</code> - Generate deterministic UUIDs</li> <li><code>extract</code> - Extract UUID from prefixed identifiers</li> <li><code>new-salt</code> - Generate cryptographic salt</li> <li><code>init</code> - Initialize configuration file</li> <li><code>validate</code> - Validate security configuration</li> <li><code>info</code> - Display configuration information</li> <li><code>docs</code> - Build or serve documentation</li> <li><code>test</code> - Run test suite</li> </ul>"},{"location":"guide/cli/#generate-command","title":"Generate Command","text":"<p>Generate a deterministic UUID for an entity.</p>"},{"location":"guide/cli/#basic-usage","title":"Basic Usage","text":"<pre><code>uuid-forge generate ENTITY_TYPE --attr key=value\n</code></pre>"},{"location":"guide/cli/#arguments","title":"Arguments","text":"<ul> <li><code>ENTITY_TYPE</code> - Type of entity (e.g., 'invoice', 'order', 'user') [required]</li> </ul>"},{"location":"guide/cli/#options","title":"Options","text":"<ul> <li><code>--attr, -a</code> - Attributes in key=value format (can be used multiple times)</li> <li><code>--prefix, -p</code> - Human-readable prefix for the UUID</li> <li><code>--separator, -s</code> - Separator between prefix and UUID (default: -)</li> <li><code>--namespace, -n</code> - Custom namespace domain (e.g., 'mycompany.com')</li> <li><code>--salt</code> - Cryptographic salt (leave empty to use environment variable)</li> <li><code>--env/--no-env</code> - Load configuration from environment variables (default: env)</li> </ul>"},{"location":"guide/cli/#examples","title":"Examples","text":""},{"location":"guide/cli/#simple-generation","title":"Simple Generation","text":"<pre><code># Generate user UUID from email\nuuid-forge generate user --attr email=alice@example.com\n\n# Generate invoice UUID with multiple attributes\nuuid-forge generate invoice --attr region=EUR --attr number=12345\n</code></pre>"},{"location":"guide/cli/#with-prefix","title":"With Prefix","text":"<pre><code># Generate with human-readable prefix\nuuid-forge generate invoice --prefix INV-EUR --attr region=EUR --attr number=12345\n# Output: INV-EUR-550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/cli/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Custom namespace and salt\nuuid-forge generate user \\\n  --namespace mycompany.com \\\n  --salt \"my-secret\" \\\n  --attr email=user@example.com\n</code></pre>"},{"location":"guide/cli/#using-environment-variables","title":"Using Environment Variables","text":"<pre><code># Set configuration via environment\nexport UUID_FORGE_SALT=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\nexport UUID_FORGE_NAMESPACE=\"mycompany.com\"\n\n# Generate using environment config\nuuid-forge generate invoice --attr region=EUR --attr number=12345\n</code></pre>"},{"location":"guide/cli/#extract-command","title":"Extract Command","text":"<p>Extract the UUID portion from a prefixed identifier.</p>"},{"location":"guide/cli/#usage","title":"Usage","text":"<pre><code>uuid-forge extract PREFIXED_ID\n</code></pre>"},{"location":"guide/cli/#example","title":"Example","text":"<pre><code>uuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n# Output: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/cli/#new-salt-command","title":"New-Salt Command","text":"<p>Generate a new cryptographically secure salt.</p>"},{"location":"guide/cli/#usage_1","title":"Usage","text":"<pre><code>uuid-forge new-salt\n</code></pre>"},{"location":"guide/cli/#example_1","title":"Example","text":"<pre><code># Generate a new salt\nuuid-forge new-salt\n# Output: xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\n\n# Save to environment variable\nexport UUID_FORGE_SALT=$(uuid-forge new-salt)\n</code></pre>"},{"location":"guide/cli/#init-command","title":"Init Command","text":"<p>Initialize a new configuration file with a generated salt.</p>"},{"location":"guide/cli/#usage_2","title":"Usage","text":"<pre><code>uuid-forge init\n</code></pre>"},{"location":"guide/cli/#example_2","title":"Example","text":"<pre><code># Create .env file with UUID_FORGE_SALT\nuuid-forge init\n\n# Or specify custom file\nuuid-forge init --file config/.env\n</code></pre>"},{"location":"guide/cli/#validate-command","title":"Validate Command","text":"<p>Validate your current configuration for security best practices.</p>"},{"location":"guide/cli/#usage_3","title":"Usage","text":"<pre><code>uuid-forge validate\n</code></pre>"},{"location":"guide/cli/#example_3","title":"Example","text":"<pre><code># Validate environment configuration\nexport UUID_FORGE_SALT=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\nexport UUID_FORGE_NAMESPACE=\"mycompany.com\"\nuuid-forge validate\n\n# Output will show:\n# \u2705 Salt is set and has adequate entropy\n# \u2705 Namespace is configured\n# \u2705 Configuration is secure\n</code></pre>"},{"location":"guide/cli/#info-command","title":"Info Command","text":"<p>Display information about your current configuration and usage.</p>"},{"location":"guide/cli/#usage_4","title":"Usage","text":"<pre><code>uuid-forge info\n</code></pre>"},{"location":"guide/cli/#example_4","title":"Example","text":"<pre><code>uuid-forge info\n# Output:\n# UUID-Forge Configuration\n# ------------------------\n# Namespace: mycompany.com\n# Salt: ***configured***\n# Version: 0.1.0\n</code></pre>"},{"location":"guide/cli/#docs-command","title":"Docs Command","text":"<p>Build or serve the documentation locally.</p>"},{"location":"guide/cli/#usage_5","title":"Usage","text":"<pre><code>uuid-forge docs [serve|build]\n</code></pre>"},{"location":"guide/cli/#examples_1","title":"Examples","text":"<pre><code># Serve docs locally at http://127.0.0.1:8000\nuuid-forge docs serve\n\n# Build docs to site/ directory\nuuid-forge docs build\n</code></pre>"},{"location":"guide/cli/#test-command","title":"Test Command","text":"<p>Run the test suite with pytest.</p>"},{"location":"guide/cli/#usage_6","title":"Usage","text":"<pre><code>uuid-forge test\n</code></pre>"},{"location":"guide/cli/#examples_2","title":"Examples","text":"<pre><code># Run all tests\nuuid-forge test\n\n# Run with coverage\nuuid-forge test --cov\n\n# Run specific test file\nuuid-forge test tests/test_core.py\n</code></pre>"},{"location":"guide/cli/#environment-variables","title":"Environment Variables","text":"<p>UUID-Forge supports configuration via environment variables:</p> Variable Description Example <code>UUID_FORGE_SALT</code> Cryptographic salt for UUID generation <code>xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB</code> <code>UUID_FORGE_NAMESPACE</code> Default namespace domain <code>mycompany.com</code>"},{"location":"guide/cli/#setting-environment-variables","title":"Setting Environment Variables","text":"<pre><code># Linux/macOS\nexport UUID_FORGE_SALT=\"your-salt-here\"\nexport UUID_FORGE_NAMESPACE=\"mycompany.com\"\n\n# Windows (PowerShell)\n$env:UUID_FORGE_SALT=\"your-salt-here\"\n$env:UUID_FORGE_NAMESPACE=\"mycompany.com\"\n\n# Or use a .env file\necho \"UUID_FORGE_SALT=your-salt-here\" &gt; .env\necho \"UUID_FORGE_NAMESPACE=mycompany.com\" &gt;&gt; .env\n</code></pre>"},{"location":"guide/cli/#common-workflows","title":"Common Workflows","text":""},{"location":"guide/cli/#first-time-setup","title":"First-Time Setup","text":"<pre><code># 1. Generate a secure salt\nuuid-forge new-salt\n\n# 2. Initialize configuration\nuuid-forge init\n\n# 3. Validate setup\nuuid-forge validate\n\n# 4. Generate your first UUID\nuuid-forge generate user --attr email=test@example.com\n</code></pre>"},{"location":"guide/cli/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># Set configuration in CI environment\nexport UUID_FORGE_SALT=\"${SECRET_SALT}\"\nexport UUID_FORGE_NAMESPACE=\"mycompany.com\"\n\n# Generate UUIDs in pipeline\nuuid-forge generate deployment \\\n  --attr branch=\"${CI_BRANCH}\" \\\n  --attr commit=\"${CI_COMMIT_SHA}\" \\\n  --attr timestamp=\"$(date -Iseconds)\"\n</code></pre>"},{"location":"guide/cli/#development-workflow","title":"Development Workflow","text":"<pre><code># Use environment-specific configuration\nexport UUID_FORGE_NAMESPACE=\"dev.mycompany.com\"\nexport UUID_FORGE_SALT=\"${DEV_SALT}\"\n\n# Generate test data\nuuid-forge generate user --attr email=dev@example.com\nuuid-forge generate order --attr id=12345 --attr region=test\n</code></pre>"},{"location":"guide/cli/#error-handling","title":"Error Handling","text":""},{"location":"guide/cli/#missing-configuration","title":"Missing Configuration","text":"<pre><code>$ uuid-forge generate user --attr email=test@example.com\nError: UUID_FORGE_SALT environment variable not set\nSolution: Run 'uuid-forge init' or set UUID_FORGE_SALT manually\n</code></pre>"},{"location":"guide/cli/#invalid-attribute-format","title":"Invalid Attribute Format","text":"<pre><code>$ uuid-forge generate user --attr email:test@example.com\nError: Invalid attribute format: email:test@example.com\nUse key=value format.\n</code></pre>"},{"location":"guide/cli/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"guide/cli/#1-use-shell-aliases","title":"1. Use Shell Aliases","text":"<pre><code># Add to ~/.bashrc or ~/.zshrc\nalias uuid='uuid-forge generate'\n\n# Usage\nuuid user --attr email=alice@example.com\n</code></pre>"},{"location":"guide/cli/#2-batch-generation-with-xargs","title":"2. Batch Generation with xargs","text":"<pre><code># Generate UUIDs for multiple emails\ncat emails.txt | xargs -I {} uuid-forge generate user --attr email={}\n</code></pre>"},{"location":"guide/cli/#3-integration-with-jq","title":"3. Integration with jq","text":"<pre><code># Generate UUID and create JSON\nUSER_UUID=$(uuid-forge generate user --attr email=alice@example.com)\necho \"{\\\"id\\\": \\\"$USER_UUID\\\", \\\"email\\\": \\\"alice@example.com\\\"}\" | jq .\n</code></pre>"},{"location":"guide/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage Guide - Learn the Python API</li> <li>Best Practices - Production configuration</li> <li>Configuration Guide - Detailed setup</li> </ul>"},{"location":"guide/concepts/","title":"Core Concepts","text":"<p>Understanding the core concepts behind UUID-Forge will help you use it effectively in your applications.</p>"},{"location":"guide/concepts/#what-are-uuids","title":"What are UUIDs?","text":"<p>UUIDs (Universally Unique Identifiers) are 128-bit values used to uniquely identify information in computer systems. They are designed to be unique across space and time without requiring a central authority.</p>"},{"location":"guide/concepts/#deterministic-generation","title":"Deterministic Generation","text":"<p>UUID-Forge specializes in deterministic UUID generation, meaning that given the same input, it will always produce the same UUID. This is crucial for:</p> <ul> <li>Cross-system coordination: Different services can generate the same UUID for the same entity</li> <li>Data consistency: Ensures referential integrity across distributed systems</li> <li>Testing: Predictable UUIDs make testing easier and more reliable</li> <li>Migration: Consistent UUIDs during data migration and transformation</li> </ul>"},{"location":"guide/concepts/#uuid-versions","title":"UUID Versions","text":"<p>UUID-Forge supports multiple UUID versions:</p>"},{"location":"guide/concepts/#version-3-md5-hash","title":"Version 3 (MD5 Hash)","text":"<ul> <li>Uses MD5 hashing algorithm</li> <li>Deterministic based on namespace and name</li> <li>Legacy support (MD5 is considered weak)</li> </ul>"},{"location":"guide/concepts/#version-4-random","title":"Version 4 (Random)","text":"<ul> <li>Randomly generated</li> <li>Not deterministic by nature</li> <li>Highest entropy</li> </ul>"},{"location":"guide/concepts/#version-5-sha-1-hash","title":"Version 5 (SHA-1 Hash)","text":"<ul> <li>Uses SHA-1 hashing algorithm</li> <li>Deterministic based on namespace and name</li> <li>Recommended for most deterministic use cases</li> </ul>"},{"location":"guide/concepts/#namespaces","title":"Namespaces","text":"<p>Namespaces are used to create logical groupings of UUIDs. They ensure that:</p> <ul> <li>UUIDs generated with different namespaces are unique</li> <li>Same name in different namespaces produces different UUIDs</li> <li>Hierarchical organization of UUID generation</li> </ul>"},{"location":"guide/concepts/#standard-namespaces","title":"Standard Namespaces","text":"<p>UUID-Forge provides several predefined namespaces:</p> <ul> <li><code>DNS</code>: For domain names</li> <li><code>URL</code>: For URLs</li> <li><code>OID</code>: For ISO OIDs</li> <li><code>X500</code>: For X.500 Distinguished Names</li> </ul>"},{"location":"guide/concepts/#custom-namespaces","title":"Custom Namespaces","text":"<p>You can define custom namespaces for your application:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\n# Create a namespace for your application domain\nmy_namespace = Namespace(\"myapp.com/users\")\n\n# Configure and create generator\nconfig = IDConfig(namespace=my_namespace, salt=\"v1\")\ngenerator = UUIDGenerator(config)\n</code></pre>"},{"location":"guide/concepts/#input-processing","title":"Input Processing","text":"<p>UUID-Forge can process various input types:</p> <ul> <li>Strings: Text data, identifiers, names</li> <li>Dictionaries: Structured data converted to canonical form</li> <li>Objects: Any object with string representation</li> <li>Binary data: Raw bytes</li> </ul>"},{"location":"guide/concepts/#determinism-guarantees","title":"Determinism Guarantees","text":"<p>UUID-Forge guarantees that:</p> <ol> <li>Same input \u2192 Same UUID (within same namespace and configuration)</li> <li>Different input \u2192 Different UUID (with high probability)</li> <li>Cross-platform consistency (same UUID on different systems)</li> <li>Version consistency (same UUID across UUID-Forge versions)</li> </ol>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Learn how to generate your first UUIDs</li> <li>Advanced Usage - Explore advanced features</li> <li>Best Practices - Learn optimal usage patterns</li> </ul>"},{"location":"use-cases/microservices/","title":"Microservices Architecture","text":"<p>Learn how to use UUID-Forge effectively in microservices architectures for consistent entity identification across services.</p>"},{"location":"use-cases/microservices/#overview","title":"Overview","text":"<p>In microservices architectures, UUID-Forge solves the critical problem of consistent entity identification across distributed services. By generating deterministic UUIDs, different services can independently create the same UUID for the same entity, eliminating the need for centralized ID generation or complex coordination.</p>"},{"location":"use-cases/microservices/#key-benefits","title":"Key Benefits","text":"<ul> <li>Service Independence: Services can generate UUIDs without inter-service communication</li> <li>Data Consistency: Same entity gets same UUID across all services</li> <li>Event Sourcing: Consistent UUIDs for event correlation</li> <li>Testing: Predictable UUIDs simplify integration testing</li> </ul>"},{"location":"use-cases/microservices/#service-design-patterns","title":"Service Design Patterns","text":""},{"location":"use-cases/microservices/#1-namespace-per-service-pattern","title":"1. Namespace-per-Service Pattern","text":"<p>Each service uses its own namespace for entity isolation:</p> <pre><code># User Service\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nimport os\n\n# Service-specific namespace and configuration\nuser_config = IDConfig(\n    namespace=Namespace(\"user-service.mycompany.com\"),\n    salt=os.getenv(\"UUID_FORGE_SALT\")\n)\nuser_forge = UUIDGenerator(config=user_config)\n\nclass UserService:\n    def create_user(self, email, name):\n        # Generate deterministic user ID from email\n        user_id = user_forge.generate(\n            \"user\",\n            email=email.lower().strip()\n        )\n        return {\"id\": user_id, \"email\": email, \"name\": name}\n</code></pre> <pre><code># Order Service\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nimport os\n\norder_config = IDConfig(\n    namespace=Namespace(\"order-service.mycompany.com\"),\n    salt=os.getenv(\"UUID_FORGE_SALT\")\n)\norder_forge = UUIDGenerator(config=order_config)\n\n# Shared user generator to create consistent user references\nuser_forge = UUIDGenerator(config=user_config)\n\nclass OrderService:\n    def create_order(self, user_email, items):\n        # Generate consistent user reference (same as User Service!)\n        user_id = user_forge.generate(\n            \"user\",\n            email=user_email.lower().strip()\n        )\n\n        # Generate order ID\n        order_id = order_forge.generate(\n            \"order\",\n            user_email=user_email.lower().strip(),\n            items=tuple(sorted(items))  # Use tuple for hashability\n        )\n\n        return {\"id\": order_id, \"user_id\": user_id, \"items\": items}\n</code></pre>"},{"location":"use-cases/microservices/#2-entity-type-based-namespaces","title":"2. Entity-Type-Based Namespaces","text":"<p>Create namespaces based on entity types for organizational consistency:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nimport os\n\n# Entity-specific namespaces under your organization's domain\nUSERS_NS = Namespace(\"users.mycompany.com\")\nORDERS_NS = Namespace(\"orders.mycompany.com\")\nPRODUCTS_NS = Namespace(\"products.mycompany.com\")\n\n# Shared configuration with salt\nsalt = os.getenv(\"UUID_FORGE_SALT\")\n\n# Shared generator instances with their respective namespaces\nuser_forge = UUIDGenerator(config=IDConfig(namespace=USERS_NS, salt=salt))\norder_forge = UUIDGenerator(config=IDConfig(namespace=ORDERS_NS, salt=salt))\nproduct_forge = UUIDGenerator(config=IDConfig(namespace=PRODUCTS_NS, salt=salt))\n\n# Any service can generate consistent entity UUIDs\ndef get_user_uuid(email: str):\n    return user_forge.generate(\"user\", email=email.lower().strip())\n\ndef get_product_uuid(sku: str):\n    return product_forge.generate(\"product\", sku=sku.upper().strip())\n\ndef get_order_uuid(user_email: str, timestamp: int):\n    return order_forge.generate(\"order\", user_email=user_email.lower(), timestamp=timestamp)\n</code></pre>"},{"location":"use-cases/microservices/#service-integration-examples","title":"Service Integration Examples","text":""},{"location":"use-cases/microservices/#user-management-service","title":"User Management Service","text":"<pre><code>from datetime import datetime\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nimport os\n\nclass UserManagementService:\n    def __init__(self):\n        config = IDConfig(\n            namespace=Namespace(\"users.mycompany.com\"),\n            salt=os.getenv(\"UUID_FORGE_SALT\")\n        )\n        self.user_forge = UUIDGenerator(config=config)\n\n    def register_user(self, email, profile_data):\n        # Generate deterministic user ID from email\n        user_id = self.user_forge.generate(\"user\", email=email.lower().strip())\n\n        user = {\n            \"id\": user_id,\n            \"email\": email,\n            \"profile\": profile_data,\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Store in database\n        self.db.users.insert(user)\n\n        # Publish event\n        self.event_bus.publish(\"user.registered\", {\n            \"user_id\": user_id,\n            \"email\": email\n        })\n\n        return user\n\n    def get_user_id(self, email):\n        \"\"\"Other services can call this to get consistent user ID\"\"\"\n        return self.user_forge.generate(\"user\", email=email.lower().strip())\n</code></pre>"},{"location":"use-cases/microservices/#order-processing-service","title":"Order Processing Service","text":"<pre><code>class OrderProcessingService:\n    def __init__(self):\n        salt = os.getenv(\"UUID_FORGE_SALT\")\n        self.user_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"users.mycompany.com\"), salt=salt)\n        )\n        self.order_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"orders.mycompany.com\"), salt=salt)\n        )\n        self.product_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"products.mycompany.com\"), salt=salt)\n        )\n\n    def create_order(self, user_email, product_skus, quantities):\n        # Generate consistent user ID (same as User Service would generate!)\n        user_id = self.user_forge.generate(\"user\", email=user_email.lower().strip())\n\n        order_items = []\n        for sku, qty in zip(product_skus, quantities):\n            product_id = self.product_forge.generate(\"product\", sku=sku.upper().strip())\n            order_items.append({\n                \"product_id\": product_id,\n                \"sku\": sku,\n                \"quantity\": qty\n            })\n\n        # Generate order ID from business data\n        # Use tuple of SKUs for deterministic ordering\n        skus_tuple = tuple(sorted(product_skus))\n        order_id = self.order_forge.generate(\n            \"order\",\n            user_email=user_email.lower().strip(),\n            skus=skus_tuple,\n            timestamp=datetime.utcnow().isoformat()\n        )\n\n        order = {\n            \"id\": order_id,\n            \"user_id\": user_id,\n            \"items\": order_items,\n            \"status\": \"pending\",\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Store order\n        self.db.orders.insert(order)\n\n        # Publish event\n        self.event_bus.publish(\"order.created\", {\n            \"order_id\": order_id,\n            \"user_id\": user_id\n        })\n\n        return order\n</code></pre>"},{"location":"use-cases/microservices/#notification-service","title":"Notification Service","text":"<pre><code>class NotificationService:\n    def __init__(self):\n        salt = os.getenv(\"UUID_FORGE_SALT\")\n        self.user_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"users.mycompany.com\"), salt=salt)\n        )\n        self.notification_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"notifications.mycompany.com\"), salt=salt)\n        )\n\n    def handle_order_created(self, event_data):\n        user_id = event_data[\"user_id\"]\n        order_id = event_data[\"order_id\"]\n\n        # Generate notification ID from business data\n        notification_id = self.notification_forge.generate(\n            \"notification\",\n            user_id=str(user_id),\n            notification_type=\"order_confirmation\",\n            reference_id=str(order_id)\n        )\n\n        notification = {\n            \"id\": notification_id,\n            \"user_id\": user_id,\n            \"type\": \"order_confirmation\",\n            \"message\": f\"Your order {order_id} has been created\",\n            \"created_at\": datetime.utcnow()\n        }\n\n        self.send_notification(notification)\n</code></pre>"},{"location":"use-cases/microservices/#event-driven-architecture","title":"Event-Driven Architecture","text":""},{"location":"use-cases/microservices/#event-correlation","title":"Event Correlation","text":"<p>Use deterministic UUIDs for event correlation:</p> <pre><code>class EventService:\n    def __init__(self):\n        config = IDConfig(\n            namespace=Namespace(\"events.mycompany.com\"),\n            salt=os.getenv(\"UUID_FORGE_SALT\")\n        )\n        self.event_forge = UUIDGenerator(config=config)\n\n    def create_correlation_id(self, user_id, action, timestamp):\n        \"\"\"Create deterministic correlation ID for event tracing\"\"\"\n        return self.event_forge.generate(\n            \"correlation\",\n            user_id=str(user_id),\n            action=action,\n            timestamp=timestamp.isoformat()\n        )\n\n    def publish_correlated_events(self, user_id, action):\n        timestamp = datetime.utcnow()\n        correlation_id = self.create_correlation_id(user_id, action, timestamp)\n\n        events = [\n            {\"type\": \"action.started\", \"correlation_id\": correlation_id},\n            {\"type\": \"action.processed\", \"correlation_id\": correlation_id},\n            {\"type\": \"action.completed\", \"correlation_id\": correlation_id}\n        ]\n\n        for event in events:\n            self.event_bus.publish(event[\"type\"], event)\n</code></pre>"},{"location":"use-cases/microservices/#saga-pattern-implementation","title":"Saga Pattern Implementation","text":"<pre><code>class SagaOrchestrator:\n    def __init__(self):\n        salt = os.getenv(\"UUID_FORGE_SALT\")\n        self.saga_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"sagas.mycompany.com\"), salt=salt)\n        )\n        self.user_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"users.mycompany.com\"), salt=salt)\n        )\n        self.order_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"orders.mycompany.com\"), salt=salt)\n        )\n\n    def start_order_saga(self, user_email, product_skus, timestamp):\n        user_id = self.user_forge.generate(\"user\", email=user_email.lower().strip())\n        order_id = self.order_forge.generate(\n            \"order\",\n            user_email=user_email.lower().strip(),\n            skus=tuple(sorted(product_skus)),\n            timestamp=timestamp\n        )\n\n        # Generate deterministic saga ID\n        saga_id = self.saga_forge.generate(\n            \"order_saga\",\n            user_id=str(user_id),\n            order_id=str(order_id)\n        )\n\n        saga_state = {\n            \"saga_id\": saga_id,\n            \"user_id\": user_id,\n            \"order_id\": order_id,\n            \"steps\": [\"validate_user\", \"reserve_inventory\", \"process_payment\"],\n            \"current_step\": 0,\n            \"status\": \"started\"\n        }\n\n        self.execute_saga_step(saga_state)\n        return saga_id\n</code></pre>"},{"location":"use-cases/microservices/#api-gateway-integration","title":"API Gateway Integration","text":""},{"location":"use-cases/microservices/#request-tracing","title":"Request Tracing","text":"<pre><code>class APIGateway:\n    def __init__(self):\n        config = IDConfig(\n            namespace=Namespace(\"traces.mycompany.com\"),\n            salt=os.getenv(\"UUID_FORGE_SALT\")\n        )\n        self.trace_forge = UUIDGenerator(config=config)\n\n    def create_trace_id(self, request):\n        \"\"\"Create deterministic trace ID for request tracking\"\"\"\n        return self.trace_forge.generate(\n            \"trace\",\n            method=request.method,\n            path=request.path,\n            user_agent=request.headers.get(\"User-Agent\", \"\"),\n            timestamp=datetime.utcnow().replace(microsecond=0).isoformat()\n        )\n\n    def process_request(self, request):\n        trace_id = self.create_trace_id(request)\n        request.headers[\"X-Trace-ID\"] = str(trace_id)\n        return self.forward_to_service(request)\n</code></pre>"},{"location":"use-cases/microservices/#database-consistency","title":"Database Consistency","text":""},{"location":"use-cases/microservices/#cross-service-queries","title":"Cross-Service Queries","text":"<pre><code>class ReportingService:\n    def __init__(self):\n        salt = os.getenv(\"UUID_FORGE_SALT\")\n        self.user_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"users.mycompany.com\"), salt=salt)\n        )\n        self.order_forge = UUIDGenerator(\n            config=IDConfig(namespace=Namespace(\"orders.mycompany.com\"), salt=salt)\n        )\n\n    def generate_user_order_report(self, user_email):\n        # Generate consistent user ID (same as User Service)\n        user_id = self.user_forge.generate(\"user\", email=user_email.lower().strip())\n\n        # Query user data from user service database\n        user_data = self.user_db.find_one({\"id\": user_id})\n\n        # Query order data from order service database\n        orders = self.order_db.find({\"user_id\": user_id})\n\n        return {\n            \"user\": user_data,\n            \"orders\": list(orders),\n            \"generated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"use-cases/microservices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"use-cases/microservices/#integration-testing","title":"Integration Testing","text":"<pre><code>class IntegrationTestSuite:\n    def setUp(self):\n        self.user_service = UserManagementService()\n        self.order_service = OrderProcessingService()\n        self.notification_service = NotificationService()\n\n    def test_cross_service_uuid_consistency(self):\n        \"\"\"Test that all services generate same UUID for same entity\"\"\"\n        email = \"test@example.com\"\n\n        # Generate user ID from different services\n        user_id_1 = self.user_service.get_user_id(email)\n        user_id_2 = self.order_service.user_forge.generate(\"user\", email=email.lower().strip())\n        user_id_3 = self.notification_service.user_forge.generate(\"user\", email=email.lower().strip())\n\n        # All should be identical\n        assert user_id_1 == user_id_2 == user_id_3\n\n    def test_end_to_end_workflow(self):\n        \"\"\"Test complete workflow with consistent UUIDs\"\"\"\n        email = \"customer@example.com\"\n\n        # Register user\n        user = self.user_service.register_user(email, {\"name\": \"Test User\"})\n\n        # Create order\n        order = self.order_service.create_order(email, [\"SKU001\"], [1])\n\n        # Verify same user ID is used\n        assert user[\"id\"] == order[\"user_id\"]\n</code></pre>"},{"location":"use-cases/microservices/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"use-cases/microservices/#uuid-tracking","title":"UUID Tracking","text":"<pre><code>import logging\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\n# Define namespace constant\nUSERS_NS = Namespace(\"microservices.myapp.com/users\")\n\nclass UUIDTracker:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        config = IDConfig(namespace=USERS_NS, salt=\"v1\")\n        self.user_forge = UUIDGenerator(config)\n\n    def track_uuid_usage(self, service_name, entity_type, input_data, uuid_result):\n        \"\"\"Track UUID generation for debugging and monitoring\"\"\"\n        self.logger.info({\n            \"event\": \"uuid_generated\",\n            \"service\": service_name,\n            \"entity_type\": entity_type,\n            \"uuid\": uuid_result,\n            \"input_hash\": hash(str(input_data))  # Don't log sensitive data\n        })\n\n    def validate_uuid_consistency(self, expected_uuid, input_data):\n        \"\"\"Validate that UUID generation is still consistent\"\"\"\n        generated_uuid = self.user_forge.generate(input_data)\n        if generated_uuid != expected_uuid:\n            self.logger.error({\n                \"event\": \"uuid_inconsistency_detected\",\n                \"expected\": expected_uuid,\n                \"generated\": generated_uuid,\n                \"input_hash\": hash(str(input_data))\n            })\n            return False\n        return True\n</code></pre>"},{"location":"use-cases/microservices/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Storage Use Case - Learn about UUID consistency across storage systems</li> <li>Testing Use Case - Advanced testing strategies with deterministic UUIDs</li> <li>Migration Use Case - Data migration patterns with UUID-Forge</li> </ul>"},{"location":"use-cases/migration/","title":"Data Migration with UUID-Forge","text":"<p>Learn how to use deterministic UUIDs for seamless data migration across systems, databases, and platforms.</p>"},{"location":"use-cases/migration/#overview","title":"Overview","text":"<p>Data migration often involves moving data between different systems while maintaining referential integrity and consistency. UUID-Forge's deterministic generation ensures that the same entities receive the same UUIDs across different environments and migration phases.</p>"},{"location":"use-cases/migration/#migration-challenges","title":"Migration Challenges","text":""},{"location":"use-cases/migration/#traditional-migration-problems","title":"Traditional Migration Problems","text":"<ul> <li>ID Mapping: Translating IDs between different systems</li> <li>Referential Integrity: Maintaining relationships during migration</li> <li>Incremental Migration: Handling partial migrations over time</li> <li>Rollback Scenarios: Reverting migrations safely</li> <li>Cross-System Consistency: Ensuring same entity has same ID everywhere</li> </ul>"},{"location":"use-cases/migration/#uuid-forge-solutions","title":"UUID-Forge Solutions","text":"<ul> <li>Deterministic IDs: Same input always generates same UUID</li> <li>No ID Mapping Required: UUIDs are consistent across systems</li> <li>Referential Integrity Maintained: Related entities get related UUIDs</li> <li>Idempotent Migration: Running migration multiple times is safe</li> <li>Cross-Platform Consistency: Same UUIDs on any system</li> </ul>"},{"location":"use-cases/migration/#migration-patterns","title":"Migration Patterns","text":""},{"location":"use-cases/migration/#database-to-database-migration","title":"Database-to-Database Migration","text":""},{"location":"use-cases/migration/#legacy-system-to-modern-database","title":"Legacy System to Modern Database","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\nimport psycopg2\nimport sqlite3\n\nclass DatabaseMigrator:\n    def __init__(self):\n        # Generators for different entity types\n        config = IDConfig(namespace=Namespace(\"users\"), salt=\"v1\")\n        self.user_gen = UUIDGenerator(config)\n        config = IDConfig(namespace=Namespace(\"orders\"), salt=\"v1\")\n        self.order_gen = UUIDGenerator(config)\n        config = IDConfig(namespace=Namespace(\"products\"), salt=\"v1\")\n        self.product_gen = UUIDGenerator(config)\n\n        # Database connections\n        self.legacy_db = sqlite3.connect(\"legacy.db\")\n        self.modern_db = psycopg2.connect(\"postgresql://...\")\n\n    def migrate_users(self):\n        \"\"\"Migrate users from legacy SQLite to PostgreSQL\"\"\"\n        legacy_cursor = self.legacy_db.cursor()\n        modern_cursor = self.modern_db.cursor()\n\n        # Read from legacy database\n        legacy_cursor.execute(\"SELECT email, name, created_at FROM users\")\n        legacy_users = legacy_cursor.fetchall()\n\n        for email, name, created_at in legacy_users:\n            # Generate deterministic UUID for user\n            user_uuid = self.user_gen.generate(\"user\", email=email)\n\n            # Insert into modern database\n            modern_cursor.execute(\n                \"INSERT INTO users (id, email, name, created_at) VALUES (%s, %s, %s, %s)\",\n                (user_uuid, email, name, created_at)\n            )\n\n        self.modern_db.commit()\n        print(f\"Migrated {len(legacy_users)} users\")\n\n    def migrate_orders(self):\n        \"\"\"Migrate orders maintaining user relationships\"\"\"\n        legacy_cursor = self.legacy_db.cursor()\n        modern_cursor = self.modern_db.cursor()\n\n        # Read orders with user email for UUID generation\n        legacy_cursor.execute(\"\"\"\n            SELECT o.id, u.email, o.total, o.created_at\n            FROM orders o\n            JOIN users u ON o.user_id = u.id\n        \"\"\")\n        legacy_orders = legacy_cursor.fetchall()\n\n        for legacy_order_id, user_email, total, created_at in legacy_orders:\n            # Generate consistent user UUID\n            user_uuid = self.user_gen.generate(\"user\", email=user_email)\n\n            # Generate order UUID from identifying attributes\n            order_uuid = self.order_gen.generate(\n                \"order\",\n                user_email=user_email,\n                legacy_id=str(legacy_order_id),\n                total=str(total),\n                created_at=str(created_at)\n            )\n\n            # Insert into modern database\n            modern_cursor.execute(\n                \"INSERT INTO orders (id, user_id, total, created_at) VALUES (%s, %s, %s, %s)\",\n                (order_uuid, user_uuid, total, created_at)\n            )\n\n        self.modern_db.commit()\n        print(f\"Migrated {len(legacy_orders)} orders\")\n</code></pre>"},{"location":"use-cases/migration/#nosql-to-sql-migration","title":"NoSQL to SQL Migration","text":"<pre><code>from pymongo import MongoClient\nimport psycopg2\nfrom uuid_forge import UUIDGenerator\n\nclass NoSQLToSQLMigrator:\n    def __init__(self):\n        self.mongo_client = MongoClient(\"mongodb://localhost:27017/\")\n        self.mongo_db = self.mongo_client.legacy_app\n\n        self.postgres_conn = psycopg2.connect(\"postgresql://...\")\n\n        # UUID generators\n        config = IDConfig(namespace=Namespace(\"users\"), salt=\"v1\")\n        self.user_gen = UUIDGenerator(config)\n        config = IDConfig(namespace=Namespace(\"posts\"), salt=\"v1\")\n        self.post_gen = UUIDGenerator(config)\n        config = IDConfig(namespace=Namespace(\"comments\"), salt=\"v1\")\n        self.comment_gen = UUIDGenerator(config)\n\n    def migrate_user_posts(self):\n        \"\"\"Migrate nested document structure to relational tables\"\"\"\n        cursor = self.postgres_conn.cursor()\n\n        # Read MongoDB documents\n        for user_doc in self.mongo_db.users.find():\n            user_email = user_doc[\"email\"]\n            user_uuid = self.user_gen.generate(\"user\", email=user_email)\n\n            # Migrate user\n            cursor.execute(\n                \"INSERT INTO users (id, email, name) VALUES (%s, %s, %s)\",\n                (user_uuid, user_doc[\"email\"], user_doc[\"name\"])\n            )\n\n            # Migrate embedded posts\n            for post in user_doc.get(\"posts\", []):\n                post_data = {\n                    \"user_email\": user_email,\n                    \"title\": post[\"title\"],\n                    \"content\": post[\"content\"],\n                    \"created_at\": post[\"created_at\"].isoformat()\n                }\n                post_uuid = self.post_gen.generate(\"user\", email=post_data)\n\n                cursor.execute(\n                    \"INSERT INTO posts (id, user_id, title, content, created_at) VALUES (%s, %s, %s, %s, %s)\",\n                    (post_uuid, user_uuid, post[\"title\"], post[\"content\"], post[\"created_at\"])\n                )\n\n                # Migrate embedded comments\n                for comment in post.get(\"comments\", []):\n                    comment_data = {\n                        \"post_id\": post_uuid,\n                        \"author\": comment[\"author\"],\n                        \"content\": comment[\"content\"],\n                        \"created_at\": comment[\"created_at\"].isoformat()\n                    }\n                    comment_uuid = self.comment_gen.generate(\"user\", email=comment_data)\n\n                    cursor.execute(\n                        \"INSERT INTO comments (id, post_id, author, content, created_at) VALUES (%s, %s, %s, %s, %s)\",\n                        (comment_uuid, post_uuid, comment[\"author\"], comment[\"content\"], comment[\"created_at\"])\n                    )\n\n        self.postgres_conn.commit()\n</code></pre>"},{"location":"use-cases/migration/#cloud-migration","title":"Cloud Migration","text":""},{"location":"use-cases/migration/#on-premises-to-cloud-migration","title":"On-Premises to Cloud Migration","text":"<pre><code>import boto3\nfrom uuid_forge import UUIDGenerator\n\nclass CloudMigrator:\n    def __init__(self):\n        # Local database connection\n        self.local_db = psycopg2.connect(\"postgresql://localhost/app\")\n\n        # AWS services\n        self.dynamodb = boto3.resource('dynamodb', region_name='us-east-1')\n        self.s3 = boto3.client('s3')\n\n        # UUID generators\n        config = IDConfig(namespace=Namespace(\"cloud-users\"), salt=\"v1\")\n        self.user_gen = UUIDGenerator(config)\n        config = IDConfig(namespace=Namespace(\"cloud-files\"), salt=\"v1\")\n        self.file_gen = UUIDGenerator(config)\n\n    def migrate_to_dynamodb(self):\n        \"\"\"Migrate relational data to DynamoDB\"\"\"\n        cursor = self.local_db.cursor()\n        table = self.dynamodb.Table('Users')\n\n        cursor.execute(\"SELECT email, name, profile_data FROM users\")\n\n        for email, name, profile_data in cursor.fetchall():\n            user_uuid = self.user_gen.generate(\"user\", email=email)\n\n            # Store in DynamoDB with UUID as partition key\n            table.put_item(\n                Item={\n                    'user_id': user_uuid,\n                    'email': email,\n                    'name': name,\n                    'profile_data': profile_data,\n                    'migrated_at': datetime.utcnow().isoformat()\n                }\n            )\n\n    def migrate_files_to_s3(self):\n        \"\"\"Migrate files to S3 with deterministic keys\"\"\"\n        cursor = self.local_db.cursor()\n\n        cursor.execute(\"SELECT file_path, metadata, content FROM files\")\n\n        for file_path, metadata, content in cursor.fetchall():\n            # Generate deterministic S3 key\n            file_data = {\n                \"original_path\": file_path,\n                \"size\": len(content),\n                \"metadata\": metadata\n            }\n            file_uuid = self.file_gen.generate(\"user\", email=file_data)\n            s3_key = f\"migrated-files/{file_uuid}\"\n\n            # Upload to S3\n            self.s3.put_object(\n                Bucket='migration-bucket',\n                Key=s3_key,\n                Body=content,\n                Metadata={\n                    'original-path': file_path,\n                    'file-uuid': file_uuid,\n                    **metadata\n                }\n            )\n</code></pre>"},{"location":"use-cases/migration/#incremental-migration","title":"Incremental Migration","text":""},{"location":"use-cases/migration/#phased-migration-strategy","title":"Phased Migration Strategy","text":"<pre><code>class IncrementalMigrator:\n    def __init__(self):\n        self.source_db = psycopg2.connect(\"postgresql://source/\")\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n\n        config = IDConfig(namespace=Namespace(\"incremental-users\"), salt=\"v1\")\n\n        self.user_gen = UUIDGenerator(config)\n\n        # Track migration progress\n        self.migration_state = {\n            \"last_migrated_id\": 0,\n            \"batch_size\": 1000,\n            \"total_migrated\": 0\n        }\n\n    def migrate_batch(self):\n        \"\"\"Migrate a batch of records\"\"\"\n        source_cursor = self.source_db.cursor()\n        target_cursor = self.target_db.cursor()\n\n        # Get next batch\n        source_cursor.execute(\n            \"SELECT id, email, name FROM users WHERE id &gt; %s ORDER BY id LIMIT %s\",\n            (self.migration_state[\"last_migrated_id\"], self.migration_state[\"batch_size\"])\n        )\n\n        batch = source_cursor.fetchall()\n        if not batch:\n            print(\"Migration complete!\")\n            return False\n\n        # Migrate batch with deterministic UUIDs\n        for source_id, email, name in batch:\n            user_uuid = self.user_gen.generate(\"user\", email=email)\n\n            # Use ON CONFLICT for idempotent migration\n            target_cursor.execute(\n                \"\"\"\n                INSERT INTO users (id, email, name, source_id, migrated_at)\n                VALUES (%s, %s, %s, %s, %s)\n                ON CONFLICT (email) DO UPDATE SET\n                    name = EXCLUDED.name,\n                    migrated_at = EXCLUDED.migrated_at\n                \"\"\",\n                (user_uuid, email, name, source_id, datetime.utcnow())\n            )\n\n            self.migration_state[\"last_migrated_id\"] = source_id\n\n        self.target_db.commit()\n        self.migration_state[\"total_migrated\"] += len(batch)\n\n        print(f\"Migrated batch: {len(batch)} records, Total: {self.migration_state['total_migrated']}\")\n        return True\n\n    def run_incremental_migration(self):\n        \"\"\"Run migration in batches\"\"\"\n        while self.migrate_batch():\n            time.sleep(1)  # Brief pause between batches\n</code></pre>"},{"location":"use-cases/migration/#data-synchronization","title":"Data Synchronization","text":""},{"location":"use-cases/migration/#bidirectional-sync","title":"Bidirectional Sync","text":"<pre><code>class DataSynchronizer:\n    def __init__(self):\n        self.system_a = psycopg2.connect(\"postgresql://system-a/\")\n        self.system_b = psycopg2.connect(\"postgresql://system-b/\")\n\n        config = IDConfig(namespace=Namespace(\"sync-users\"), salt=\"v1\")\n\n        self.user_gen = UUIDGenerator(config)\n        self.sync_log = []\n\n    def sync_user_changes(self):\n        \"\"\"Synchronize user changes between systems\"\"\"\n        cursor_a = self.system_a.cursor()\n        cursor_b = self.system_b.cursor()\n\n        # Get changes from system A\n        cursor_a.execute(\n            \"SELECT email, name, updated_at FROM users WHERE updated_at &gt; %s\",\n            (self.last_sync_time,)\n        )\n\n        changes_a = cursor_a.fetchall()\n\n        for email, name, updated_at in changes_a:\n            user_uuid = self.user_gen.generate(\"user\", email=email)\n\n            # Apply change to system B\n            cursor_b.execute(\n                \"\"\"\n                INSERT INTO users (id, email, name, updated_at)\n                VALUES (%s, %s, %s, %s)\n                ON CONFLICT (id) DO UPDATE SET\n                    name = EXCLUDED.name,\n                    updated_at = EXCLUDED.updated_at\n                WHERE users.updated_at &lt; EXCLUDED.updated_at\n                \"\"\",\n                (user_uuid, email, name, updated_at)\n            )\n\n            self.sync_log.append({\n                \"user_id\": user_uuid,\n                \"direction\": \"A-&gt;B\",\n                \"timestamp\": datetime.utcnow()\n            })\n\n        self.system_b.commit()\n</code></pre>"},{"location":"use-cases/migration/#migration-validation","title":"Migration Validation","text":""},{"location":"use-cases/migration/#data-integrity-verification","title":"Data Integrity Verification","text":"<pre><code>class MigrationValidator:\n    def __init__(self):\n        self.source_db = psycopg2.connect(\"postgresql://source/\")\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n\n        config = IDConfig(namespace=Namespace(\"validation-users\"), salt=\"v1\")\n\n        self.user_gen = UUIDGenerator(config)\n\n    def validate_user_migration(self):\n        \"\"\"Validate that all users migrated correctly\"\"\"\n        source_cursor = self.source_db.cursor()\n        target_cursor = self.target_db.cursor()\n\n        source_cursor.execute(\"SELECT email, name FROM users ORDER BY email\")\n        source_users = source_cursor.fetchall()\n\n        target_cursor.execute(\"SELECT email, name FROM users ORDER BY email\")\n        target_users = target_cursor.fetchall()\n\n        validation_results = {\n            \"total_source\": len(source_users),\n            \"total_target\": len(target_users),\n            \"missing_users\": [],\n            \"data_mismatches\": []\n        }\n\n        source_dict = {email: name for email, name in source_users}\n        target_dict = {email: name for email, name in target_users}\n\n        # Check for missing users\n        for email in source_dict:\n            if email not in target_dict:\n                validation_results[\"missing_users\"].append(email)\n            elif source_dict[email] != target_dict[email]:\n                validation_results[\"data_mismatches\"].append({\n                    \"email\": email,\n                    \"source_name\": source_dict[email],\n                    \"target_name\": target_dict[email]\n                })\n\n        return validation_results\n\n    def validate_referential_integrity(self):\n        \"\"\"Validate that relationships are maintained\"\"\"\n        target_cursor = self.target_db.cursor()\n\n        # Check that all orders have valid user references\n        target_cursor.execute(\"\"\"\n            SELECT COUNT(*) FROM orders o\n            LEFT JOIN users u ON o.user_id = u.id\n            WHERE u.id IS NULL\n        \"\"\")\n\n        orphaned_orders = target_cursor.fetchone()[0]\n\n        return {\n            \"orphaned_orders\": orphaned_orders,\n            \"integrity_valid\": orphaned_orders == 0\n        }\n</code></pre>"},{"location":"use-cases/migration/#rollback-strategies","title":"Rollback Strategies","text":""},{"location":"use-cases/migration/#safe-migration-rollback","title":"Safe Migration Rollback","text":"<pre><code>class MigrationRollback:\n    def __init__(self):\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n        self.backup_db = psycopg2.connect(\"postgresql://backup/\")\n\n    def create_rollback_point(self):\n        \"\"\"Create a rollback point before migration\"\"\"\n        target_cursor = self.target_db.cursor()\n        backup_cursor = self.backup_db.cursor()\n\n        # Backup current state\n        target_cursor.execute(\"SELECT * FROM users\")\n        users = target_cursor.fetchall()\n\n        # Clear backup and restore\n        backup_cursor.execute(\"DELETE FROM users\")\n\n        for user in users:\n            backup_cursor.execute(\n                \"INSERT INTO users VALUES (%s, %s, %s, %s)\",\n                user\n            )\n\n        self.backup_db.commit()\n        print(\"Rollback point created\")\n\n    def rollback_migration(self):\n        \"\"\"Rollback to previous state\"\"\"\n        target_cursor = self.target_db.cursor()\n        backup_cursor = self.backup_db.cursor()\n\n        # Clear target\n        target_cursor.execute(\"DELETE FROM users\")\n\n        # Restore from backup\n        backup_cursor.execute(\"SELECT * FROM users\")\n        backup_users = backup_cursor.fetchall()\n\n        for user in backup_users:\n            target_cursor.execute(\n                \"INSERT INTO users VALUES (%s, %s, %s, %s)\",\n                user\n            )\n\n        self.target_db.commit()\n        print(\"Migration rolled back successfully\")\n</code></pre>"},{"location":"use-cases/migration/#migration-monitoring","title":"Migration Monitoring","text":""},{"location":"use-cases/migration/#progress-tracking","title":"Progress Tracking","text":"<pre><code>class MigrationMonitor:\n    def __init__(self):\n        self.metrics = {\n            \"start_time\": None,\n            \"records_processed\": 0,\n            \"records_failed\": 0,\n            \"current_phase\": None,\n            \"estimated_completion\": None\n        }\n\n    def start_monitoring(self, total_records):\n        \"\"\"Start migration monitoring\"\"\"\n        self.metrics[\"start_time\"] = datetime.utcnow()\n        self.metrics[\"total_records\"] = total_records\n        print(f\"Migration started: {total_records} records to process\")\n\n    def update_progress(self, records_processed, current_phase=\"processing\"):\n        \"\"\"Update migration progress\"\"\"\n        self.metrics[\"records_processed\"] = records_processed\n        self.metrics[\"current_phase\"] = current_phase\n\n        elapsed = datetime.utcnow() - self.metrics[\"start_time\"]\n        progress_pct = (records_processed / self.metrics[\"total_records\"]) * 100\n\n        if records_processed &gt; 0:\n            avg_time_per_record = elapsed / records_processed\n            remaining_records = self.metrics[\"total_records\"] - records_processed\n            eta = datetime.utcnow() + (avg_time_per_record * remaining_records)\n            self.metrics[\"estimated_completion\"] = eta\n\n        print(f\"Progress: {progress_pct:.1f}% ({records_processed}/{self.metrics['total_records']}) - ETA: {eta}\")\n\n    def log_error(self, record_id, error):\n        \"\"\"Log migration error\"\"\"\n        self.metrics[\"records_failed\"] += 1\n        print(f\"Error processing record {record_id}: {error}\")\n\n    def complete_monitoring(self):\n        \"\"\"Complete migration monitoring\"\"\"\n        total_time = datetime.utcnow() - self.metrics[\"start_time\"]\n        success_rate = ((self.metrics[\"records_processed\"] - self.metrics[\"records_failed\"]) /\n                       self.metrics[\"total_records\"]) * 100\n\n        print(f\"Migration completed in {total_time}\")\n        print(f\"Success rate: {success_rate:.1f}%\")\n        print(f\"Records processed: {self.metrics['records_processed']}\")\n        print(f\"Records failed: {self.metrics['records_failed']}\")\n</code></pre>"},{"location":"use-cases/migration/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Use Case - Testing migration strategies</li> <li>Best Practices - Migration optimization</li> <li>Development Guide - Development environment setup</li> </ul>"},{"location":"use-cases/multi-storage/","title":"Multi-Storage Systems","text":"<p>Learn how UUID-Forge ensures consistency across different storage systems and databases.</p>"},{"location":"use-cases/multi-storage/#overview","title":"Overview","text":"<p>In modern applications, data often spans multiple storage systems - SQL databases, NoSQL stores, message queues, caches, and file systems. UUID-Forge provides deterministic UUID generation to maintain consistent entity identification across all these systems.</p>"},{"location":"use-cases/multi-storage/#common-challenges","title":"Common Challenges","text":""},{"location":"use-cases/multi-storage/#storage-system-inconsistencies","title":"Storage System Inconsistencies","text":"<p>Different storage systems may handle UUIDs differently:</p> <ul> <li>SQL databases: Native UUID columns with specific formatting</li> <li>NoSQL stores: String or binary UUID representations</li> <li>Message queues: UUID as message correlation IDs</li> <li>Caches: UUID as cache keys</li> <li>File systems: UUID in filenames or directory structures</li> </ul>"},{"location":"use-cases/multi-storage/#synchronization-issues","title":"Synchronization Issues","text":"<p>Traditional approaches face challenges:</p> <ul> <li>Database sequences: Not available across all systems</li> <li>Auto-generated UUIDs: Different for same entity</li> <li>Centralized ID generation: Single point of failure</li> <li>Manual coordination: Error-prone and complex</li> </ul>"},{"location":"use-cases/multi-storage/#uuid-forge-solution","title":"UUID-Forge Solution","text":""},{"location":"use-cases/multi-storage/#deterministic-generation","title":"Deterministic Generation","text":"<p>Same input always produces the same UUID:</p> <pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\n# Initialize generator with proper configuration\nconfig = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\ngenerator = UUIDGenerator(config)\n\n# Same UUID across all storage systems\nuser_email = \"john@example.com\"\nuser_uuid = generator.generate(\"user\", email=user_email)\n\n# Use in SQL database\nsql_insert = f\"INSERT INTO users (id, email) VALUES ('{user_uuid}', '{user_email}')\"\n\n# Use in MongoDB\nmongo_doc = {\"_id\": str(user_uuid), \"email\": user_email}\n\n# Use as Redis key\nredis_key = f\"user:{user_uuid}\"\n\n# All systems reference the same deterministic UUID\n</code></pre>"},{"location":"use-cases/multi-storage/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"use-cases/multi-storage/#database-integration","title":"Database Integration","text":""},{"location":"use-cases/multi-storage/#postgresql-with-uuid-column","title":"PostgreSQL with UUID Column","text":"<pre><code>import psycopg2\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass UserRepository:\n    def __init__(self):\n        config = IDConfig(namespace=Namespace(\"users.myapp.com\"), salt=\"v1\")\n        self.generator = UUIDGenerator(config)\n        self.conn = psycopg2.connect(\"postgresql://...\")\n\n    def create_user(self, email: str, name: str) -&gt; UUID:\n        user_id = self.generator.generate(\"user\", email=email)\n\n        with self.conn.cursor() as cur:\n            cur.execute(\n                \"INSERT INTO users (id, email, name) VALUES (%s, %s, %s)\",\n                (user_id, email, name)\n            )\n\n        return user_id\n\n    def get_user_id(self, email: str) -&gt; UUID:\n        \"\"\"Get consistent user ID without database lookup\"\"\"\n        return self.generator.generate(\"user\", email=email)\n</code></pre>"},{"location":"use-cases/multi-storage/#mongodb-integration","title":"MongoDB Integration","text":"<pre><code>from pymongo import MongoClient\nfrom uuid_forge import UUIDGenerator\n\nclass DocumentStore:\n    def __init__(self):\n        self.generator = UUIDGenerator(IDConfig(namespace=Namespace(\"documents\"), salt=\"v1\"))\n        self.client = MongoClient(\"mongodb://...\")\n        self.db = self.client.myapp\n\n    def store_document(self, content: str, metadata: dict):\n        created_at = datetime.utcnow().isoformat()\n\n        # Generate deterministic ID from content and metadata\n        doc_id = self.generator.generate(\n            \"document\",\n            content=content,\n            metadata=str(metadata),\n            created_at=created_at\n        )\n\n        # Store in MongoDB\n        self.db.documents.insert_one({\n            \"_id\": str(doc_id),\n            \"content\": content,\n            \"metadata\": metadata,\n            \"created_at\": created_at\n        })\n\n        return doc_id\n</code></pre>"},{"location":"use-cases/multi-storage/#cache-integration","title":"Cache Integration","text":""},{"location":"use-cases/multi-storage/#redis-caching","title":"Redis Caching","text":"<pre><code>import redis\nfrom uuid_forge import UUIDGenerator\n\nclass CacheManager:\n    def __init__(self):\n        self.user_generator = UUIDGenerator(IDConfig(namespace=Namespace(\"users\"), salt=\"v1\"))\n        self.session_generator = UUIDGenerator(IDConfig(namespace=Namespace(\"sessions\"), salt=\"v1\"))\n        self.redis = redis.Redis(host=\"localhost\", port=6379)\n\n    def cache_user_data(self, email, user_data):\n        user_id = self.user_generator.generate(\"user\", email=email)\n        cache_key = f\"user:{user_id}\"\n\n        # Store in Redis with deterministic key\n        self.redis.setex(cache_key, 3600, json.dumps(user_data))\n\n        return cache_key\n\n    def get_cached_user(self, email):\n        user_id = self.user_generator.generate(\"user\", email=email)\n        cache_key = f\"user:{user_id}\"\n\n        cached_data = self.redis.get(cache_key)\n        return json.loads(cached_data) if cached_data else None\n</code></pre>"},{"location":"use-cases/multi-storage/#message-queue-integration","title":"Message Queue Integration","text":""},{"location":"use-cases/multi-storage/#rabbitmq-with-correlation-ids","title":"RabbitMQ with Correlation IDs","text":"<pre><code>import pika\nfrom uuid_forge import UUIDGenerator\n\nclass MessagePublisher:\n    def __init__(self):\n        self.message_generator = UUIDGenerator(IDConfig(namespace=Namespace(\"messages\"), salt=\"v1\"))\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\"localhost\")\n        )\n        self.channel = self.connection.channel()\n\n    def publish_user_event(self, user_email: str, event_type: str, event_data: dict):\n        # Generate deterministic correlation ID from event attributes\n        timestamp = datetime.utcnow().isoformat()\n        correlation_id = self.message_generator.generate(\n            \"event\",\n            user_email=user_email,\n            event_type=event_type,\n            timestamp=timestamp\n        )\n\n        message = {\n            \"correlation_id\": str(correlation_id),\n            \"user_email\": user_email,\n            \"event_type\": event_type,\n            \"data\": event_data\n        }\n\n        self.channel.basic_publish(\n            exchange=\"user_events\",\n            routing_key=event_type,\n            body=json.dumps(message),\n            properties=pika.BasicProperties(correlation_id=str(correlation_id))\n        )\n\n        return correlation_id\n</code></pre>"},{"location":"use-cases/multi-storage/#cross-system-consistency-examples","title":"Cross-System Consistency Examples","text":""},{"location":"use-cases/multi-storage/#e-commerce-order-processing","title":"E-commerce Order Processing","text":"<pre><code>class OrderProcessingSystem:\n    def __init__(self):\n        self.user_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"users\"), salt=\"v1\"))\n        self.order_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"orders\"), salt=\"v1\"))\n        self.product_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"products\"), salt=\"v1\"))\n\n        # Multiple storage systems\n        self.postgres = psycopg2.connect(\"postgresql://...\")\n        self.redis = redis.Redis()\n        self.mongo = MongoClient()\n        self.es = Elasticsearch()\n\n    def process_order(self, user_email, product_skus, quantities):\n        # Generate consistent IDs\n        user_id = self.user_gen.generate(\"user\", email=user_email)\n\n        order_items = []\n        for sku, qty in zip(product_skus, quantities):\n            product_id = self.product_gen.generate(sku)\n            order_items.append({\n                \"product_id\": product_id,\n                \"sku\": sku,\n                \"quantity\": qty\n            })\n\n        order_data = {\n            \"user_id\": user_id,\n            \"items\": sorted(order_items, key=lambda x: x[\"sku\"]),\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        order_id = self.order_gen.generate(order_data)\n\n        # Store in PostgreSQL (transactional data)\n        with self.postgres.cursor() as cur:\n            cur.execute(\n                \"INSERT INTO orders (id, user_id, status, created_at) VALUES (%s, %s, %s, %s)\",\n                (order_id, user_id, \"pending\", datetime.utcnow())\n            )\n\n            for item in order_items:\n                cur.execute(\n                    \"INSERT INTO order_items (order_id, product_id, quantity) VALUES (%s, %s, %s)\",\n                    (order_id, item[\"product_id\"], item[\"quantity\"])\n                )\n\n        # Cache in Redis (fast access)\n        self.redis.setex(\n            f\"order:{order_id}\",\n            3600,\n            json.dumps(order_data)\n        )\n\n        # Store in MongoDB (document store)\n        self.mongo.orders.insert_one({\n            \"_id\": order_id,\n            **order_data\n        })\n\n        # Index in Elasticsearch (search)\n        self.es.index(\n            index=\"orders\",\n            id=order_id,\n            body={\n                **order_data,\n                \"searchable_text\": f\"{user_email} {' '.join(product_skus)}\"\n            }\n        )\n\n        return order_id\n</code></pre>"},{"location":"use-cases/multi-storage/#file-system-integration","title":"File System Integration","text":"<pre><code>import os\nfrom pathlib import Path\nfrom uuid_forge import UUIDGenerator\n\nclass FileManager:\n    def __init__(self, base_path):\n        self.base_path = Path(base_path)\n        self.file_generator = UUIDGenerator(IDConfig(namespace=Namespace(\"files\"), salt=\"v1\"))\n\n    def store_file(self, content, metadata):\n        # Generate deterministic file UUID\n        file_data = {\n            \"content_hash\": hashlib.md5(content).hexdigest(),\n            \"metadata\": metadata,\n            \"size\": len(content)\n        }\n        file_uuid = self.file_generator.generate(file_data)\n\n        # Create directory structure using UUID segments\n        dir_path = self.base_path / file_uuid[:2] / file_uuid[2:4]\n        dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Store file with UUID name\n        file_path = dir_path / f\"{file_uuid}.dat\"\n        with open(file_path, \"wb\") as f:\n            f.write(content)\n\n        # Store metadata in database with same UUID\n        self.store_metadata_in_db(file_uuid, metadata, str(file_path))\n\n        return file_uuid\n\n    def get_file_path(self, content, metadata):\n        \"\"\"Get file path without creating file\"\"\"\n        file_data = {\n            \"content_hash\": hashlib.md5(content).hexdigest(),\n            \"metadata\": metadata,\n            \"size\": len(content)\n        }\n        file_uuid = self.file_generator.generate(file_data)\n\n        return self.base_path / file_uuid[:2] / file_uuid[2:4] / f\"{file_uuid}.dat\"\n</code></pre>"},{"location":"use-cases/multi-storage/#testing-multi-storage-consistency","title":"Testing Multi-Storage Consistency","text":""},{"location":"use-cases/multi-storage/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\nclass TestMultiStorageConsistency:\n    def setUp(self):\n        self.user_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"test-users\"), salt=\"v1\"))\n        self.order_gen = UUIDGenerator(IDConfig(namespace=Namespace(\"test-orders\"), salt=\"v1\"))\n\n        # Initialize test storage systems\n        self.setup_test_databases()\n\n    def test_user_id_consistency(self):\n        \"\"\"Test user ID consistency across all storage systems\"\"\"\n        email = \"test@example.com\"\n\n        # Generate UUID from different components\n        user_id_1 = self.user_gen.generate(\"user\", email=email)\n        user_id_2 = self.get_user_id_from_postgres(email)\n        user_id_3 = self.get_user_id_from_cache(email)\n        user_id_4 = self.get_user_id_from_mongo(email)\n\n        # All should be identical\n        assert user_id_1 == user_id_2 == user_id_3 == user_id_4\n\n    def test_cross_system_query(self):\n        \"\"\"Test querying data across multiple systems using consistent UUIDs\"\"\"\n        email = \"customer@example.com\"\n        user_id = self.user_gen.generate(\"user\", email=email)\n\n        # Store user in different systems\n        self.store_user_in_postgres(user_id, email)\n        self.cache_user_in_redis(user_id, {\"name\": \"Test User\"})\n        self.index_user_in_elasticsearch(user_id, email)\n\n        # Query from different systems using same UUID\n        pg_user = self.get_user_from_postgres(user_id)\n        cached_user = self.get_user_from_cache(user_id)\n        indexed_user = self.search_user_in_elasticsearch(user_id)\n\n        # Verify data consistency\n        assert pg_user[\"id\"] == cached_user[\"id\"] == indexed_user[\"id\"] == user_id\n</code></pre>"},{"location":"use-cases/multi-storage/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"use-cases/multi-storage/#uuid-consistency-validation","title":"UUID Consistency Validation","text":"<pre><code>class ConsistencyValidator:\n    def __init__(self):\n        self.generators = {\n            \"users\": UUIDGenerator(IDConfig(namespace=Namespace(\"users\"), salt=\"v1\")),\n            \"orders\": UUIDGenerator(IDConfig(namespace=Namespace(\"orders\"), salt=\"v1\")),\n            \"products\": UUIDGenerator(IDConfig(namespace=Namespace(\"products\"), salt=\"v1\"))\n        }\n\n    def validate_storage_consistency(self, entity_type, identifier):\n        \"\"\"Validate UUID consistency across storage systems\"\"\"\n        expected_uuid = self.generators[entity_type].generate(identifier)\n\n        results = {\n            \"postgres\": self.get_uuid_from_postgres(entity_type, identifier),\n            \"redis\": self.get_uuid_from_redis(entity_type, identifier),\n            \"mongodb\": self.get_uuid_from_mongodb(entity_type, identifier),\n            \"elasticsearch\": self.get_uuid_from_elasticsearch(entity_type, identifier)\n        }\n\n        inconsistencies = []\n        for system, uuid_value in results.items():\n            if uuid_value != expected_uuid:\n                inconsistencies.append({\n                    \"system\": system,\n                    \"expected\": expected_uuid,\n                    \"actual\": uuid_value\n                })\n\n        return {\n            \"consistent\": len(inconsistencies) == 0,\n            \"expected_uuid\": expected_uuid,\n            \"inconsistencies\": inconsistencies\n        }\n</code></pre>"},{"location":"use-cases/multi-storage/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Use Case - Testing strategies with consistent UUIDs</li> <li>Migration Use Case - Data migration patterns</li> <li>Best Practices - Optimization and patterns</li> </ul>"},{"location":"use-cases/testing/","title":"Testing with UUID-Forge","text":"<p>Learn how to leverage deterministic UUIDs for more effective testing strategies.</p>"},{"location":"use-cases/testing/#overview","title":"Overview","text":"<p>Deterministic UUID generation provides significant advantages for testing by making UUIDs predictable and reproducible. This enables more reliable tests, easier debugging, and better test data management.</p>"},{"location":"use-cases/testing/#benefits-for-testing","title":"Benefits for Testing","text":""},{"location":"use-cases/testing/#predictable-test-data","title":"Predictable Test Data","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\ndef test_user_creation():\n    \"\"\"Test with predictable UUIDs\"\"\"\n    config = IDConfig(namespace=Namespace(\"test.example.com\"), salt=\"test-v1\")\n    generator = UUIDGenerator(config)\n\n    # Always generates the same UUID for same input\n    user_id = generator.generate(\"user\", email=\"test@example.com\")\n\n    # Test assertions can verify UUID properties\n    assert isinstance(user_id, UUID)\n    assert str(user_id)  # Can convert to string\n\n    # Deterministic - same input always produces same UUID\n    user_id_2 = generator.generate(\"user\", email=\"test@example.com\")\n    assert user_id == user_id_2\n</code></pre>"},{"location":"use-cases/testing/#reproducible-test-scenarios","title":"Reproducible Test Scenarios","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestOrderProcessing:\n    def setUp(self):\n        user_config = IDConfig(namespace=Namespace(\"test.example.com/users\"), salt=\"test-v1\")\n        order_config = IDConfig(namespace=Namespace(\"test.example.com/orders\"), salt=\"test-v1\")\n\n        self.user_gen = UUIDGenerator(user_config)\n        self.order_gen = UUIDGenerator(order_config)\n\n    def test_order_workflow(self):\n        \"\"\"Test complete order workflow with predictable UUIDs\"\"\"\n        # Same UUIDs generated every test run\n        user_id = self.user_gen.generate(\"user\", email=\"customer@test.com\")\n\n        order_id = self.order_gen.generate(\n            \"order\",\n            user_id=str(user_id),\n            item1=\"product1\",\n            item2=\"product2\",\n            timestamp=\"2024-01-15T10:00:00Z\"\n        )\n\n        # Test can rely on deterministic UUID generation\n        # Same inputs always produce same UUIDs\n        expected_user_id = self.user_gen.generate(\"user\", email=\"customer@test.com\")\n        assert user_id == expected_user_id\n\n        expected_order_id = self.order_gen.generate(\n            \"order\",\n            user_id=str(user_id),\n            item1=\"product1\",\n            item2=\"product2\",\n            timestamp=\"2024-01-15T10:00:00Z\"\n        )\n        assert order_id == expected_order_id\n</code></pre>"},{"location":"use-cases/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"use-cases/testing/#fixture-based-testing","title":"Fixture-Based Testing","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\nfrom typing import Dict\n\n@pytest.fixture\ndef test_generators() -&gt; Dict[str, UUIDGenerator]:\n    \"\"\"Provide test UUID generators\"\"\"\n    return {\n        \"users\": UUIDGenerator(\n            IDConfig(namespace=Namespace(\"test.example.com/users\"), salt=\"test-v1\")\n        ),\n        \"orders\": UUIDGenerator(\n            IDConfig(namespace=Namespace(\"test.example.com/orders\"), salt=\"test-v1\")\n        ),\n        \"products\": UUIDGenerator(\n            IDConfig(namespace=Namespace(\"test.example.com/products\"), salt=\"test-v1\")\n        ),\n    }\n\n@pytest.fixture\ndef test_users(test_generators):\n    \"\"\"Generate test user data with deterministic UUIDs\"\"\"\n    users = [\n        {\"email\": \"user1@test.com\", \"name\": \"User One\", \"region\": \"us\"},\n        {\"email\": \"user2@test.com\", \"name\": \"User Two\", \"region\": \"eu\"},\n        {\"email\": \"user3@test.com\", \"name\": \"User Three\", \"region\": \"asia\"},\n    ]\n\n    for user in users:\n        user[\"id\"] = test_generators[\"users\"].generate(\n            \"user\",\n            email=user[\"email\"],\n            region=user[\"region\"]\n        )\n\n    return users\n\ndef test_user_processing(test_users):\n    \"\"\"Test using predictable user data\"\"\"\n    assert len(test_users) == 3\n    assert all(isinstance(user[\"id\"], UUID) for user in test_users)\n\n    # UUIDs are deterministic - same every test run\n    first_user_id = test_users[0][\"id\"]\n    assert isinstance(first_user_id, UUID)\n\n    # All users have unique UUIDs (different inputs)\n    user_ids = [user[\"id\"] for user in test_users]\n    assert len(set(user_ids)) == len(user_ids)\n</code></pre>"},{"location":"use-cases/testing/#database-testing","title":"Database Testing","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestDatabaseOperations:\n    def setUp(self):\n        user_config = IDConfig(namespace=Namespace(\"test.example.com/users\"), salt=\"test-v1\")\n        self.user_gen = UUIDGenerator(user_config)\n        self.setup_test_database()\n\n    def test_user_crud_operations(self):\n        \"\"\"Test CRUD operations with deterministic UUIDs\"\"\"\n        user_email = \"dbtest@example.com\"\n        user_id = self.user_gen.generate(\"user\", email=user_email)\n\n        # Create\n        self.db.create_user(user_id, user_email, \"Test User\")\n\n        # Read - can regenerate UUID to lookup\n        stored_user = self.db.get_user(user_id)\n        assert stored_user[\"id\"] == user_id\n        assert stored_user[\"email\"] == user_email\n\n        # Can also regenerate UUID for lookup without storing it\n        lookup_id = self.user_gen.generate(\"user\", email=user_email)\n        assert lookup_id == user_id\n        stored_user_2 = self.db.get_user(lookup_id)\n        assert stored_user_2[\"email\"] == user_email\n\n        # Update\n        self.db.update_user(user_id, {\"name\": \"Updated Name\"})\n        updated_user = self.db.get_user(user_id)\n        assert updated_user[\"name\"] == \"Updated Name\"\n\n        # Delete\n        self.db.delete_user(user_id)\n        assert self.db.get_user(user_id) is None\n\n    def test_relationship_integrity(self):\n        \"\"\"Test foreign key relationships\"\"\"\n        user_id = self.user_gen.generate(\"user\", email=\"parent@test.com\")\n\n        order_config = IDConfig(namespace=Namespace(\"test.example.com/orders\"), salt=\"test-v1\")\n        order_gen = UUIDGenerator(order_config)\n\n        # Create parent record\n        self.db.create_user(user_id, \"parent@test.com\", \"Parent User\")\n\n        # Create child record with deterministic UUID\n        order_id = order_gen.generate(\n            \"order\",\n            user_email=\"parent@test.com\",\n            total=100.00\n        )\n        self.db.create_order(order_id, user_id, 100.00)\n\n        # Verify relationship\n        user_orders = self.db.get_user_orders(user_id)\n        assert len(user_orders) == 1\n        assert user_orders[0][\"id\"] == order_id\n</code></pre>"},{"location":"use-cases/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"use-cases/testing/#multi-service-testing","title":"Multi-Service Testing","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestMicroservicesIntegration:\n    def setUp(self):\n        self.user_service = UserService()\n        self.order_service = OrderService()\n        self.notification_service = NotificationService()\n\n        # All services use same UUID configuration for users\n        user_config = IDConfig(\n            namespace=Namespace(\"test.example.com/users\"),\n            salt=\"integration-test-v1\"\n        )\n        self.user_gen = UUIDGenerator(user_config)\n\n    def test_cross_service_workflow(self):\n        \"\"\"Test workflow spanning multiple services\"\"\"\n        user_email = \"integration@test.com\"\n        user_id = self.user_gen.generate(\"user\", email=user_email)\n\n        # Step 1: Create user\n        user = self.user_service.create_user(user_email, \"Test User\")\n        assert user[\"id\"] == user_id\n\n        # Step 2: Create order (should reference same user ID)\n        # Order service can regenerate user UUID from email\n        order = self.order_service.create_order(user_email, [\"item1\", \"item2\"])\n        assert order[\"user_id\"] == user_id\n\n        # Step 3: Send notification (should reference same user ID)\n        # Notification service can also regenerate user UUID\n        notification = self.notification_service.send_order_confirmation(\n            user_email, order[\"id\"]\n        )\n        assert notification[\"user_id\"] == user_id\n\n        # All services independently generated the same user ID from the email\n        assert user[\"id\"] == order[\"user_id\"] == notification[\"user_id\"]\n\n        # Verify we can regenerate the same UUID\n        regenerated_id = self.user_gen.generate(\"user\", email=user_email)\n        assert regenerated_id == user_id\n</code></pre>"},{"location":"use-cases/testing/#api-testing","title":"API Testing","text":"<pre><code>import requests\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestAPIEndpoints:\n    def setUp(self):\n        self.base_url = \"http://localhost:8000/api\"\n        user_config = IDConfig(\n            namespace=Namespace(\"test.example.com/users\"),\n            salt=\"api-test-v1\"\n        )\n        self.user_gen = UUIDGenerator(user_config)\n\n    def test_user_api_endpoints(self):\n        \"\"\"Test user API with predictable UUIDs\"\"\"\n        user_email = \"apitest@example.com\"\n        expected_user_id = self.user_gen.generate(\"user\", email=user_email)\n\n        # POST /users - Create user\n        create_response = requests.post(\n            f\"{self.base_url}/users\",\n            json={\"email\": user_email, \"name\": \"API Test User\"}\n        )\n        assert create_response.status_code == 201\n        created_user = create_response.json()\n        assert created_user[\"id\"] == expected_user_id\n\n        # GET /users/{id} - Retrieve user\n        get_response = requests.get(f\"{self.base_url}/users/{expected_user_id}\")\n        assert get_response.status_code == 200\n        retrieved_user = get_response.json()\n        assert retrieved_user[\"id\"] == expected_user_id\n        assert retrieved_user[\"email\"] == user_email\n\n        # PUT /users/{id} - Update user\n        update_response = requests.put(\n            f\"{self.base_url}/users/{expected_user_id}\",\n            json={\"name\": \"Updated API User\"}\n        )\n        assert update_response.status_code == 200\n\n        # DELETE /users/{id} - Delete user\n        delete_response = requests.delete(f\"{self.base_url}/users/{expected_user_id}\")\n        assert delete_response.status_code == 204\n</code></pre>"},{"location":"use-cases/testing/#property-based-testing","title":"Property-Based Testing","text":""},{"location":"use-cases/testing/#hypothesis-integration","title":"Hypothesis Integration","text":"<pre><code>from hypothesis import given, strategies as st\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestUUIDProperties:\n    def setUp(self):\n        config = IDConfig(namespace=Namespace(\"test.example.com\"), salt=\"property-test-v1\")\n        self.generator = UUIDGenerator(config)\n\n    @given(st.text(min_size=1))\n    def test_uuid_type_property(self, input_text):\n        \"\"\"Property: All generated UUIDs are valid UUID objects\"\"\"\n        uuid_result = self.generator.generate(\"entity\", value=input_text)\n\n        # Should be a UUID object\n        assert isinstance(uuid_result, UUID)\n\n        # Can convert to string\n        uuid_str = str(uuid_result)\n        assert len(uuid_str) == 36\n        assert uuid_str.count(\"-\") == 4\n\n    @given(st.text(min_size=1))\n    def test_determinism_property(self, input_text):\n        \"\"\"Property: Same input always produces same UUID\"\"\"\n        uuid1 = self.generator.generate(\"entity\", value=input_text)\n        uuid2 = self.generator.generate(\"entity\", value=input_text)\n\n        assert uuid1 == uuid2\n        assert isinstance(uuid1, UUID)\n\n    @given(st.lists(st.text(min_size=1), min_size=2, unique=True))\n    def test_uniqueness_property(self, input_list):\n        \"\"\"Property: Different inputs produce different UUIDs\"\"\"\n        uuids = [\n            self.generator.generate(\"entity\", value=input_text)\n            for input_text in input_list\n        ]\n\n        # All UUIDs should be unique\n        assert len(set(uuids)) == len(uuids)\n        assert all(isinstance(u, UUID) for u in uuids)\n</code></pre>"},{"location":"use-cases/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"use-cases/testing/#benchmark-testing","title":"Benchmark Testing","text":"<pre><code>import time\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\n\nclass TestPerformance:\n    def setUp(self):\n        config = IDConfig(namespace=Namespace(\"test.example.com\"), salt=\"perf-test-v1\")\n        self.generator = UUIDGenerator(config)\n        self.test_data = [f\"user{i}@test.com\" for i in range(1000)]\n\n    def test_single_generation_performance(self):\n        \"\"\"Test single UUID generation performance\"\"\"\n        start_time = time.time()\n\n        uuid_result = self.generator.generate(\"user\", email=\"performance@test.com\")\n\n        end_time = time.time()\n        generation_time = end_time - start_time\n\n        # Should generate UUID very quickly\n        assert generation_time &lt; 0.01  # Under 10ms\n        assert isinstance(uuid_result, UUID)\n\n    def test_batch_generation_performance(self):\n        \"\"\"Test batch UUID generation performance\"\"\"\n        start_time = time.time()\n\n        uuids = [\n            self.generator.generate(\"user\", email=email)\n            for email in self.test_data\n        ]\n\n        end_time = time.time()\n        total_time = end_time - start_time\n\n        # Should generate 1000 UUIDs quickly\n        assert total_time &lt; 1.0  # Under 1 second\n        assert len(uuids) == 1000\n        assert len(set(uuids)) == 1000  # All unique (different emails)\n\n    def test_memory_usage(self):\n        \"\"\"Test memory usage during generation\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        # Generate many UUIDs\n        large_test_data = [f\"user{i}@test.com\" for i in range(10000)]\n        uuids = [\n            self.generator.generate(\"user\", email=email)\n            for email in large_test_data\n        ]\n\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n\n        # Memory increase should be reasonable (less than 10MB)\n        assert memory_increase &lt; 10 * 1024 * 1024\n        assert len(uuids) == 10000\n</code></pre>"},{"location":"use-cases/testing/#mock-and-stub-testing","title":"Mock and Stub Testing","text":""},{"location":"use-cases/testing/#deterministic-mocking","title":"Deterministic Mocking","text":"<pre><code>from unittest.mock import patch\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestWithMocking:\n    def setUp(self):\n        config = IDConfig(namespace=Namespace(\"test.example.com\"), salt=\"mock-test-v1\")\n        self.test_generator = UUIDGenerator(config)\n\n    @patch('external_service.get_user_id')\n    def test_external_service_integration(self, mock_get_user_id):\n        \"\"\"Test integration with external service using predictable UUIDs\"\"\"\n        test_email = \"mocktest@example.com\"\n        expected_uuid = self.test_generator.generate(\"user\", email=test_email)\n\n        # Mock external service to return deterministic UUID\n        mock_get_user_id.return_value = expected_uuid\n\n        # Test our service\n        result = our_service.process_user(test_email)\n\n        # Verify mock was called correctly\n        mock_get_user_id.assert_called_once_with(test_email)\n        assert result[\"user_id\"] == expected_uuid\n\n    def test_time_dependent_operations(self):\n        \"\"\"Test operations that depend on time using fixed timestamps\"\"\"\n        fixed_timestamp = \"2024-01-15T10:00:00Z\"\n\n        with patch('datetime.datetime') as mock_datetime:\n            mock_datetime.utcnow.return_value.isoformat.return_value = fixed_timestamp\n\n            # Generate UUID with deterministic timestamp\n            uuid_result = self.test_generator.generate(\n                \"event\",\n                user_email=\"timetest@example.com\",\n                timestamp=fixed_timestamp\n            )\n\n            # UUID is deterministic because timestamp is fixed\n            expected_uuid = self.test_generator.generate(\n                \"event\",\n                user_email=\"timetest@example.com\",\n                timestamp=fixed_timestamp\n            )\n            assert uuid_result == expected_uuid\n</code></pre>"},{"location":"use-cases/testing/#test-environment-management","title":"Test Environment Management","text":""},{"location":"use-cases/testing/#environment-specific-testing","title":"Environment-Specific Testing","text":"<pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig, Namespace\nfrom uuid import UUID\n\nclass TestEnvironmentConfiguration:\n    def test_development_environment(self):\n        \"\"\"Test development environment configuration\"\"\"\n        os.environ[\"ENVIRONMENT\"] = \"development\"\n        os.environ[\"UUID_NAMESPACE_DOMAIN\"] = \"dev.example.com\"\n\n        config = IDConfig(\n            namespace=Namespace(os.environ[\"UUID_NAMESPACE_DOMAIN\"]),\n            salt=f\"{os.environ['ENVIRONMENT']}-v1\"\n        )\n        generator = UUIDGenerator(config)\n\n        dev_uuid = generator.generate(\"user\", email=\"devtest@example.com\")\n\n        # Development environment generates consistent UUIDs\n        assert isinstance(dev_uuid, UUID)\n\n        # Can regenerate same UUID\n        dev_uuid_2 = generator.generate(\"user\", email=\"devtest@example.com\")\n        assert dev_uuid == dev_uuid_2\n\n    def test_production_environment(self):\n        \"\"\"Test production environment configuration\"\"\"\n        os.environ[\"ENVIRONMENT\"] = \"production\"\n        os.environ[\"UUID_NAMESPACE_DOMAIN\"] = \"prod.example.com\"\n\n        config = IDConfig(\n            namespace=Namespace(os.environ[\"UUID_NAMESPACE_DOMAIN\"]),\n            salt=f\"{os.environ['ENVIRONMENT']}-v1\"\n        )\n        generator = UUIDGenerator(config)\n\n        prod_uuid = generator.generate(\"user\", email=\"prodtest@example.com\")\n\n        # Production environment uses different namespace\n        # Different namespace/salt = different UUIDs even with same input\n        assert isinstance(prod_uuid, UUID)\n\n        # Verify it's different from dev (different namespace)\n        dev_config = IDConfig(\n            namespace=Namespace(\"dev.example.com\"),\n            salt=\"development-v1\"\n        )\n        dev_generator = UUIDGenerator(dev_config)\n        dev_uuid = dev_generator.generate(\"user\", email=\"prodtest@example.com\")\n        assert prod_uuid != dev_uuid  # Different environments = different UUIDs\n\n    def tearDown(self):\n        \"\"\"Clean up environment variables\"\"\"\n        for var in [\"ENVIRONMENT\", \"UUID_NAMESPACE_DOMAIN\"]:\n            if var in os.environ:\n                del os.environ[var]\n</code></pre>"},{"location":"use-cases/testing/#continuous-integration-testing","title":"Continuous Integration Testing","text":""},{"location":"use-cases/testing/#cicd-pipeline-testing","title":"CI/CD Pipeline Testing","text":"<pre><code># .github/workflows/test.yml\nname: Test Suite\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: \"3.11\"\n\n      - name: Install dependencies\n        run: |\n          pip install uv\n          uv sync --dev\n\n      - name: Run deterministic tests\n        run: |\n          # Run tests multiple times to verify determinism\n          uv run pytest tests/test_deterministic.py\n          uv run pytest tests/test_deterministic.py\n          uv run pytest tests/test_deterministic.py\n\n      - name: Run integration tests\n        run: uv run pytest tests/test_integration.py\n\n      - name: Run performance tests\n        run: uv run pytest tests/test_performance.py\n</code></pre>"},{"location":"use-cases/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Migration Use Case - Data migration with consistent UUIDs</li> <li>Best Practices - Testing optimization strategies</li> <li>Development Guide - Development testing setup</li> </ul>"}]}