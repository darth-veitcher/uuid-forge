{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"UUID-Forge Documentation","text":"<p>Deterministic UUID Generation for Cross-System Coordination</p> <p>Welcome to the UUID-Forge documentation! This library provides a simple, secure way to generate deterministic UUIDs that remain consistent across multiple storage systems without requiring inter-service communication or centralized ID generation.</p>"},{"location":"#what-is-uuid-forge","title":"What is UUID-Forge?","text":"<p>UUID-Forge solves a common problem in microservices and distributed systems: How do you maintain consistent entity identifiers across multiple storage systems?</p> <pre><code>from uuid_forge import generate_uuid_only, IDConfig\nimport os\n\n# Configure once\nconfig = IDConfig(salt=os.getenv(\"UUID_FORGE_SALT\"))\n\n# Generate UUID from business data\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\n# Later, regenerate the exact same UUID - no database needed!\nregenerated = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nassert invoice_uuid == regenerated  # Always True!\n</code></pre>"},{"location":"#core-principle","title":"Core Principle","text":"<p>Same Input + Same Config = Same UUID, Every Time</p> <p>This enables:</p> <ul> <li>\u2705 Zero coordination between services</li> <li>\u2705 Direct access to any storage system</li> <li>\u2705 No lookups required</li> <li>\u2705 Deterministic testing</li> <li>\u2705 Simple architecture</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":""},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running in minutes with our step-by-step guide.</p> <p>Get Started \u2192</p>"},{"location":"#user-guide","title":"\ud83d\udcda User Guide","text":"<p>Learn core concepts and best practices for production use.</p> <p>User Guide \u2192</p>"},{"location":"#api-reference","title":"\ud83d\udcd6 API Reference","text":"<p>Complete API documentation with examples and type signatures.</p> <p>API Reference \u2192</p>"},{"location":"#cli-reference","title":"\ud83d\udee0\ufe0f CLI Reference","text":"<p>Command-line interface for generating UUIDs and managing config.</p> <p>CLI Reference \u2192## Use Cases</p>"},{"location":"#microservices-architecture","title":"Microservices Architecture","text":"<p>Generate consistent IDs across multiple services without coordination:</p> <pre><code># Order Service\norder_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\n# Invoice Service (different codebase, same UUID!)\ninvoice_order_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\nassert order_uuid == invoice_order_uuid\n</code></pre>"},{"location":"#multi-storage-systems","title":"Multi-Storage Systems","text":"<p>Use the same UUID across all your storage layers:</p> <pre><code># Postgres\ndb.execute(\"INSERT INTO invoices (id, ...) VALUES (%s, ...)\", invoice_uuid)\n\n# S3\ns3.put_object(Key=f\"invoices/{invoice_uuid}.pdf\", ...)\n\n# Redis\nredis.set(f\"invoice:{invoice_uuid}\", ...)\n\n# All accessible with the same UUID!\n</code></pre>"},{"location":"#deterministic-testing","title":"Deterministic Testing","text":"<p>Reproduce exact UUIDs in tests for reliable assertions:</p> <pre><code>def test_invoice_processing():\n    test_config = IDConfig(salt=\"test-salt\")\n\n    # Known UUID for assertions\n    expected_uuid = generate_uuid_only(\n        \"invoice\",\n        config=test_config,\n        region=\"EUR\",\n        number=12345\n    )\n\n    # Test your code\n    result = process_invoice(region=\"EUR\", number=12345)\n\n    assert result.id == expected_uuid\n</code></pre>"},{"location":"#why-uuid-forge","title":"Why UUID-Forge?","text":"<p>Traditional approaches to cross-system ID coordination have significant drawbacks:</p> Approach Problems Central ID Service Single point of failure, latency, complexity Database Lookups Performance impact, requires database access ID Mappings Additional storage, synchronization challenges Random UUIDs No reproducibility, requires storage everywhere <p>UUID-Forge eliminates all of these problems with deterministic generation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd12 Secure: Cryptographic salt prevents UUID prediction</li> <li>\ud83c\udfaf Deterministic: Identical inputs always produce identical UUIDs</li> <li>\ud83d\ude80 Zero Coordination: No inter-service communication needed</li> <li>\ud83d\udce6 Simple API: Functional-first with optional OO wrapper</li> <li>\ud83d\udd27 Production Ready: Type-safe, tested, documented</li> <li>\ud83c\udfa8 CLI Included: First-class command-line interface</li> <li>\ud83d\udc0d Modern Python: Requires Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># With uv (recommended)\nuv add uuid-forge\n\n# With pip\npip install uuid-forge\n</code></pre> <p>Learn more \u2192</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ol> <li>Install UUID-Forge</li> <li>Follow the Quick Start guide</li> <li>Learn core concepts</li> <li>Explore use cases</li> </ol>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Contributing: Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>UUID-Forge is released under the MIT License. See License for details.</p>"},{"location":"about/changelog/","title":"Changelog","text":"<p>All notable changes to UUID-Forge will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"about/changelog/#unreleased","title":"[Unreleased]","text":""},{"location":"about/changelog/#added","title":"Added","text":"<ul> <li>Initial implementation of deterministic UUID generation</li> <li>Support for UUID versions 3, 4, and 5</li> <li>Comprehensive configuration system</li> <li>Command-line interface with full feature support</li> <li>Cross-platform compatibility</li> <li>Extensive documentation and examples</li> </ul>"},{"location":"about/changelog/#changed","title":"Changed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#deprecated","title":"Deprecated","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#removed","title":"Removed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#fixed","title":"Fixed","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#security","title":"Security","text":"<ul> <li>N/A (initial release)</li> </ul>"},{"location":"about/changelog/#010-2024-01-15","title":"[0.1.0] - 2024-01-15","text":""},{"location":"about/changelog/#added_1","title":"Added","text":"<ul> <li> <p>Core UUID Generation</p> </li> <li> <p>Deterministic UUID generation from various input types</p> </li> <li>Support for strings, dictionaries, and custom objects</li> <li>Configurable namespace support for entity isolation</li> <li> <p>Multiple UUID versions (3, 4, 5) with version 5 as default</p> </li> <li> <p>Configuration System</p> </li> <li> <p>Environment variable configuration support</p> </li> <li>Configuration file support (YAML/JSON)</li> <li>Hierarchical configuration with precedence rules</li> <li> <p>Runtime configuration validation</p> </li> <li> <p>Command-Line Interface</p> </li> <li> <p>Full-featured CLI with typer and rich for enhanced UX</p> </li> <li>Batch processing capabilities</li> <li>Multiple output formats (hex, urn, bytes)</li> <li>Configuration management commands</li> <li> <p>UUID validation and verification tools</p> </li> <li> <p>Developer Experience</p> </li> <li> <p>Comprehensive type hints throughout codebase</p> </li> <li>Extensive test suite with &gt;95% coverage</li> <li>Pre-commit hooks for code quality</li> <li>Detailed documentation with MkDocs</li> <li> <p>Performance benchmarks and optimization</p> </li> <li> <p>Documentation</p> </li> <li>Getting started guide with quick setup</li> <li>Comprehensive API reference</li> <li>Use case examples for microservices, multi-storage, testing</li> <li>Best practices and optimization guides</li> <li>CLI reference with all commands and options</li> </ul>"},{"location":"about/changelog/#technical-implementation","title":"Technical Implementation","text":"<ul> <li>Core Architecture: Clean separation between core logic, configuration, and CLI</li> <li>Type Safety: Full type annotations with mypy validation</li> <li>Testing: Unit tests, integration tests, and property-based testing</li> <li>Performance: Optimized for both single UUID generation and batch processing</li> <li>Security: Secure random salt generation and validation</li> <li>Compatibility: Python 3.11+ support with backwards compatibility considerations</li> </ul>"},{"location":"about/changelog/#quality-assurance","title":"Quality Assurance","text":"<ul> <li>Linting: Black, isort, ruff for code formatting and linting</li> <li>Type Checking: mypy for static type analysis</li> <li>Testing: pytest with coverage reporting</li> <li>Documentation: MkDocs with material theme and API documentation</li> <li>CI/CD: GitHub Actions for automated testing and deployment</li> </ul>"},{"location":"about/changelog/#template-for-future-releases","title":"Template for Future Releases","text":"<p>Use this template when creating new changelog entries:</p> <pre><code>## [X.Y.Z] - YYYY-MM-DD\n\n### Added\n\n- New features and functionality\n\n### Changed\n\n- Changes to existing functionality\n\n### Deprecated\n\n- Features marked for removal in future versions\n\n### Removed\n\n- Features removed in this version\n\n### Fixed\n\n- Bug fixes\n\n### Security\n\n- Security-related changes\n</code></pre>"},{"location":"about/changelog/#change-categories","title":"Change Categories","text":"<ul> <li>Added: New features</li> <li>Changed: Changes in existing functionality</li> <li>Deprecated: Soon-to-be removed features</li> <li>Removed: Now removed features</li> <li>Fixed: Any bug fixes</li> <li>Security: Security improvements or fixes</li> </ul>"},{"location":"about/license/","title":"License","text":"<p>UUID-Forge is released under the MIT License.</p>"},{"location":"about/license/#mit-license","title":"MIT License","text":"<p>Copyright (c) 2024 Darth Veitcher</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"about/license/#third-party-licenses","title":"Third-Party Licenses","text":"<p>UUID-Forge depends on several third-party packages, each with their own licenses:</p>"},{"location":"about/license/#runtime-dependencies","title":"Runtime Dependencies","text":"<ul> <li>Python Standard Library: Python Software Foundation License</li> <li>typing_extensions (if Python &lt; 3.11): Python Software Foundation License</li> </ul>"},{"location":"about/license/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>pytest: MIT License</li> <li>black: MIT License</li> <li>ruff: MIT License</li> <li>mypy: MIT License</li> <li>coverage: Apache License 2.0</li> <li>pre-commit: MIT License</li> <li>typer: MIT License</li> <li>rich: MIT License</li> </ul>"},{"location":"about/license/#documentation-dependencies","title":"Documentation Dependencies","text":"<ul> <li>mkdocs: BSD License</li> <li>mkdocs-material: MIT License</li> <li>mkdocstrings: ISC License</li> </ul>"},{"location":"about/license/#license-compatibility","title":"License Compatibility","text":"<p>The MIT License is:</p> <ul> <li>Permissive: Allows commercial and private use</li> <li>Compatible: Works with most other licenses</li> <li>Simple: Minimal restrictions and requirements</li> <li>Popular: Widely adopted in the Python ecosystem</li> </ul>"},{"location":"about/license/#using-uuid-forge-in-your-project","title":"Using UUID-Forge in Your Project","text":"<p>You can freely use UUID-Forge in your projects, whether:</p> <ul> <li>Open source: Include the license in your project</li> <li>Commercial: No additional requirements beyond attribution</li> <li>Private: Use internally without restrictions</li> <li>Modified: Create derivative works with attribution</li> </ul>"},{"location":"about/license/#attribution-requirements","title":"Attribution Requirements","text":"<p>When using UUID-Forge, you must:</p> <ol> <li>Include the license: Keep the MIT license text in your distribution</li> <li>Include copyright notice: Maintain the copyright notice</li> <li>No trademark use: Don't use UUID-Forge name without permission</li> </ol>"},{"location":"about/license/#warranty-disclaimer","title":"Warranty Disclaimer","text":"<p>UUID-Forge is provided \"as is\" without warranty of any kind. The authors are not liable for any damages arising from the use of this software.</p>"},{"location":"about/license/#contributing","title":"Contributing","text":"<p>By contributing to UUID-Forge, you agree that your contributions will be licensed under the same MIT License that covers the project.</p> <p>For more information about contributing, see Contributing Guide.</p>"},{"location":"api/cli/","title":"CLI API Reference","text":"<p>Complete reference for UUID-Forge command-line interface.</p>"},{"location":"api/cli/#cli-functions","title":"CLI Functions","text":"<p>The UUID-Forge CLI provides command-line access to UUID generation functionality.</p> <p>options: show_root_heading: true show_source: false heading_level: 3</p>"},{"location":"api/cli/#uuid_forge.cli.app","title":"uuid_forge.cli.app  <code>module-attribute</code>","text":"<pre><code>app = Typer(\n    name=\"uuid-forge\",\n    help=\"Deterministic UUID generation for cross-system coordination\",\n    add_completion=False,\n)\n</code></pre>"},{"location":"api/cli/#main-commands","title":"Main Commands","text":""},{"location":"api/cli/#generate","title":"generate","text":"<p>Generate UUIDs from input data.</p> <pre><code>uuid-forge generate [OPTIONS] [INPUTS]...\n</code></pre> <p>Arguments:</p> <ul> <li><code>INPUTS</code>: Input data for UUID generation (strings, files, etc.)</li> </ul> <p>Options:</p> <ul> <li><code>--namespace TEXT</code>: Namespace to use for generation</li> <li><code>--version {3,4,5}</code>: UUID version (default: 5)</li> <li><code>--format {hex,urn,bytes}</code>: Output format (default: hex)</li> <li><code>--case {upper,lower}</code>: Case for hex output (default: lower)</li> <li><code>--separator TEXT</code>: Separator for hex format (default: -)</li> <li><code>--input-file PATH</code>: Read inputs from file</li> <li><code>--output PATH</code>: Write output to file</li> <li><code>--stdin</code>: Read from standard input</li> <li><code>--verbose</code>: Verbose output</li> <li><code>--help</code>: Show help message</li> </ul> <p>Examples:</p> <pre><code># Generate single UUID\nuuid-forge generate \"user@example.com\"\n\n# Generate with custom namespace\nuuid-forge generate \"user@example.com\" --namespace users\n\n# Generate multiple UUIDs\nuuid-forge generate \"user1\" \"user2\" \"user3\"\n\n# From file\nuuid-forge generate --input-file users.txt\n\n# From stdin\necho \"test-data\" | uuid-forge generate --stdin\n\n# Custom format\nuuid-forge generate \"test\" --format urn --case upper\n</code></pre>"},{"location":"api/cli/#config","title":"config","text":"<p>Manage configuration settings.</p> <pre><code>uuid-forge config [SUBCOMMAND] [OPTIONS]\n</code></pre> <p>Subcommands:</p> <ul> <li><code>show</code>: Display current configuration</li> <li><code>get KEY</code>: Get specific configuration value</li> <li><code>set KEY VALUE</code>: Set configuration value</li> <li><code>init</code>: Create default configuration file</li> <li><code>validate</code>: Validate configuration</li> </ul> <p>Examples:</p> <pre><code># Show all configuration\nuuid-forge config show\n\n# Get specific setting\nuuid-forge config get namespace\n\n# Set configuration\nuuid-forge config set namespace \"my-app\"\nuuid-forge config set version 5\n\n# Create config file\nuuid-forge config init\n\n# Validate configuration\nuuid-forge config validate\n</code></pre>"},{"location":"api/cli/#validate","title":"validate","text":"<p>Validate UUIDs and check deterministic generation.</p> <pre><code>uuid-forge validate [OPTIONS] [UUIDS]...\n</code></pre> <p>Options:</p> <ul> <li><code>--input-file PATH</code>: Read UUIDs from file</li> <li><code>--check-deterministic INPUT UUID</code>: Check if UUID matches expected for input</li> <li><code>--format {hex,urn}</code>: Expected UUID format</li> <li><code>--verbose</code>: Verbose validation output</li> </ul> <p>Examples:</p> <pre><code># Validate single UUID\nuuid-forge validate 550e8400-e29b-41d4-a716-446655440000\n\n# Validate multiple UUIDs\nuuid-forge validate uuid1 uuid2 uuid3\n\n# Validate from file\nuuid-forge validate --input-file uuids.txt\n\n# Check deterministic generation\nuuid-forge validate --check-deterministic \"test-input\" 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"api/cli/#namespace","title":"namespace","text":"<p>Manage namespaces for UUID generation.</p> <pre><code>uuid-forge namespace [SUBCOMMAND] [OPTIONS]\n</code></pre> <p>Subcommands:</p> <ul> <li><code>list</code>: List available namespaces</li> <li><code>create NAME</code>: Create new namespace</li> <li><code>delete NAME</code>: Delete namespace</li> <li><code>show NAME</code>: Show namespace details</li> </ul> <p>Examples:</p> <pre><code># List namespaces\nuuid-forge namespace list\n\n# Create namespace\nuuid-forge namespace create \"my-service\"\n\n# Show namespace details\nuuid-forge namespace show \"my-service\"\n\n# Delete namespace\nuuid-forge namespace delete \"my-service\"\n</code></pre>"},{"location":"api/cli/#global-options","title":"Global Options","text":"<p>Available for all commands:</p> <ul> <li><code>--config PATH</code>: Configuration file path</li> <li><code>--verbose</code>: Enable verbose logging</li> <li><code>--quiet</code>: Suppress output except errors</li> <li><code>--debug</code>: Enable debug mode</li> <li><code>--version</code>: Show version information</li> <li><code>--help</code>: Show help message</li> </ul>"},{"location":"api/cli/#configuration","title":"Configuration","text":""},{"location":"api/cli/#configuration-file","title":"Configuration File","text":"<p>The CLI looks for configuration in:</p> <ol> <li>Path specified by <code>--config</code> option</li> <li><code>uuid_forge.yaml</code> in current directory</li> <li><code>~/.uuid_forge.yaml</code> in user home</li> <li><code>/etc/uuid_forge.yaml</code> system-wide</li> </ol>"},{"location":"api/cli/#environment-variables","title":"Environment Variables","text":"<p>All CLI options can be set via environment variables:</p> <pre><code>export UUID_FORGE_NAMESPACE=\"my-app\"\nexport UUID_FORGE_VERSION=5\nexport UUID_FORGE_FORMAT=\"hex\"\nexport UUID_FORGE_CASE=\"lower\"\nexport UUID_FORGE_CONFIG_FILE=\"/path/to/config.yaml\"\n</code></pre>"},{"location":"api/cli/#output-formats","title":"Output Formats","text":""},{"location":"api/cli/#standard-output","title":"Standard Output","text":"<p>Default output format for generated UUIDs:</p> <pre><code>$ uuid-forge generate \"test1\" \"test2\"\n550e8400-e29b-41d4-a716-446655440000\n550e8400-e29b-41d4-a716-446655440001\n</code></pre>"},{"location":"api/cli/#json-output","title":"JSON Output","text":"<p>Use <code>--format-output json</code> for structured output:</p> <pre><code>$ uuid-forge generate \"test1\" \"test2\" --format-output json\n[\n  {\n    \"input\": \"test1\",\n    \"uuid\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"namespace\": \"default\",\n    \"version\": 5\n  },\n  {\n    \"input\": \"test2\",\n    \"uuid\": \"550e8400-e29b-41d4-a716-446655440001\",\n    \"namespace\": \"default\",\n    \"version\": 5\n  }\n]\n</code></pre>"},{"location":"api/cli/#csv-output","title":"CSV Output","text":"<p>Use <code>--format-output csv</code> for CSV format:</p> <pre><code>$ uuid-forge generate \"test1\" \"test2\" --format-output csv\ninput,uuid,namespace,version\ntest1,550e8400-e29b-41d4-a716-446655440000,default,5\ntest2,550e8400-e29b-41d4-a716-446655440001,default,5\n</code></pre>"},{"location":"api/cli/#error-handling","title":"Error Handling","text":""},{"location":"api/cli/#exit-codes","title":"Exit Codes","text":"<ul> <li><code>0</code>: Success</li> <li><code>1</code>: General error</li> <li><code>2</code>: Invalid arguments</li> <li><code>3</code>: Configuration error</li> <li><code>4</code>: Validation error</li> </ul>"},{"location":"api/cli/#error-messages","title":"Error Messages","text":"<pre><code>$ uuid-forge generate --version 99\nError: Invalid UUID version: 99. Must be 3, 4, or 5.\n\n$ uuid-forge validate \"invalid-uuid\"\nError: Invalid UUID format: invalid-uuid\n\n$ uuid-forge config get nonexistent\nError: Configuration key 'nonexistent' not found.\n</code></pre>"},{"location":"api/cli/#batch-processing","title":"Batch Processing","text":""},{"location":"api/cli/#large-datasets","title":"Large Datasets","text":"<p>For processing large datasets efficiently:</p> <pre><code># Process in batches\nuuid-forge generate --input-file large-dataset.txt --batch-size 1000\n\n# Parallel processing\ncat users.txt | xargs -P 4 -I {} uuid-forge generate \"{}\" --namespace users\n</code></pre>"},{"location":"api/cli/#input-file-formats","title":"Input File Formats","text":"<p>Supported input file formats:</p> <p>Plain text (one input per line):</p> <pre><code>user1@example.com\nuser2@example.com\nuser3@example.com\n</code></pre> <p>JSON lines:</p> <pre><code>{\"email\": \"user1@example.com\", \"name\": \"User 1\"}\n{\"email\": \"user2@example.com\", \"name\": \"User 2\"}\n</code></pre> <p>CSV:</p> <pre><code>email,name\nuser1@example.com,User 1\nuser2@example.com,User 2\n</code></pre>"},{"location":"api/cli/#integration-examples","title":"Integration Examples","text":""},{"location":"api/cli/#shell-scripts","title":"Shell Scripts","text":"<pre><code>#!/bin/bash\n\n# Generate UUID and use in script\nUSER_UUID=$(uuid-forge generate \"$USER_EMAIL\" --namespace users)\necho \"Generated UUID for $USER_EMAIL: $USER_UUID\"\n\n# Validate UUIDs in file\nif uuid-forge validate --input-file production-uuids.txt; then\n    echo \"All UUIDs are valid\"\nelse\n    echo \"Some UUIDs are invalid\"\n    exit 1\nfi\n</code></pre>"},{"location":"api/cli/#makefile-integration","title":"Makefile Integration","text":"<pre><code># Generate test UUIDs\ngenerate-test-data:\n    uuid-forge generate --input-file test-users.txt --output test-uuids.txt\n\n# Validate production UUIDs\nvalidate-prod:\n    uuid-forge validate --input-file prod-uuids.txt\n\n# Clean up generated files\nclean:\n    rm -f test-uuids.txt generated-*.txt\n</code></pre>"},{"location":"api/cli/#cicd-pipelines","title":"CI/CD Pipelines","text":"<pre><code># GitHub Actions\nname: UUID Validation\non: [push, pull_request]\n\njobs:\n  validate-uuids:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Install UUID-Forge\n        run: pip install uuid-forge\n\n      - name: Generate test UUIDs\n        run: |\n          uuid-forge generate --input-file test-data.txt --output test-uuids.txt\n\n      - name: Validate UUIDs\n        run: |\n          uuid-forge validate --input-file test-uuids.txt\n</code></pre>"},{"location":"api/cli/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"api/cli/#verbose-mode","title":"Verbose Mode","text":"<p>Use <code>--verbose</code> for detailed output:</p> <pre><code>$ uuid-forge generate \"test\" --verbose\nINFO: Using namespace: default\nINFO: UUID version: 5\nINFO: Input data: test\nINFO: Generated UUID: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"api/cli/#debug-mode","title":"Debug Mode","text":"<p>Use <code>--debug</code> for maximum detail:</p> <pre><code>$ uuid-forge generate \"test\" --debug\nDEBUG: Configuration loaded from: /home/user/.uuid_forge.yaml\nDEBUG: Namespace resolved to: 6ba7b810-9dad-11d1-80b4-00c04fd430c8\nDEBUG: Input preprocessing: test -&gt; test\nDEBUG: Hash algorithm: SHA-1\nDEBUG: Generated UUID: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"api/cli/#common-issues","title":"Common Issues","text":"<p>Issue: \"Command not found\"</p> <pre><code># Solution: Ensure UUID-Forge is installed and in PATH\npip install uuid-forge\nwhich uuid-forge\n</code></pre> <p>Issue: \"Invalid UUID version\"</p> <pre><code># Solution: Use valid version (3, 4, or 5)\nuuid-forge generate \"test\" --version 5\n</code></pre> <p>Issue: \"Configuration file not found\"</p> <pre><code># Solution: Create configuration or specify path\nuuid-forge config init\n# or\nuuid-forge --config /path/to/config.yaml generate \"test\"\n</code></pre>"},{"location":"api/cli/#performance-considerations","title":"Performance Considerations","text":""},{"location":"api/cli/#optimization-tips","title":"Optimization Tips","text":"<ol> <li>Reuse configuration: Use config files instead of passing options repeatedly</li> <li>Batch processing: Process multiple inputs in single command</li> <li>Output to file: Use <code>--output</code> instead of shell redirection for large datasets</li> <li>Parallel processing: Use <code>xargs -P</code> for CPU-intensive operations</li> </ol>"},{"location":"api/cli/#benchmarking","title":"Benchmarking","text":"<pre><code># Time single generation\ntime uuid-forge generate \"test\"\n\n# Time batch generation\ntime uuid-forge generate --input-file large-dataset.txt\n\n# Memory usage\n/usr/bin/time -v uuid-forge generate --input-file large-dataset.txt\n</code></pre>"},{"location":"api/config/","title":"IDConfig API Reference","text":"<p>Complete reference for UUID-Forge configuration system.</p>"},{"location":"api/config/#configuration-management","title":"Configuration Management","text":"<p>The configuration system in UUID-Forge provides utilities for loading and managing UUID generation settings.</p>"},{"location":"api/config/#configuration-methods","title":"Configuration Methods","text":""},{"location":"api/config/#load-configuration","title":"Load Configuration","text":"<p>Load configuration from various sources:</p> <pre><code>from uuid_forge.config import load_config_from_env\nfrom uuid_forge.core import IDConfig\n\n# Load from environment variables\nconfig = load_config_from_env()\n\n# Create configuration directly\nconfig = IDConfig(namespace=\"my-app\", salt=\"custom-salt\")\n</code></pre>"},{"location":"api/config/#validation","title":"Validation","text":"<p>Configuration is automatically validated:</p> <pre><code># Valid configuration\nconfig = IDConfig(\n    namespace=\"my-app\",\n    salt=\"custom-salt\"\n)\n\n# Invalid configuration raises ValueError\ntry:\n    config = IDConfig(namespace=\"invalid-uuid-string\")  # Invalid namespace\nexcept ValueError as e:\n    print(f\"Configuration error: {e}\")\n</code></pre>"},{"location":"api/config/#configuration-options","title":"Configuration Options","text":""},{"location":"api/config/#core-settings","title":"Core Settings","text":"Option Type Default Description <code>namespace</code> <code>str</code> or <code>UUID</code> <code>None</code> Default namespace for UUID generation <code>version</code> <code>int</code> <code>5</code> UUID version (3, 4, or 5) <code>format</code> <code>str</code> <code>\"hex\"</code> Output format (<code>hex</code>, <code>urn</code>, <code>bytes</code>) <code>case</code> <code>str</code> <code>\"lower\"</code> Case for hex output (<code>upper</code>, <code>lower</code>) <code>separator</code> <code>str</code> <code>\"-\"</code> Separator character for hex format"},{"location":"api/config/#advanced-settings","title":"Advanced Settings","text":"Option Type Default Description <code>seed</code> <code>int</code> <code>None</code> Random seed for reproducible generation <code>clock_seq</code> <code>int</code> <code>None</code> Clock sequence for version 1 UUIDs <code>node</code> <code>int</code> <code>None</code> Node ID for version 1 UUIDs <code>json_encoder</code> <code>JSONEncoder</code> <code>None</code> Custom JSON encoder for object serialization"},{"location":"api/config/#configuration-file-format","title":"Configuration File Format","text":""},{"location":"api/config/#yaml-configuration","title":"YAML Configuration","text":"<pre><code># uuid_forge.yaml\nnamespace: \"my-application\"\nversion: 5\nformat: \"hex\"\ncase: \"lower\"\nseparator: \"-\"\n\n# Custom namespaces\nnamespaces:\n  users: \"550e8400-e29b-41d4-a716-446655440000\"\n  orders: \"550e8400-e29b-41d4-a716-446655440001\"\n  products: \"550e8400-e29b-41d4-a716-446655440002\"\n\n# Environment-specific settings\nenvironments:\n  development:\n    namespace: \"dev-app\"\n    seed: 12345\n  production:\n    namespace: \"prod-app\"\n    seed: null\n</code></pre>"},{"location":"api/config/#json-configuration","title":"JSON Configuration","text":"<pre><code>{\n  \"namespace\": \"my-application\",\n  \"version\": 5,\n  \"format\": \"hex\",\n  \"case\": \"lower\",\n  \"separator\": \"-\",\n  \"namespaces\": {\n    \"users\": \"550e8400-e29b-41d4-a716-446655440000\",\n    \"orders\": \"550e8400-e29b-41d4-a716-446655440001\"\n  }\n}\n</code></pre>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Configuration via environment variables:</p> Variable Description Example <code>UUID_FORGE_NAMESPACE</code> Default namespace <code>my-app</code> <code>UUID_FORGE_VERSION</code> UUID version <code>5</code> <code>UUID_FORGE_FORMAT</code> Output format <code>hex</code> <code>UUID_FORGE_CASE</code> Case for hex output <code>lower</code> <code>UUID_FORGE_SEPARATOR</code> Separator character <code>-</code> <code>UUID_FORGE_CONFIG_FILE</code> Configuration file path <code>/path/to/config.yaml</code>"},{"location":"api/config/#examples","title":"Examples","text":""},{"location":"api/config/#basic-configuration","title":"Basic Configuration","text":"<pre><code>from uuid_forge import IDConfig, UUIDGenerator\n\n# Simple configuration\nconfig = IDConfig(\n    namespace=\"my-app\",\n    version=5\n)\n\nforge = UUIDGenerator(config)\nuuid_result = forge.generate(\"test\")\n</code></pre>"},{"location":"api/config/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>import json\nfrom datetime import datetime\n\nclass CustomJSONEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        return super().default(obj)\n\nconfig = IDConfig(\n    namespace=\"advanced-app\",\n    version=5,\n    format=\"hex\",\n    case=\"upper\",\n    separator=\"\",\n    json_encoder=CustomJSONEncoder\n)\n\nforge = UUIDGenerator(config)\n</code></pre>"},{"location":"api/config/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<pre><code>import os\n\ndef create_config():\n    env = os.getenv(\"ENVIRONMENT\", \"development\")\n\n    if env == \"production\":\n        return IDConfig(\n            namespace=\"prod-app\",\n            version=5,\n            format=\"hex\"\n        )\n    else:\n        return IDConfig(\n            namespace=\"dev-app\",\n            version=5,\n            format=\"hex\",\n            seed=12345  # Consistent for testing\n        )\n\nconfig = create_config()\nforge = UUIDGenerator(config)\n</code></pre>"},{"location":"api/config/#configuration-inheritance","title":"Configuration Inheritance","text":"<pre><code># Base configuration\nbase_config = IDConfig(\n    version=5,\n    format=\"hex\",\n    case=\"lower\"\n)\n\n# Service-specific configurations\nuser_config = IDConfig(\n    namespace=\"users\",\n    **base_config.to_dict()\n)\n\norder_config = IDConfig(\n    namespace=\"orders\",\n    **base_config.to_dict()\n)\n</code></pre>"},{"location":"api/config/#validation-rules","title":"Validation Rules","text":""},{"location":"api/config/#namespace-validation","title":"Namespace Validation","text":"<ul> <li>Must be a valid UUID string or UUID object</li> <li>Empty string is converted to <code>None</code></li> <li>Invalid UUID strings raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#version-validation","title":"Version Validation","text":"<ul> <li>Must be 3, 4, or 5</li> <li>Other values raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#format-validation","title":"Format Validation","text":"<ul> <li>Must be one of: <code>\"hex\"</code>, <code>\"urn\"</code>, <code>\"bytes\"</code></li> <li>Case-insensitive matching</li> <li>Invalid formats raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#case-validation","title":"Case Validation","text":"<ul> <li>Must be one of: <code>\"upper\"</code>, <code>\"lower\"</code></li> <li>Case-insensitive matching</li> <li>Invalid cases raise <code>ValueError</code></li> </ul>"},{"location":"api/config/#configuration-precedence","title":"Configuration Precedence","text":"<p>Configuration is loaded in order of precedence:</p> <ol> <li>Explicit parameters - Passed to <code>IDConfig()</code> constructor</li> <li>Configuration file - Loaded from file path</li> <li>Environment variables - System environment</li> <li>Default values - Built-in defaults</li> </ol>"},{"location":"api/config/#error-handling","title":"Error Handling","text":"<pre><code>from uuid_forge.config import IDConfig, ConfigError\n\ntry:\n    config = IDConfig.load_from_file(\"invalid_config.yaml\")\nexcept ConfigError as e:\n    print(f\"Configuration error: {e}\")\nexcept FileNotFoundError:\n    print(\"Configuration file not found\")\n</code></pre>"},{"location":"api/config/#migration-and-compatibility","title":"Migration and Compatibility","text":""},{"location":"api/config/#version-migration","title":"Version Migration","text":"<pre><code>def migrate_config_v1_to_v2(old_config_dict):\n    \"\"\"Migrate configuration from v1 to v2 format\"\"\"\n    new_config = {}\n\n    # Map old keys to new keys\n    key_mapping = {\n        \"uuid_namespace\": \"namespace\",\n        \"uuid_version\": \"version\",\n        \"output_format\": \"format\"\n    }\n\n    for old_key, new_key in key_mapping.items():\n        if old_key in old_config_dict:\n            new_config[new_key] = old_config_dict[old_key]\n\n    return IDConfig(**new_config)\n</code></pre>"},{"location":"api/config/#backward-compatibility","title":"Backward Compatibility","text":"<p>UUID-Forge maintains backward compatibility for configuration:</p> <pre><code># Old style (still supported)\nconfig = IDConfig(\n    uuid_namespace=\"my-app\",  # Deprecated\n    uuid_version=5           # Deprecated\n)\n\n# New style (recommended)\nconfig = IDConfig(\n    namespace=\"my-app\",\n    version=5\n)\n</code></pre>"},{"location":"api/config/#testing-configuration","title":"Testing Configuration","text":"<pre><code>import pytest\nfrom uuid_forge.config import IDConfig\n\ndef test_config_validation():\n    \"\"\"Test configuration validation\"\"\"\n    # Valid configuration\n    config = IDConfig(namespace=\"test\", version=5)\n    assert config.namespace == \"test\"\n    assert config.version == 5\n\n    # Invalid version\n    with pytest.raises(ValueError):\n        IDConfig(version=99)\n\n    # Invalid format\n    with pytest.raises(ValueError):\n        IDConfig(format=\"invalid\")\n\ndef test_config_loading():\n    \"\"\"Test configuration loading from various sources\"\"\"\n    # From dict\n    config_dict = {\"namespace\": \"test\", \"version\": 5}\n    config = IDConfig(**config_dict)\n\n    # From environment (mock)\n    import os\n    os.environ[\"UUID_FORGE_NAMESPACE\"] = \"env-test\"\n    config = IDConfig.load_from_env()\n    assert config.namespace == \"env-test\"\n</code></pre>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core UUID generation functionality provided by <code>uuid_forge.core</code>.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The core module provides three main approaches to generating deterministic UUIDs:</p> <ol> <li>Functional API (recommended): Pure functions for UUID generation</li> <li>Object-Oriented API: Class-based wrapper for convenience</li> <li>Utility Functions: Helper functions for salt generation and UUID extraction</li> </ol>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#uuid_forge.core.IDConfig","title":"uuid_forge.core.IDConfig  <code>dataclass</code>","text":"<pre><code>IDConfig(namespace=NAMESPACE_DNS, salt='')\n</code></pre> <p>Configuration for deterministic UUID generation.</p> <p>This configuration ensures consistent UUID generation across different services and deployments. The namespace provides logical separation between different entity types or applications, while the salt adds security by preventing UUID prediction attacks.</p> <p>Attributes:</p> Name Type Description <code>namespace</code> <code>UUID | Namespace</code> <p>UUID namespace for generation. Can be a UUID object or a Namespace. Defaults to DNS-based namespace. For custom namespaces, use Namespace(\"domain.com\").</p> <code>salt</code> <code>str</code> <p>Random salt for security. CRITICAL: Keep this secret! Generate once per deployment and store securely in environment variables. Without a salt, UUIDs are predictable, which may be a security risk.</p> <p>Examples:</p> <pre><code>from uuid_forge.core import IDConfig, Namespace\n\n# Simple domain-based namespace\nconfig = IDConfig(\n    namespace=Namespace(\"mycompany.com\"),\n    salt=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\n)\n\n# Service-specific namespace\nconfig = IDConfig(\n    namespace=Namespace(\"users.mycompany.com\"),\n    salt=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\n)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; config = IDConfig(namespace=uuid.NAMESPACE_DNS, salt=\"test-salt\")\n&gt;&gt;&gt; config.namespace == uuid.NAMESPACE_DNS\nTrue\n&gt;&gt;&gt; config.salt == \"test-salt\"\nTrue\n&gt;&gt;&gt; # Test immutability - this should raise FrozenInstanceError\n&gt;&gt;&gt; config.salt = \"new-salt\"\nTraceback (most recent call last):\n...\nFrozenInstanceError: cannot assign to field 'salt'\n</code></pre> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Validate configuration after initialization.</p>"},{"location":"api/core/#uuid_forge.core.IDConfig-attributes","title":"Attributes","text":""},{"location":"api/core/#uuid_forge.core.IDConfig.namespace_uuid","title":"namespace_uuid  <code>property</code>","text":"<pre><code>namespace_uuid\n</code></pre> <p>Get the UUID representation of the namespace.</p>"},{"location":"api/core/#uuid_forge.core.IDConfig-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.IDConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    if not isinstance(self.namespace, uuid_module.UUID | Namespace):\n        raise TypeError(\n            f\"namespace must be a UUID or Namespace, got {type(self.namespace).__name__}\"\n        )\n</code></pre>"},{"location":"api/core/#primary-functions","title":"Primary Functions","text":""},{"location":"api/core/#generate_uuid_only","title":"generate_uuid_only","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_only","title":"uuid_forge.core.generate_uuid_only","text":"<pre><code>generate_uuid_only(entity_type, *args, config=None, **kwargs)\n</code></pre> <p>Generate a deterministic UUID from entity type and business data.</p> <p>This is the core function for generating idempotent UUIDs. Given the same inputs and configuration, it will always produce the same UUID. This enables zero-coordination ID generation across multiple services and storage systems.</p> <p>The function uses UUIDv5 (name-based, SHA-1) for deterministic generation, with an optional salt for security. The entity_type provides logical separation between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\"). This provides namespace separation between different entity types.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID. Can be any serializable data that uniquely identifies the entity.</p> <code>()</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt). IMPORTANT: In production, always provide a config with a salt for security.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID. Keys are sorted alphabetically to ensure consistency regardless of argument order.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID that will be identical for the same inputs and config.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\nimport uuid\nimport os\n\n# Production usage with config\nconfig = IDConfig(\n    namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n    salt=os.getenv(\"UUID_SALT\", \"\")\n)\n\n# Generate UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\n# Later, regenerate the same UUID from business data\nregenerated = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\nassert invoice_uuid == regenerated  # Always the same!\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_uuid_only, IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test basic generation\n&gt;&gt;&gt; uuid1 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Test idempotency\n&gt;&gt;&gt; uuid2 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid1 == uuid2  # Same inputs should produce same UUID\nTrue\n&gt;&gt;&gt; # Test with different inputs\n&gt;&gt;&gt; uuid3 = generate_uuid_only(\"test\", key=\"other\")\n&gt;&gt;&gt; uuid1 != uuid3  # Different inputs should produce different UUIDs\nTrue\n&gt;&gt;&gt; # Test with config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; uuid4 = generate_uuid_only(\"test\", key=\"value\", config=config)\n&gt;&gt;&gt; uuid5 = generate_uuid_only(\"test\", key=\"value\", config=config)\n&gt;&gt;&gt; uuid4 == uuid5  # Same config should produce same UUID\nTrue\n&gt;&gt;&gt; # Test that different config produces different UUID\n&gt;&gt;&gt; uuid6 = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid4 != uuid6  # Different config should produce different UUID\nTrue\n&gt;&gt;&gt; # Test kwargs order doesn't matter\n&gt;&gt;&gt; uuid7 = generate_uuid_only(\"test\", a=1, b=2)\n&gt;&gt;&gt; uuid8 = generate_uuid_only(\"test\", b=2, a=1)\n&gt;&gt;&gt; uuid7 == uuid8  # Kwargs order shouldn't matter\nTrue\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_only(\n    entity_type: str, *args: Any, config: IDConfig | None = None, **kwargs: Any\n) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID from entity type and business data.\n\n    This is the core function for generating idempotent UUIDs. Given the same\n    inputs and configuration, it will always produce the same UUID. This enables\n    zero-coordination ID generation across multiple services and storage systems.\n\n    The function uses UUIDv5 (name-based, SHA-1) for deterministic generation,\n    with an optional salt for security. The entity_type provides logical separation\n    between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n            This provides namespace separation between different entity types.\n        *args: Positional arguments contributing to the UUID. Can be any\n            serializable data that uniquely identifies the entity.\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt). IMPORTANT: In production,\n            always provide a config with a salt for security.\n        **kwargs: Keyword arguments contributing to the UUID. Keys are sorted\n            alphabetically to ensure consistency regardless of argument order.\n\n    Returns:\n        A deterministic UUID that will be identical for the same inputs and config.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_only, IDConfig\n        import uuid\n        import os\n\n        # Production usage with config\n        config = IDConfig(\n            namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n            salt=os.getenv(\"UUID_SALT\", \"\")\n        )\n\n        # Generate UUID for an invoice\n        invoice_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        # Later, regenerate the same UUID from business data\n        regenerated = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        assert invoice_uuid == regenerated  # Always the same!\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_uuid_only, IDConfig\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; # Test basic generation\n        &gt;&gt;&gt; uuid1 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\n        True\n        &gt;&gt;&gt; # Test idempotency\n        &gt;&gt;&gt; uuid2 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; uuid1 == uuid2  # Same inputs should produce same UUID\n        True\n        &gt;&gt;&gt; # Test with different inputs\n        &gt;&gt;&gt; uuid3 = generate_uuid_only(\"test\", key=\"other\")\n        &gt;&gt;&gt; uuid1 != uuid3  # Different inputs should produce different UUIDs\n        True\n        &gt;&gt;&gt; # Test with config\n        &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n        &gt;&gt;&gt; uuid4 = generate_uuid_only(\"test\", key=\"value\", config=config)\n        &gt;&gt;&gt; uuid5 = generate_uuid_only(\"test\", key=\"value\", config=config)\n        &gt;&gt;&gt; uuid4 == uuid5  # Same config should produce same UUID\n        True\n        &gt;&gt;&gt; # Test that different config produces different UUID\n        &gt;&gt;&gt; uuid6 = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; uuid4 != uuid6  # Different config should produce different UUID\n        True\n        &gt;&gt;&gt; # Test kwargs order doesn't matter\n        &gt;&gt;&gt; uuid7 = generate_uuid_only(\"test\", a=1, b=2)\n        &gt;&gt;&gt; uuid8 = generate_uuid_only(\"test\", b=2, a=1)\n        &gt;&gt;&gt; uuid7 == uuid8  # Kwargs order shouldn't matter\n        True\n    \"\"\"\n    if config is None:\n        config = IDConfig()\n    elif not isinstance(config, IDConfig):\n        raise TypeError(f\"config must be IDConfig, got {type(config).__name__}\")\n\n    # Build the name string from entity type, salt, and normalized inputs\n    parts = [entity_type]\n\n    if config.salt:\n        parts.append(f\"salt:{config.salt}\")\n\n    normalized = _normalize_input(*args, **kwargs)\n    if normalized:\n        parts.append(normalized)\n\n    name = \"|\".join(parts)\n\n    # Generate deterministic UUID\n    return uuid_module.uuid5(config.namespace_uuid, name)\n</code></pre>"},{"location":"api/core/#generate_uuid_with_prefix","title":"generate_uuid_with_prefix","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_with_prefix","title":"uuid_forge.core.generate_uuid_with_prefix","text":"<pre><code>generate_uuid_with_prefix(\n    entity_type, *args, prefix=None, separator=\"-\", config=None, **kwargs\n)\n</code></pre> <p>Generate a deterministic UUID with an optional human-readable prefix.</p> <p>This function extends generate_uuid_only by adding a human-readable prefix to the UUID. The prefix can be useful for: - Quick visual identification of entity types (e.g., \"INV-\" for invoices) - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices) - Making logs and debugging more human-friendly</p> <p>The prefix does NOT affect the UUID generation - it's purely cosmetic. The same business data will always produce the same UUID, regardless of prefix used.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\").</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID. If None, only the UUID is returned (as a string). Can include business context like region codes, year, or entity type abbreviations.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default config.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,</p> <code>str</code> <p>or just \"{uuid}\" if prefix is None.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_with_prefix, IDConfig\nimport os\n\nconfig = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n# With prefix\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Without prefix (just UUID as string)\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Custom separator\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    separator=\"_\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n&gt;&gt;&gt; # Test without prefix\n&gt;&gt;&gt; id1 = generate_uuid_with_prefix(\"test\", key=\"value\")\n&gt;&gt;&gt; \"-\" in id1  # Should be a UUID string\nTrue\n&gt;&gt;&gt; not id1.startswith(\"test\")  # No prefix\nTrue\n&gt;&gt;&gt; # Test with prefix\n&gt;&gt;&gt; id2 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; id2.startswith(\"TST-\")\nTrue\n&gt;&gt;&gt; # Test idempotency with prefix\n&gt;&gt;&gt; id3 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; id2 == id3  # Same inputs should produce same result\nTrue\n&gt;&gt;&gt; # Test that different prefixes don't change UUID part\n&gt;&gt;&gt; id4 = generate_uuid_with_prefix(\"test\", prefix=\"OTHER\", key=\"value\")\n&gt;&gt;&gt; uuid_part_2 = id2.split(\"-\", 1)[1]\n&gt;&gt;&gt; uuid_part_4 = id4.split(\"-\", 1)[1]\n&gt;&gt;&gt; uuid_part_2 == uuid_part_4  # UUID should be same regardless of prefix\nTrue\n&gt;&gt;&gt; # Test custom separator\n&gt;&gt;&gt; id5 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n&gt;&gt;&gt; id5.startswith(\"TST_\")  # Should use custom separator\nTrue\n&gt;&gt;&gt; # Test with config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; id6 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n&gt;&gt;&gt; id7 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n&gt;&gt;&gt; id6 == id7  # Config should be applied consistently\nTrue\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_with_prefix(\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    config: IDConfig | None = None,\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with an optional human-readable prefix.\n\n    This function extends generate_uuid_only by adding a human-readable prefix\n    to the UUID. The prefix can be useful for:\n    - Quick visual identification of entity types (e.g., \"INV-\" for invoices)\n    - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices)\n    - Making logs and debugging more human-friendly\n\n    The prefix does NOT affect the UUID generation - it's purely cosmetic.\n    The same business data will always produce the same UUID, regardless of\n    prefix used.\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID. If None, only\n            the UUID is returned (as a string). Can include business context\n            like region codes, year, or entity type abbreviations.\n        separator: Character(s) to use between prefix and UUID. Default is \"-\".\n        config: Configuration for UUID generation. If None, uses default config.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,\n        or just \"{uuid}\" if prefix is None.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n        import os\n\n        config = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n        # With prefix\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Without prefix (just UUID as string)\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n        # Custom separator\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV\",\n            separator=\"_\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n        &gt;&gt;&gt; # Test without prefix\n        &gt;&gt;&gt; id1 = generate_uuid_with_prefix(\"test\", key=\"value\")\n        &gt;&gt;&gt; \"-\" in id1  # Should be a UUID string\n        True\n        &gt;&gt;&gt; not id1.startswith(\"test\")  # No prefix\n        True\n        &gt;&gt;&gt; # Test with prefix\n        &gt;&gt;&gt; id2 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; id2.startswith(\"TST-\")\n        True\n        &gt;&gt;&gt; # Test idempotency with prefix\n        &gt;&gt;&gt; id3 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; id2 == id3  # Same inputs should produce same result\n        True\n        &gt;&gt;&gt; # Test that different prefixes don't change UUID part\n        &gt;&gt;&gt; id4 = generate_uuid_with_prefix(\"test\", prefix=\"OTHER\", key=\"value\")\n        &gt;&gt;&gt; uuid_part_2 = id2.split(\"-\", 1)[1]\n        &gt;&gt;&gt; uuid_part_4 = id4.split(\"-\", 1)[1]\n        &gt;&gt;&gt; uuid_part_2 == uuid_part_4  # UUID should be same regardless of prefix\n        True\n        &gt;&gt;&gt; # Test custom separator\n        &gt;&gt;&gt; id5 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n        &gt;&gt;&gt; id5.startswith(\"TST_\")  # Should use custom separator\n        True\n        &gt;&gt;&gt; # Test with config\n        &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n        &gt;&gt;&gt; id6 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n        &gt;&gt;&gt; id7 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n        &gt;&gt;&gt; id6 == id7  # Config should be applied consistently\n        True\n    \"\"\"\n    generated_uuid = generate_uuid_only(entity_type, *args, config=config, **kwargs)\n    uuid_str = str(generated_uuid)\n\n    if prefix:\n        return f\"{prefix}{separator}{uuid_str}\"\n    return uuid_str\n</code></pre>"},{"location":"api/core/#extract_uuid_from_prefixed","title":"extract_uuid_from_prefixed","text":""},{"location":"api/core/#uuid_forge.core.extract_uuid_from_prefixed","title":"uuid_forge.core.extract_uuid_from_prefixed","text":"<pre><code>extract_uuid_from_prefixed(prefixed_id, separator='-')\n</code></pre> <p>Extract the UUID from a prefixed identifier.</p> <p>This function parses a prefixed identifier string (created with generate_uuid_with_prefix) and extracts just the UUID portion. It intelligently handles both prefixed and non-prefixed UUIDs.</p> <p>Parameters:</p> Name Type Description Default <code>prefixed_id</code> <code>str</code> <p>The prefixed identifier string. Can be either: - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\" - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"</p> required <code>separator</code> <code>str</code> <p>The separator used between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <p>Returns:</p> Type Description <code>UUID</code> <p>The extracted UUID object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid UUID can be found in the input string.</p> Example <pre><code>from uuid_forge.core import (\n    generate_uuid_with_prefix,\n    extract_uuid_from_prefixed,\n    IDConfig\n)\n\nconfig = IDConfig(salt=\"my-secret-salt\")\n\n# Generate a prefixed ID\nprefixed = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Extract the UUID\nextracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n# Regenerate from business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n\nassert extracted_uuid == regenerated_uuid\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import (\n...     generate_uuid_with_prefix,\n...     extract_uuid_from_prefixed,\n...     generate_uuid_only\n... )\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test with prefixed UUID\n&gt;&gt;&gt; prefixed = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n&gt;&gt;&gt; isinstance(extracted, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Verify extracted UUID matches original\n&gt;&gt;&gt; original = generate_uuid_only(\"test\", key=\"value\")\n&gt;&gt;&gt; extracted == original\nTrue\n&gt;&gt;&gt; # Test with plain UUID string\n&gt;&gt;&gt; plain_uuid = str(generate_uuid_only(\"test\", key=\"other\"))\n&gt;&gt;&gt; extracted2 = extract_uuid_from_prefixed(plain_uuid)\n&gt;&gt;&gt; isinstance(extracted2, uuid.UUID)\nTrue\n&gt;&gt;&gt; str(extracted2) == plain_uuid\nTrue\n&gt;&gt;&gt; # Test with custom separator\n&gt;&gt;&gt; prefixed_custom = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n&gt;&gt;&gt; extracted3 = extract_uuid_from_prefixed(prefixed_custom, separator=\"_\")\n</code></pre> <p>extracted3 == original True</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def extract_uuid_from_prefixed(prefixed_id: str, separator: str = \"-\") -&gt; uuid_module.UUID:\n    \"\"\"Extract the UUID from a prefixed identifier.\n\n    This function parses a prefixed identifier string (created with\n    generate_uuid_with_prefix) and extracts just the UUID portion.\n    It intelligently handles both prefixed and non-prefixed UUIDs.\n\n    Args:\n        prefixed_id: The prefixed identifier string. Can be either:\n            - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n            - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"\n        separator: The separator used between prefix and UUID. Default is \"-\".\n\n    Returns:\n        The extracted UUID object.\n\n    Raises:\n        ValueError: If no valid UUID can be found in the input string.\n\n    Example:\n        ```python\n        from uuid_forge.core import (\n            generate_uuid_with_prefix,\n            extract_uuid_from_prefixed,\n            IDConfig\n        )\n\n        config = IDConfig(salt=\"my-secret-salt\")\n\n        # Generate a prefixed ID\n        prefixed = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Extract the UUID\n        extracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n        # Regenerate from business data\n        regenerated_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n\n        assert extracted_uuid == regenerated_uuid\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import (\n        ...     generate_uuid_with_prefix,\n        ...     extract_uuid_from_prefixed,\n        ...     generate_uuid_only\n        ... )\n        &gt;&gt;&gt; import uuid\n        &gt;&gt;&gt; # Test with prefixed UUID\n        &gt;&gt;&gt; prefixed = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n        &gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n        &gt;&gt;&gt; isinstance(extracted, uuid.UUID)\n        True\n        &gt;&gt;&gt; # Verify extracted UUID matches original\n        &gt;&gt;&gt; original = generate_uuid_only(\"test\", key=\"value\")\n        &gt;&gt;&gt; extracted == original\n        True\n        &gt;&gt;&gt; # Test with plain UUID string\n        &gt;&gt;&gt; plain_uuid = str(generate_uuid_only(\"test\", key=\"other\"))\n        &gt;&gt;&gt; extracted2 = extract_uuid_from_prefixed(plain_uuid)\n        &gt;&gt;&gt; isinstance(extracted2, uuid.UUID)\n        True\n        &gt;&gt;&gt; str(extracted2) == plain_uuid\n        True\n        &gt;&gt;&gt; # Test with custom separator\n        &gt;&gt;&gt; prefixed_custom = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n        &gt;&gt;&gt; extracted3 = extract_uuid_from_prefixed(prefixed_custom, separator=\"_\")\n    &gt;&gt;&gt; extracted3 == original\n    True\n    &gt;&gt;&gt; # Test with invalid input\n    &gt;&gt;&gt; extract_uuid_from_prefixed(\"not-a-uuid\")  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: No valid UUID found in 'not-a-uuid'\n    \"\"\"\n    # Split by separator and try to find UUID pattern\n    parts = prefixed_id.split(separator)\n\n    # Try each part from the end (UUID is typically at the end)\n    for i in range(len(parts)):\n        # Join remaining parts in case UUID has dashes\n        potential_uuid = separator.join(parts[i:])\n        try:\n            return uuid_module.UUID(potential_uuid)\n        except ValueError:\n            continue\n\n    raise ValueError(f\"No valid UUID found in '{prefixed_id}'\")\n</code></pre>"},{"location":"api/core/#uuid_forge.core.extract_uuid_from_prefixed--test-with-invalid-input","title":"Test with invalid input","text":"<p>extract_uuid_from_prefixed(\"not-a-uuid\")  # doctest: +IGNORE_EXCEPTION_DETAIL Traceback (most recent call last): ... ValueError: No valid UUID found in 'not-a-uuid'</p>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#generate_salt","title":"generate_salt","text":""},{"location":"api/core/#uuid_forge.core.generate_salt","title":"uuid_forge.core.generate_salt","text":"<pre><code>generate_salt(length=32)\n</code></pre> <p>Generate a cryptographically secure random salt for UUID generation.</p> <p>This function creates a URL-safe, base64-encoded random string suitable for use as a salt in IDConfig. The salt should be generated once per deployment and stored securely in environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the generated salt in bytes. Default is 32 bytes, which produces a 43-character base64 string.</p> <code>32</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL-safe base64-encoded string suitable for use as a salt.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If length is less than 16 bytes (minimum recommended).</p> Example <pre><code>from uuid_forge.core import generate_salt\n\n# Generate a new salt for your deployment\nsalt = generate_salt()\n# Add this to your .env file: UUID_SALT={salt}\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import generate_salt\n&gt;&gt;&gt; salt = generate_salt()\n&gt;&gt;&gt; isinstance(salt, str)\nTrue\n&gt;&gt;&gt; len(salt) &gt; 0\nTrue\n&gt;&gt;&gt; # Test different lengths\n&gt;&gt;&gt; salt_16 = generate_salt(16)\n&gt;&gt;&gt; salt_64 = generate_salt(64)\n&gt;&gt;&gt; len(salt_16) &lt; len(salt_64)\nTrue\n&gt;&gt;&gt; # Test minimum length validation\n&gt;&gt;&gt; generate_salt(15)\nTraceback (most recent call last):\n...\nValueError: Salt length must be at least 16 bytes for security, got 15\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_salt(length: int = 32) -&gt; str:\n    \"\"\"Generate a cryptographically secure random salt for UUID generation.\n\n    This function creates a URL-safe, base64-encoded random string suitable\n    for use as a salt in IDConfig. The salt should be generated once per\n    deployment and stored securely in environment variables.\n\n    Args:\n        length: Length of the generated salt in bytes. Default is 32 bytes,\n            which produces a 43-character base64 string.\n\n    Returns:\n        A URL-safe base64-encoded string suitable for use as a salt.\n\n    Raises:\n        ValueError: If length is less than 16 bytes (minimum recommended).\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_salt\n\n        # Generate a new salt for your deployment\n        salt = generate_salt()\n        # Add this to your .env file: UUID_SALT={salt}\n        ```\n\n    Examples:\n        &gt;&gt;&gt; from uuid_forge.core import generate_salt\n        &gt;&gt;&gt; salt = generate_salt()\n        &gt;&gt;&gt; isinstance(salt, str)\n        True\n        &gt;&gt;&gt; len(salt) &gt; 0\n        True\n        &gt;&gt;&gt; # Test different lengths\n        &gt;&gt;&gt; salt_16 = generate_salt(16)\n        &gt;&gt;&gt; salt_64 = generate_salt(64)\n        &gt;&gt;&gt; len(salt_16) &lt; len(salt_64)\n        True\n        &gt;&gt;&gt; # Test minimum length validation\n        &gt;&gt;&gt; generate_salt(15)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Salt length must be at least 16 bytes for security, got 15\n    \"\"\"\n    if length &lt; 16:\n        raise ValueError(f\"Salt length must be at least 16 bytes for security, got {length}\")\n\n    return secrets.token_urlsafe(length)\n</code></pre>"},{"location":"api/core/#object-oriented-api","title":"Object-Oriented API","text":""},{"location":"api/core/#uuidgenerator","title":"UUIDGenerator","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator","title":"uuid_forge.core.UUIDGenerator","text":"<pre><code>UUIDGenerator(config=None)\n</code></pre> <p>Object-oriented convenience wrapper for UUID generation.</p> <p>This class provides a stateful interface for UUID generation, holding a configuration that's applied to all generated UUIDs. This is useful when you're generating many UUIDs with the same configuration, as it reduces boilerplate and ensures consistency.</p> <p>The functional API (generate_uuid_only, generate_uuid_with_prefix) is recommended for most use cases. Use this class when you need: - Multiple UUIDs with the same configuration - Encapsulation of configuration in a service/repository - Dependency injection patterns</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>The IDConfig used for all UUID generation operations.</p> Example <pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\nimport uuid\nimport os\n\n# Create generator with production config\ngenerator = UUIDGenerator(\n    config=IDConfig(\n        namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n        salt=os.getenv(\"UUID_SALT\", \"\")\n    )\n)\n\n# Generate multiple UUIDs with same config\ninvoice_uuid = generator.generate(\"invoice\", region=\"EUR\", number=123)\norder_uuid = generator.generate(\"order\", customer_id=456)\n\n# With prefixes\nprefixed_invoice = generator.generate_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    region=\"EUR\",\n    number=123\n)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from uuid_forge.core import UUIDGenerator, IDConfig\n&gt;&gt;&gt; import uuid\n&gt;&gt;&gt; # Test with default config\n&gt;&gt;&gt; gen = UUIDGenerator()\n&gt;&gt;&gt; uuid1 = gen.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; isinstance(uuid1, uuid.UUID)\nTrue\n&gt;&gt;&gt; # Test idempotency\n&gt;&gt;&gt; uuid2 = gen.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid1 == uuid2\nTrue\n&gt;&gt;&gt; # Test with custom config\n&gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n&gt;&gt;&gt; gen_custom = UUIDGenerator(config=config)\n&gt;&gt;&gt; uuid3 = gen_custom.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid4 = gen_custom.generate(\"test\", key=\"value\")\n&gt;&gt;&gt; uuid3 == uuid4\nTrue\n&gt;&gt;&gt; # Different config produces different UUID\n&gt;&gt;&gt; uuid1 != uuid3\nTrue\n&gt;&gt;&gt; # Test generate_with_prefix\n&gt;&gt;&gt; prefixed = gen.generate_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n&gt;&gt;&gt; prefixed.startswith(\"TST-\")\nTrue\n&gt;&gt;&gt; # Verify UUID part matches\n&gt;&gt;&gt; from uuid_forge.core import extract_uuid_from_prefixed\n&gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n&gt;&gt;&gt; extracted == uuid1\nTrue\n</code></pre> <p>Initialize the UUID generator with a configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt).</p> <code>None</code> <p>Methods:</p> Name Description <code>generate</code> <p>Generate a deterministic UUID using this generator's configuration.</p> <code>generate_with_prefix</code> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __init__(self, config: IDConfig | None = None) -&gt; None:\n    \"\"\"Initialize the UUID generator with a configuration.\n\n    Args:\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt).\n    \"\"\"\n    self.config = config or IDConfig()\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate","title":"generate","text":"<pre><code>generate(entity_type, *args, **kwargs)\n</code></pre> <p>Generate a deterministic UUID using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_only with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate(self, entity_type: str, *args: Any, **kwargs: Any) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_only with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A deterministic UUID.\n    \"\"\"\n    return generate_uuid_only(entity_type, *args, config=self.config, **kwargs)\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate_with_prefix","title":"generate_with_prefix","text":"<pre><code>generate_with_prefix(entity_type, *args, prefix=None, separator='-', **kwargs)\n</code></pre> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_with_prefix with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID.</p> <code>'-'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with optional prefix and UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_with_prefix(\n    self,\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    **kwargs: Any,\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with prefix using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_with_prefix with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID.\n        separator: Character(s) to use between prefix and UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string with optional prefix and UUID.\n    \"\"\"\n    return generate_uuid_with_prefix(\n        entity_type, *args, prefix=prefix, separator=separator, config=self.config, **kwargs\n    )\n</code></pre>"},{"location":"api/core/#protocols","title":"Protocols","text":""},{"location":"api/core/#representable","title":"Representable","text":""},{"location":"api/core/#uuid_forge.core.Representable","title":"uuid_forge.core.Representable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can be represented as strings.</p> <p>Any object implementing repr satisfies this protocol and can be used directly with UUID generation functions.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return string representation of object.</p>"},{"location":"api/core/#uuid_forge.core.Representable-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.Representable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return string representation of object.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#usage-examples","title":"Usage Examples","text":""},{"location":"api/core/#basic-uuid-generation","title":"Basic UUID Generation","text":"<pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\n\n# Create configuration\nconfig = IDConfig(salt=\"production-secret-salt\")\n\n# Generate UUID\nuser_uuid = generate_uuid_only(\n    \"user\",\n    config=config,\n    email=\"alice@example.com\"\n)\n\nprint(user_uuid)  # UUID object\n</code></pre>"},{"location":"api/core/#with-human-readable-prefix","title":"With Human-Readable Prefix","text":"<pre><code>from uuid_forge.core import generate_uuid_with_prefix\n\n# Generate prefixed ID\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nprint(invoice_id)  # \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"api/core/#using-the-oo-api","title":"Using the OO API","text":"<pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\n\n# Create generator with configuration\ngenerator = UUIDGenerator(\n    config=IDConfig(salt=\"production-secret-salt\")\n)\n\n# Generate multiple UUIDs with same config\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\n</code></pre>"},{"location":"api/core/#extracting-uuids","title":"Extracting UUIDs","text":"<pre><code>from uuid_forge.core import extract_uuid_from_prefixed\n\n# Extract UUID from prefixed string\nprefixed = \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\nuuid = extract_uuid_from_prefixed(prefixed)\n\nprint(uuid)  # UUID('550e8400-e29b-41d4-a716-446655440000')\n</code></pre>"},{"location":"api/core/#type-information","title":"Type Information","text":"<p>All functions in the core module are fully typed. Import types for type hints:</p> <pre><code>from uuid import UUID\nfrom uuid_forge.core import IDConfig, Representable\nfrom typing import Optional\n\ndef process_entity(\n    entity_type: str,\n    config: Optional[IDConfig] = None,\n    **kwargs: Any\n) -&gt; UUID:\n    return generate_uuid_only(entity_type, config=config, **kwargs)\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>All functions in the core module are thread-safe. They have no shared mutable state and can be called concurrently from multiple threads.</p>"},{"location":"api/core/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>UUID generation is fast: ~10 microseconds per call</li> <li>No I/O operations are performed</li> <li>Memory usage is minimal (&lt; 1KB per call)</li> <li>Consider caching UUIDs if generating millions per second</li> </ul>"},{"location":"api/core/#security-notes","title":"Security Notes","text":"<p>Always Use a Salt in Production</p> <p>Without a salt, UUIDs are predictable and may pose a security risk. Always configure a cryptographic salt using <code>generate_salt()</code>.</p> <p>Keep Your Salt Secret</p> <p>The salt is effectively a secret key. Anyone with your salt can predict your UUIDs. Store it securely:</p> <ul> <li>Environment variables</li> <li>Secret management systems (AWS Secrets Manager, Vault, etc.)</li> <li>Never commit to version control</li> </ul>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Loading configuration from environment</li> <li>CLI Reference - Command-line interface</li> <li>Best Practices - Production guidelines</li> </ul>"},{"location":"development/contributing/","title":"Contributing to UUID-Forge","text":"<p>Thank you for your interest in contributing to UUID-Forge! This guide will help you get started with development and contribution.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":""},{"location":"development/contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>uv for dependency management</li> <li>Git for version control</li> </ul>"},{"location":"development/contributing/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n</code></pre> <ol> <li>Install dependencies:</li> </ol> <pre><code>uv sync --dev\n</code></pre> <ol> <li>Activate the virtual environment:</li> </ol> <pre><code>source .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre> <ol> <li>Install pre-commit hooks: <pre><code>uv run pre-commit install\n</code></pre></li> </ol>"},{"location":"development/contributing/#running-tests","title":"Running Tests","text":"<p>Run the full test suite:</p> <pre><code>uv run pytest\n</code></pre> <p>Run with coverage:</p> <pre><code>uv run pytest --cov=uuid_forge --cov-report=html\n</code></pre> <p>Run specific test categories:</p> <pre><code># Unit tests only\nuv run pytest tests/ -k \"not integration\"\n\n# Integration tests only\nuv run pytest tests/ -k \"integration\"\n\n# Performance tests\nuv run pytest tests/ -k \"performance\"\n</code></pre>"},{"location":"development/contributing/#code-quality","title":"Code Quality","text":"<p>We use several tools to maintain code quality:</p> <p>Formatting:</p> <pre><code>uv run black src tests\nuv run isort src tests\n</code></pre> <p>Linting:</p> <pre><code>uv run ruff check src tests\nuv run mypy src\n</code></pre> <p>All quality checks:</p> <pre><code>uv run pre-commit run --all-files\n</code></pre>"},{"location":"development/contributing/#project-structure","title":"Project Structure","text":"<pre><code>uuid-forge/\n\u251c\u2500\u2500 src/uuid_forge/          # Main package\n\u2502   \u251c\u2500\u2500 __init__.py          # Package initialization\n\u2502   \u251c\u2500\u2500 core.py              # Core UUID generation logic\n\u2502   \u251c\u2500\u2500 config.py            # Configuration management\n\u2502   \u2514\u2500\u2500 cli.py               # Command-line interface\n\u251c\u2500\u2500 tests/                   # Test suite\n\u2502   \u251c\u2500\u2500 test_core.py         # Core functionality tests\n\u2502   \u251c\u2500\u2500 test_config.py       # Configuration tests\n\u2502   \u251c\u2500\u2500 test_cli.py          # CLI tests\n\u2502   \u2514\u2500\u2500 conftest.py          # Test configuration\n\u251c\u2500\u2500 docs/                    # Documentation\n\u251c\u2500\u2500 pyproject.toml           # Project configuration\n\u2514\u2500\u2500 README.md               # Project overview\n</code></pre>"},{"location":"development/contributing/#contribution-guidelines","title":"Contribution Guidelines","text":""},{"location":"development/contributing/#code-style","title":"Code Style","text":"<ul> <li>Follow PEP 8 style guidelines</li> <li>Use type hints for all functions and methods</li> <li>Write descriptive docstrings (Google style)</li> <li>Keep functions and classes focused and small</li> <li>Use meaningful variable and function names</li> </ul>"},{"location":"development/contributing/#example-code-style","title":"Example Code Style","text":"<pre><code>def generate_uuid_from_data(\n    data: dict[str, Any],\n    namespace: str | None = None\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID from structured data.\n\n    Args:\n        data: Dictionary containing the data to generate UUID from\n        namespace: Optional namespace for UUID generation\n\n    Returns:\n        Generated UUID as a string\n\n    Raises:\n        ValueError: If data is empty or invalid\n\n    Example:\n        &gt;&gt;&gt; generate_uuid_from_data({\"user\": \"john@example.com\"})\n        '550e8400-e29b-41d4-a716-446655440000'\n    \"\"\"\n    if not data:\n        raise ValueError(\"Data cannot be empty\")\n\n    # Implementation here...\n    return uuid_string\n</code></pre>"},{"location":"development/contributing/#documentation","title":"Documentation","text":"<ul> <li>Update documentation for new features</li> <li>Include examples in docstrings</li> <li>Add entries to CHANGELOG.md</li> <li>Update README.md if needed</li> </ul>"},{"location":"development/contributing/#testing","title":"Testing","text":"<p>All contributions must include tests:</p> <ul> <li>Unit tests for individual functions/methods</li> <li>Integration tests for feature workflows</li> <li>Property-based tests for edge cases (using Hypothesis)</li> <li>Performance tests for optimization claims</li> </ul> <p>Example test structure:</p> <pre><code>def test_uuid_generation_deterministic():\n    \"\"\"Test that UUID generation is deterministic.\"\"\"\n    generator = UUIDGenerator(namespace=\"test\")\n\n    # Generate UUID multiple times\n    uuid1 = generator.generate(\"test-data\")\n    uuid2 = generator.generate(\"test-data\")\n\n    # Should be identical\n    assert uuid1 == uuid2\n    assert isinstance(uuid1, str)\n    assert len(uuid1) == 36  # Standard UUID length\n</code></pre>"},{"location":"development/contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"development/contributing/#bug-reports","title":"Bug Reports","text":"<p>When reporting bugs, please include:</p> <ul> <li>Description: Clear description of the bug</li> <li>Steps to reproduce: Minimal example to reproduce the issue</li> <li>Expected behavior: What you expected to happen</li> <li>Actual behavior: What actually happened</li> <li>Environment: Python version, OS, package versions</li> <li>Stack trace: Full error output if applicable</li> </ul>"},{"location":"development/contributing/#feature-requests","title":"Feature Requests","text":"<p>For new features, please provide:</p> <ul> <li>Use case: Why is this feature needed?</li> <li>Proposed API: How should the feature work?</li> <li>Alternatives: Other ways to achieve the same goal</li> <li>Breaking changes: Will this break existing code?</li> </ul>"},{"location":"development/contributing/#pull-requests","title":"Pull Requests","text":"<p>Before submitting a pull request:</p> <ol> <li>Fork the repository and create a feature branch</li> <li>Write tests for your changes</li> <li>Update documentation as needed</li> <li>Run all tests and quality checks</li> <li>Write a clear commit message</li> </ol> <p>Pull request checklist:</p> <ul> <li> Tests pass locally</li> <li> Code follows style guidelines</li> <li> Documentation updated</li> <li> CHANGELOG.md updated</li> <li> No breaking changes (or clearly documented)</li> </ul>"},{"location":"development/contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"development/contributing/#branching-strategy","title":"Branching Strategy","text":"<ul> <li><code>main</code>: Stable release branch</li> <li><code>develop</code>: Development integration branch</li> <li><code>feature/*</code>: Feature development branches</li> <li><code>bugfix/*</code>: Bug fix branches</li> <li><code>hotfix/*</code>: Critical fixes for production</li> </ul>"},{"location":"development/contributing/#commit-messages","title":"Commit Messages","text":"<p>Use conventional commit format:</p> <pre><code>type(scope): description\n\nOptional longer description\n\nCloses #issue-number\n</code></pre> <p>Types:</p> <ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style changes</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Test changes</li> <li><code>chore</code>: Build/maintenance tasks</li> </ul> <p>Examples:</p> <pre><code>feat(core): add support for custom hash algorithms\n\nfix(cli): handle empty input gracefully\n\ndocs(api): update configuration examples\n</code></pre>"},{"location":"development/contributing/#release-process","title":"Release Process","text":""},{"location":"development/contributing/#version-numbers","title":"Version Numbers","text":"<p>We follow Semantic Versioning:</p> <ul> <li>MAJOR: Incompatible API changes</li> <li>MINOR: New functionality (backward compatible)</li> <li>PATCH: Bug fixes (backward compatible)</li> </ul>"},{"location":"development/contributing/#release-steps","title":"Release Steps","text":"<ol> <li>Update version in <code>pyproject.toml</code></li> <li>Update <code>CHANGELOG.md</code></li> <li>Create release tag</li> <li>Build and publish to PyPI</li> <li>Create GitHub release</li> </ol>"},{"location":"development/contributing/#getting-help","title":"Getting Help","text":""},{"location":"development/contributing/#community-support","title":"Community Support","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>GitHub Discussions: Questions and general discussion</li> <li>Documentation: Comprehensive guides and API reference</li> </ul>"},{"location":"development/contributing/#development-questions","title":"Development Questions","text":"<p>If you have questions about development:</p> <ol> <li>Check existing issues and discussions</li> <li>Read the documentation thoroughly</li> <li>Look at existing code for patterns</li> <li>Ask specific questions with examples</li> </ol>"},{"location":"development/contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>CHANGELOG.md for significant contributions</li> <li>README.md contributors section</li> <li>GitHub contributors graph</li> <li>Release notes for major contributions</li> </ul>"},{"location":"development/contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>Please note that this project follows a Code of Conduct. By participating, you agree to abide by its terms:</p> <ul> <li>Be respectful and inclusive</li> <li>Focus on constructive feedback</li> <li>Help create a welcoming environment</li> <li>Report unacceptable behavior</li> </ul> <p>Thank you for contributing to UUID-Forge! Your contributions help make deterministic UUID generation better for everyone.</p>"},{"location":"development/release/","title":"Release Process","text":"<p>Comprehensive guide for maintainers on how to prepare, execute, and follow up on UUID-Forge releases.</p>"},{"location":"development/release/#release-overview","title":"Release Overview","text":"<p>UUID-Forge follows Semantic Versioning and uses an automated release process with proper testing, documentation, and distribution.</p>"},{"location":"development/release/#version-types","title":"Version Types","text":"<ul> <li>MAJOR (X.0.0): Breaking changes to public API</li> <li>MINOR (X.Y.0): New features, backward compatible</li> <li>PATCH (X.Y.Z): Bug fixes, backward compatible</li> </ul>"},{"location":"development/release/#pre-release-checklist","title":"Pre-Release Checklist","text":""},{"location":"development/release/#1-code-quality-verification","title":"1. Code Quality Verification","text":"<pre><code># Run full test suite\nuv run pytest\n\n# Check code coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n# Ensure coverage is &gt;95%\n\n# Run type checking\nuv run mypy src\n\n# Run linting\nuv run ruff check src tests\n\n# Format code\nuv run black src tests\nuv run isort src tests\n\n# Run pre-commit hooks\nuv run pre-commit run --all-files\n</code></pre>"},{"location":"development/release/#2-documentation-updates","title":"2. Documentation Updates","text":"<pre><code># Build documentation locally\nuv run mkdocs build --strict\n\n# Serve documentation for review\nuv run mkdocs serve\n\n# Check for broken links\nuv run mkdocs build --strict 2&gt;&amp;1 | grep WARNING\n</code></pre> <p>Update these files:</p> <ul> <li><code>CHANGELOG.md</code> - Add new version entry</li> <li><code>README.md</code> - Update examples if needed</li> <li><code>docs/</code> - Update any relevant documentation</li> <li><code>pyproject.toml</code> - Verify metadata is current</li> </ul>"},{"location":"development/release/#3-version-verification","title":"3. Version Verification","text":"<pre><code># Check current version\nuv run python -c \"from uuid_forge import __version__; print(__version__)\"\n\n# Verify version in all files matches\ngrep -r \"version.*=\" pyproject.toml\ngrep -r \"__version__\" src/uuid_forge/\n</code></pre>"},{"location":"development/release/#release-preparation","title":"Release Preparation","text":""},{"location":"development/release/#1-update-version-numbers","title":"1. Update Version Numbers","text":"<p>pyproject.toml:</p> <pre><code>[project]\nversion = \"1.2.3\"\n</code></pre> <p>src/uuid_forge/_version.py:</p> <pre><code>__version__ = \"1.2.3\"\n</code></pre>"},{"location":"development/release/#2-update-changelogmd","title":"2. Update CHANGELOG.md","text":"<pre><code>## [1.2.3] - 2024-01-15\n\n### Added\n\n- New feature descriptions\n- New functionality\n\n### Changed\n\n- Modified behavior descriptions\n- Updated dependencies\n\n### Fixed\n\n- Bug fix descriptions\n- Performance improvements\n\n### Deprecated\n\n- Features marked for removal\n\n### Removed\n\n- Removed features\n\n### Security\n\n- Security improvements\n</code></pre>"},{"location":"development/release/#3-create-release-branch","title":"3. Create Release Branch","text":"<pre><code># Create release branch\ngit checkout -b release/v1.2.3\n\n# Commit version updates\ngit add .\ngit commit -m \"chore: prepare release v1.2.3\"\n\n# Push release branch\ngit push origin release/v1.2.3\n</code></pre>"},{"location":"development/release/#release-execution","title":"Release Execution","text":""},{"location":"development/release/#1-final-testing","title":"1. Final Testing","text":"<pre><code># Install in clean environment\npython -m venv test-release\nsource test-release/bin/activate\npip install .\n\n# Test CLI functionality\nuuid-forge --version\nuuid-forge generate \"test-release\"\n\n# Test Python API\npython -c \"from uuid_forge import UUIDGenerator; print(UUIDGenerator().generate('test'))\"\n\n# Deactivate test environment\ndeactivate\nrm -rf test-release\n</code></pre>"},{"location":"development/release/#2-create-release-pr","title":"2. Create Release PR","text":"<p>Create a Pull Request from <code>release/v1.2.3</code> to <code>main</code>:</p> <p>PR Title: <code>Release v1.2.3</code></p> <p>PR Description:</p> <pre><code>## Release v1.2.3\n\n### Changes\n\n- Summary of major changes\n- Link to detailed CHANGELOG.md\n\n### Pre-release Checklist\n\n- [x] All tests passing\n- [x] Documentation updated\n- [x] Version numbers updated\n- [x] CHANGELOG.md updated\n- [x] Manual testing completed\n\n### Post-merge Actions\n\n- [ ] Create GitHub release\n- [ ] Build and publish to PyPI\n- [ ] Update documentation site\n- [ ] Announce release\n</code></pre>"},{"location":"development/release/#3-merge-and-tag","title":"3. Merge and Tag","text":"<p>After PR approval and merge:</p> <pre><code># Switch to main and pull latest\ngit checkout main\ngit pull origin main\n\n# Create and push tag\ngit tag -a v1.2.3 -m \"Release v1.2.3\"\ngit push origin v1.2.3\n</code></pre>"},{"location":"development/release/#automated-release-pipeline","title":"Automated Release Pipeline","text":""},{"location":"development/release/#github-actions-workflow","title":"GitHub Actions Workflow","text":"<p>.github/workflows/release.yml:</p> <pre><code>name: Release\n\non:\n  push:\n    tags:\n      - \"v*\"\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Install dependencies\n        run: uv sync --dev\n\n      - name: Run tests\n        run: uv run pytest --cov=uuid_forge\n\n      - name: Build documentation\n        run: uv run mkdocs build --strict\n\n  build:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Build package\n        run: uv build\n\n      - name: Store build artifacts\n        uses: actions/upload-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n  publish-pypi:\n    needs: build\n    runs-on: ubuntu-latest\n    environment: release\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n      - name: Publish to PyPI\n        uses: pypa/gh-action-pypi-publish@release/v1\n        with:\n          password: ${{ secrets.PYPI_API_TOKEN }}\n\n  github-release:\n    needs: [test, build]\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Download build artifacts\n        uses: actions/download-artifact@v3\n        with:\n          name: dist\n          path: dist/\n\n      - name: Create GitHub Release\n        uses: softprops/action-gh-release@v1\n        with:\n          files: dist/*\n          generate_release_notes: true\n          draft: false\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n\n  deploy-docs:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n        with:\n          fetch-depth: 0\n\n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: \"3.11\"\n\n      - name: Install uv\n        run: pip install uv\n\n      - name: Install dependencies\n        run: uv sync --dev\n\n      - name: Deploy documentation\n        run: |\n          git config user.name github-actions\n          git config user.email github-actions@github.com\n          uv run mike deploy --push --update-aliases ${{ github.ref_name }} latest\n</code></pre>"},{"location":"development/release/#manual-release-steps","title":"Manual Release Steps","text":"<p>If automated release fails, follow these manual steps:</p>"},{"location":"development/release/#1-build-package","title":"1. Build Package","text":"<pre><code># Clean previous builds\nrm -rf dist/ build/\n\n# Build package\nuv build\n\n# Verify build\nls -la dist/\n# Should see: uuid_forge-1.2.3.tar.gz and uuid_forge-1.2.3-py3-none-any.whl\n</code></pre>"},{"location":"development/release/#2-test-package","title":"2. Test Package","text":"<pre><code># Test installation from built package\npip install dist/uuid_forge-1.2.3-py3-none-any.whl\n\n# Test functionality\npython -c \"from uuid_forge import UUIDGenerator; print('OK')\"\nuuid-forge --version\n\n# Uninstall test installation\npip uninstall uuid-forge -y\n</code></pre>"},{"location":"development/release/#3-upload-to-pypi","title":"3. Upload to PyPI","text":"<pre><code># Install twine if not available\npip install twine\n\n# Check package\nuv run twine check dist/*\n\n# Upload to Test PyPI first\nuv run twine upload --repository testpypi dist/*\n\n# Test installation from Test PyPI\npip install --index-url https://test.pypi.org/simple/ uuid-forge==1.2.3\n\n# If test successful, upload to production PyPI\nuv run twine upload dist/*\n</code></pre>"},{"location":"development/release/#4-create-github-release","title":"4. Create GitHub Release","text":"<ol> <li>Go to GitHub repository releases page</li> <li>Click \"Create a new release\"</li> <li>Choose the tag <code>v1.2.3</code></li> <li>Title: <code>v1.2.3</code></li> <li>Description: Copy from CHANGELOG.md</li> <li>Attach built files from <code>dist/</code></li> <li>Click \"Publish release\"</li> </ol>"},{"location":"development/release/#post-release-tasks","title":"Post-Release Tasks","text":""},{"location":"development/release/#1-update-documentation","title":"1. Update Documentation","text":"<pre><code># Deploy documentation with version\nuv run mike deploy v1.2.3 latest --update-aliases --push\n\n# Verify documentation is live\nopen https://yourusername.github.io/uuid-forge/\n</code></pre>"},{"location":"development/release/#2-verify-package-distribution","title":"2. Verify Package Distribution","text":"<pre><code># Test installation from PyPI\npip install uuid-forge==1.2.3\n\n# Verify functionality\npython -c \"from uuid_forge import __version__; print(__version__)\"\nuuid-forge --version\n\n# Clean up\npip uninstall uuid-forge -y\n</code></pre>"},{"location":"development/release/#3-update-development-environment","title":"3. Update Development Environment","text":"<pre><code># Switch to develop branch\ngit checkout develop\n\n# Merge main into develop\ngit merge main\n\n# Push updated develop\ngit push origin develop\n\n# Clean up release branch\ngit branch -d release/v1.2.3\ngit push origin --delete release/v1.2.3\n</code></pre>"},{"location":"development/release/#4-prepare-next-development","title":"4. Prepare Next Development","text":"<p>Update version for development:</p> <pre><code># pyproject.toml\n[project]\nversion = \"1.2.4-dev\"\n</code></pre> <pre><code># src/uuid_forge/_version.py\n__version__ = \"1.2.4-dev\"\n</code></pre> <pre><code># Commit development version\ngit add .\ngit commit -m \"chore: bump version to 1.2.4-dev\"\ngit push origin develop\n</code></pre>"},{"location":"development/release/#release-communication","title":"Release Communication","text":""},{"location":"development/release/#1-announcement-channels","title":"1. Announcement Channels","text":"<p>GitHub Release Notes: Automatically generated PyPI Description: Updated from README.md Documentation: Updated automatically</p>"},{"location":"development/release/#2-social-media-optional","title":"2. Social Media (Optional)","text":"<p>Twitter:</p> <pre><code>\ud83c\udf89 UUID-Forge v1.2.3 is now available!\n\n\u2728 New features:\n- Feature 1\n- Feature 2\n\n\ud83d\udc1b Bug fixes and improvements\n\nInstall: pip install uuid-forge==1.2.3\n\n#Python #UUID #OpenSource\n</code></pre>"},{"location":"development/release/#emergency-procedures","title":"Emergency Procedures","text":""},{"location":"development/release/#hotfix-release","title":"Hotfix Release","text":"<p>For critical bugs in production:</p> <pre><code># Create hotfix branch from main\ngit checkout main\ngit checkout -b hotfix/v1.2.4\n\n# Make minimal fix\n# Update version to 1.2.4\n# Update CHANGELOG.md\n\n# Test thoroughly\nuv run pytest\n\n# Create PR to main\n# After merge, follow normal release process\n</code></pre>"},{"location":"development/release/#release-rollback","title":"Release Rollback","text":"<p>If critical issues are discovered:</p> <pre><code># Remove from PyPI (contact PyPI support)\n# Create new patch release with fix\n# Update documentation to recommend new version\n</code></pre>"},{"location":"development/release/#failed-release-recovery","title":"Failed Release Recovery","text":"<p>If release process fails:</p> <ol> <li>Check CI/CD logs for specific failure</li> <li>Fix issue in code or configuration</li> <li>Delete failed tag if necessary:    <pre><code>git tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n</code></pre></li> <li>Create new tag and retry release</li> </ol>"},{"location":"development/release/#release-metrics","title":"Release Metrics","text":"<p>Track these metrics for each release:</p> <ul> <li>Download counts from PyPI</li> <li>GitHub release downloads</li> <li>Documentation page views</li> <li>Issue reports post-release</li> <li>Community feedback</li> </ul>"},{"location":"development/release/#security-considerations","title":"Security Considerations","text":""},{"location":"development/release/#release-security","title":"Release Security","text":"<ul> <li>Sign releases with GPG keys</li> <li>Verify dependencies are up to date</li> <li>Scan for vulnerabilities before release</li> <li>Use secure CI/CD practices</li> </ul>"},{"location":"development/release/#dependency-management","title":"Dependency Management","text":"<pre><code># Update dependencies before release\nuv sync --upgrade\n\n# Check for security vulnerabilities\nuv run pip-audit\n\n# Review dependency changes\nuv run pip list --outdated\n</code></pre>"},{"location":"development/release/#troubleshooting","title":"Troubleshooting","text":""},{"location":"development/release/#common-issues","title":"Common Issues","text":"<p>Version Mismatch:</p> <ul> <li>Ensure all files have consistent version numbers</li> <li>Check both <code>pyproject.toml</code> and <code>_version.py</code></li> </ul> <p>Build Failures:</p> <ul> <li>Clean build directories: <code>rm -rf dist/ build/</code></li> <li>Check for missing dependencies</li> <li>Verify Python version compatibility</li> </ul> <p>Upload Failures:</p> <ul> <li>Check PyPI credentials</li> <li>Verify package name availability</li> <li>Ensure proper file permissions</li> </ul> <p>Documentation Deployment:</p> <ul> <li>Check GitHub Pages settings</li> <li>Verify mike configuration</li> <li>Test documentation build locally</li> </ul>"},{"location":"development/release/#next-steps","title":"Next Steps","text":"<p>After successful release:</p> <ul> <li>Monitor for issues and feedback</li> <li>Plan next release features</li> <li>Update project roadmap</li> <li>Review and improve release process</li> </ul> <p>For more information:</p> <ul> <li>Contributing Guidelines</li> <li>Development Setup</li> <li>Testing Guide</li> </ul>"},{"location":"development/setup/","title":"Development Setup","text":"<p>Set up your development environment for contributing to UUID-Forge.</p>"},{"location":"development/setup/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.11 or higher: UUID-Forge requires modern Python features</li> <li>uv: Fast Python package installer and resolver</li> <li>Git: Version control system</li> <li>Code Editor: VS Code, PyCharm, or your preferred editor</li> </ul>"},{"location":"development/setup/#installation","title":"Installation","text":""},{"location":"development/setup/#1-install-uv","title":"1. Install uv","text":"<p>If you don't have uv installed:</p> <pre><code># On macOS/Linux\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# On Windows\npowershell -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n\n# Or via pip\npip install uv\n</code></pre>"},{"location":"development/setup/#2-clone-the-repository","title":"2. Clone the Repository","text":"<pre><code>git clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n</code></pre>"},{"location":"development/setup/#3-set-up-development-environment","title":"3. Set Up Development Environment","text":"<pre><code># Create virtual environment and install dependencies\nuv sync --dev\n\n# Activate virtual environment\nsource .venv/bin/activate  # On Unix/macOS\n# or\n.venv\\Scripts\\activate  # On Windows\n</code></pre>"},{"location":"development/setup/#4-install-pre-commit-hooks","title":"4. Install Pre-commit Hooks","text":"<pre><code>uv run pre-commit install\n</code></pre>"},{"location":"development/setup/#development-dependencies","title":"Development Dependencies","text":"<p>The development environment includes:</p>"},{"location":"development/setup/#core-dependencies","title":"Core Dependencies","text":"<ul> <li>typer: CLI framework</li> <li>rich: Rich text and beautiful formatting</li> <li>pydantic: Data validation (if used)</li> </ul>"},{"location":"development/setup/#development-tools","title":"Development Tools","text":"<ul> <li>pytest: Testing framework</li> <li>pytest-cov: Coverage reporting</li> <li>pytest-benchmark: Performance testing</li> <li>hypothesis: Property-based testing</li> </ul>"},{"location":"development/setup/#code-quality","title":"Code Quality","text":"<ul> <li>black: Code formatting</li> <li>isort: Import sorting</li> <li>ruff: Fast Python linter</li> <li>mypy: Static type checking</li> <li>pre-commit: Git hooks for code quality</li> </ul>"},{"location":"development/setup/#documentation","title":"Documentation","text":"<ul> <li>mkdocs: Documentation generator</li> <li>mkdocs-material: Material theme for MkDocs</li> <li>mkdocstrings: API documentation from docstrings</li> </ul>"},{"location":"development/setup/#project-structure","title":"Project Structure","text":"<pre><code>uuid-forge/\n\u251c\u2500\u2500 .github/                 # GitHub workflows and templates\n\u2502   \u2514\u2500\u2500 workflows/\n\u2502       \u251c\u2500\u2500 ci.yml          # Continuous integration\n\u2502       \u2514\u2500\u2500 release.yml     # Release automation\n\u251c\u2500\u2500 .vscode/                # VS Code configuration\n\u2502   \u251c\u2500\u2500 settings.json       # Editor settings\n\u2502   \u2514\u2500\u2500 launch.json         # Debug configuration\n\u251c\u2500\u2500 docs/                   # Documentation source\n\u2502   \u251c\u2500\u2500 index.md           # Homepage\n\u2502   \u251c\u2500\u2500 getting-started/   # Getting started guides\n\u2502   \u251c\u2500\u2500 guide/             # User guides\n\u2502   \u251c\u2500\u2500 api/               # API reference\n\u2502   \u251c\u2500\u2500 use-cases/         # Use case examples\n\u2502   \u2514\u2500\u2500 development/       # Development docs\n\u251c\u2500\u2500 src/uuid_forge/         # Main package\n\u2502   \u251c\u2500\u2500 __init__.py        # Package initialization\n\u2502   \u251c\u2500\u2500 core.py            # Core UUID generation\n\u2502   \u251c\u2500\u2500 config.py          # Configuration management\n\u2502   \u2514\u2500\u2500 cli.py             # Command-line interface\n\u251c\u2500\u2500 tests/                  # Test suite\n\u2502   \u251c\u2500\u2500 conftest.py        # Test configuration\n\u2502   \u251c\u2500\u2500 test_core.py       # Core functionality tests\n\u2502   \u251c\u2500\u2500 test_config.py     # Configuration tests\n\u2502   \u251c\u2500\u2500 test_cli.py        # CLI tests\n\u2502   \u2514\u2500\u2500 integration/       # Integration tests\n\u251c\u2500\u2500 .gitignore             # Git ignore patterns\n\u251c\u2500\u2500 .pre-commit-config.yaml # Pre-commit configuration\n\u251c\u2500\u2500 mkdocs.yml             # Documentation configuration\n\u251c\u2500\u2500 pyproject.toml         # Project configuration\n\u2514\u2500\u2500 README.md              # Project overview\n</code></pre>"},{"location":"development/setup/#development-workflow","title":"Development Workflow","text":""},{"location":"development/setup/#1-create-feature-branch","title":"1. Create Feature Branch","text":"<pre><code>git checkout -b feature/your-feature-name\n</code></pre>"},{"location":"development/setup/#2-make-changes","title":"2. Make Changes","text":"<p>Edit code following the project conventions:</p> <ul> <li>Type hints: Use type hints for all functions</li> <li>Docstrings: Google-style docstrings</li> <li>Testing: Write tests for new functionality</li> <li>Documentation: Update docs for user-facing changes</li> </ul>"},{"location":"development/setup/#3-run-tests","title":"3. Run Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run with coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_core.py\n\n# Run tests matching pattern\nuv run pytest -k \"test_uuid_generation\"\n</code></pre>"},{"location":"development/setup/#4-check-code-quality","title":"4. Check Code Quality","text":"<pre><code># Format code\nuv run black src tests\n\n# Sort imports\nuv run isort src tests\n\n# Check linting\nuv run ruff check src tests\n\n# Type checking\nuv run mypy src\n\n# Run all pre-commit hooks\nuv run pre-commit run --all-files\n</code></pre>"},{"location":"development/setup/#5-build-documentation","title":"5. Build Documentation","text":"<pre><code># Build documentation\nuv run mkdocs build\n\n# Serve documentation locally\nuv run mkdocs serve\n</code></pre>"},{"location":"development/setup/#6-commit-changes","title":"6. Commit Changes","text":"<pre><code>git add .\ngit commit -m \"feat: add new UUID generation feature\"\n</code></pre> <p>The pre-commit hooks will automatically run and ensure code quality.</p>"},{"location":"development/setup/#ide-configuration","title":"IDE Configuration","text":""},{"location":"development/setup/#vs-code-setup","title":"VS Code Setup","text":"<p>Recommended VS Code extensions:</p> <pre><code>{\n  \"recommendations\": [\n    \"ms-python.python\",\n    \"ms-python.black-formatter\",\n    \"ms-python.isort\",\n    \"charliermarsh.ruff\",\n    \"ms-python.mypy-type-checker\",\n    \"ms-python.pytest\",\n    \"yzhang.markdown-all-in-one\"\n  ]\n}\n</code></pre> <p>VS Code settings (<code>.vscode/settings.json</code>):</p> <pre><code>{\n  \"python.defaultInterpreterPath\": \"./.venv/bin/python\",\n  \"python.formatting.provider\": \"black\",\n  \"python.linting.enabled\": true,\n  \"python.linting.ruffEnabled\": true,\n  \"python.testing.pytestEnabled\": true,\n  \"python.testing.pytestPath\": \"./.venv/bin/pytest\",\n  \"editor.formatOnSave\": true,\n  \"editor.codeActionsOnSave\": {\n    \"source.organizeImports\": true\n  }\n}\n</code></pre>"},{"location":"development/setup/#pycharm-setup","title":"PyCharm Setup","text":"<ol> <li>Open Project: Open the <code>uuid-forge</code> directory</li> <li>Configure Interpreter: Set Python interpreter to <code>.venv/bin/python</code></li> <li>Enable Tools:</li> <li>Code \u2192 Reformat Code (Black)</li> <li>Code \u2192 Optimize Imports (isort)</li> <li>Enable type checking in settings</li> </ol>"},{"location":"development/setup/#testing","title":"Testing","text":""},{"location":"development/setup/#test-categories","title":"Test Categories","text":"<p>Unit Tests: Test individual functions and classes</p> <pre><code>uv run pytest tests/test_core.py::test_uuid_generation\n</code></pre> <p>Integration Tests: Test component interactions</p> <pre><code>uv run pytest tests/integration/\n</code></pre> <p>Property Tests: Test with generated data using Hypothesis</p> <pre><code>uv run pytest tests/test_properties.py\n</code></pre> <p>Performance Tests: Benchmark performance</p> <pre><code>uv run pytest tests/test_performance.py --benchmark-only\n</code></pre>"},{"location":"development/setup/#writing-tests","title":"Writing Tests","text":"<p>Example test structure:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\nclass TestUUIDGeneration:\n    def setUp(self):\n        self.generator = UUIDGenerator(namespace=\"test\")\n\n    def test_deterministic_generation(self):\n        \"\"\"Test that UUID generation is deterministic.\"\"\"\n        uuid1 = self.generator.generate(\"test-input\")\n        uuid2 = self.generator.generate(\"test-input\")\n\n        assert uuid1 == uuid2\n        assert len(uuid1) == 36\n\n    @pytest.mark.parametrize(\"input_data\", [\n        \"string\",\n        {\"key\": \"value\"},\n        [\"list\", \"data\"],\n        42\n    ])\n    def test_various_input_types(self, input_data):\n        \"\"\"Test UUID generation with various input types.\"\"\"\n        uuid_result = self.generator.generate(input_data)\n\n        assert isinstance(uuid_result, str)\n        assert len(uuid_result) == 36\n</code></pre>"},{"location":"development/setup/#test-configuration","title":"Test Configuration","text":"<p>The <code>conftest.py</code> file contains shared test fixtures:</p> <pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\n@pytest.fixture\ndef test_generator():\n    \"\"\"Provide a test UUID generator.\"\"\"\n    return UUIDGenerator(namespace=\"test-namespace\")\n\n@pytest.fixture\ndef sample_data():\n    \"\"\"Provide sample test data.\"\"\"\n    return {\n        \"users\": [\n            {\"email\": \"user1@test.com\", \"name\": \"User 1\"},\n            {\"email\": \"user2@test.com\", \"name\": \"User 2\"}\n        ],\n        \"orders\": [\n            {\"id\": \"order1\", \"total\": 100.0},\n            {\"id\": \"order2\", \"total\": 200.0}\n        ]\n    }\n</code></pre>"},{"location":"development/setup/#debugging","title":"Debugging","text":""},{"location":"development/setup/#vs-code-debugging","title":"VS Code Debugging","text":"<p>Launch configuration (<code>.vscode/launch.json</code>):</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python: Current File\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"program\": \"${file}\",\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\",\n      \"env\": {\n        \"PYTHONPATH\": \"${workspaceFolder}/src\"\n      }\n    },\n    {\n      \"name\": \"Python: Test Current File\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"pytest\",\n      \"args\": [\"${file}\"],\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    },\n    {\n      \"name\": \"UUID-Forge CLI\",\n      \"type\": \"python\",\n      \"request\": \"launch\",\n      \"module\": \"uuid_forge.cli\",\n      \"args\": [\"generate\", \"test-input\"],\n      \"console\": \"integratedTerminal\",\n      \"cwd\": \"${workspaceFolder}\"\n    }\n  ]\n}\n</code></pre>"},{"location":"development/setup/#debug-configuration","title":"Debug Configuration","text":"<p>Enable debug logging:</p> <pre><code>import logging\n\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Use in code\nlogger.debug(\"Debug information\")\n</code></pre>"},{"location":"development/setup/#performance-profiling","title":"Performance Profiling","text":""},{"location":"development/setup/#profile-code-performance","title":"Profile Code Performance","text":"<pre><code># Profile with cProfile\npython -m cProfile -o profile.stats -m uuid_forge.cli generate \"test-data\"\n\n# Analyze profile\npython -c \"import pstats; pstats.Stats('profile.stats').sort_stats('cumulative').print_stats(10)\"\n</code></pre>"},{"location":"development/setup/#memory-profiling","title":"Memory Profiling","text":"<pre><code># Install memory profiler\nuv add --dev memory-profiler\n\n# Profile memory usage\npython -m memory_profiler uuid_forge/core.py\n</code></pre>"},{"location":"development/setup/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\n@pytest.mark.benchmark\ndef test_uuid_generation_performance(benchmark):\n    \"\"\"Benchmark UUID generation performance.\"\"\"\n    generator = UUIDGenerator(namespace=\"benchmark\")\n\n    result = benchmark(generator.generate, \"benchmark-data\")\n\n    assert len(result) == 36\n</code></pre>"},{"location":"development/setup/#documentation-development","title":"Documentation Development","text":""},{"location":"development/setup/#local-documentation-server","title":"Local Documentation Server","text":"<pre><code># Start local server with auto-reload\nuv run mkdocs serve\n\n# Build documentation\nuv run mkdocs build\n\n# Deploy to GitHub Pages (maintainers only)\nuv run mkdocs gh-deploy\n</code></pre>"},{"location":"development/setup/#writing-documentation","title":"Writing Documentation","text":"<ul> <li>Use clear, concise language</li> <li>Include code examples</li> <li>Add links between related sections</li> <li>Follow the existing style and structure</li> </ul>"},{"location":"development/setup/#common-tasks","title":"Common Tasks","text":""},{"location":"development/setup/#add-new-dependency","title":"Add New Dependency","text":"<pre><code># Add runtime dependency\nuv add package-name\n\n# Add development dependency\nuv add --dev package-name\n\n# Update lockfile\nuv lock\n</code></pre>"},{"location":"development/setup/#update-dependencies","title":"Update Dependencies","text":"<pre><code># Update all dependencies\nuv sync --upgrade\n\n# Update specific package\nuv add package-name@latest\n</code></pre>"},{"location":"development/setup/#release-preparation","title":"Release Preparation","text":"<pre><code># Update version in pyproject.toml\n# Update CHANGELOG.md\n# Run full test suite\nuv run pytest\n\n# Build package\nuv build\n\n# Check package\nuv run twine check dist/*\n</code></pre>"},{"location":"development/setup/#getting-help","title":"Getting Help","text":"<ul> <li>Documentation: Check existing docs first</li> <li>Issues: Search GitHub issues for similar problems</li> <li>Discussions: Use GitHub Discussions for questions</li> <li>Code Review: Submit PRs for feedback</li> </ul> <p>For development questions, include:</p> <ul> <li>Python version</li> <li>Operating system</li> <li>Full error messages</li> <li>Minimal reproduction example</li> </ul>"},{"location":"development/testing/","title":"Development Testing","text":"<p>Comprehensive guide to testing practices and infrastructure for UUID-Forge development.</p>"},{"location":"development/testing/#testing-philosophy","title":"Testing Philosophy","text":"<p>UUID-Forge follows a comprehensive testing strategy that ensures:</p> <ul> <li>Correctness: All functionality works as specified</li> <li>Determinism: UUIDs are consistently generated</li> <li>Performance: Generation is fast and efficient</li> <li>Reliability: Code works across different environments</li> <li>Maintainability: Tests are clear and maintainable</li> </ul>"},{"location":"development/testing/#test-structure","title":"Test Structure","text":""},{"location":"development/testing/#test-organization","title":"Test Organization","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Shared test configuration\n\u251c\u2500\u2500 test_core.py             # Core functionality tests\n\u251c\u2500\u2500 test_config.py           # Configuration tests\n\u251c\u2500\u2500 test_cli.py              # CLI tests\n\u251c\u2500\u2500 test_init.py             # Package initialization tests\n\u251c\u2500\u2500 test_version.py          # Version tests\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 test_database.py     # Database integration\n\u2502   \u251c\u2500\u2500 test_api.py          # API integration\n\u2502   \u2514\u2500\u2500 test_cli_integration.py # CLI integration\n\u251c\u2500\u2500 performance/             # Performance tests\n\u2502   \u251c\u2500\u2500 test_benchmarks.py   # Benchmark tests\n\u2502   \u2514\u2500\u2500 test_memory.py       # Memory usage tests\n\u2514\u2500\u2500 property/                # Property-based tests\n    \u251c\u2500\u2500 test_determinism.py  # Determinism properties\n    \u2514\u2500\u2500 test_uniqueness.py   # Uniqueness properties\n</code></pre>"},{"location":"development/testing/#test-categories","title":"Test Categories","text":"<p>Unit Tests: Test individual functions and classes in isolation Integration Tests: Test component interactions and workflows Property Tests: Test mathematical properties using generated data Performance Tests: Benchmark and validate performance requirements Regression Tests: Prevent previously fixed bugs from reoccurring</p>"},{"location":"development/testing/#unit-testing","title":"Unit Testing","text":""},{"location":"development/testing/#core-functionality-tests","title":"Core Functionality Tests","text":"<pre><code>import pytest\nimport uuid\nfrom uuid_forge.core import UUIDGenerator, IDConfig\n\nclass TestUUIDGenerator:\n    \"\"\"Test core UUID generation functionality.\"\"\"\n\n    def setUp(self):\n        self.config = IDConfig(namespace=\"test-namespace\")\n        self.generator = UUIDGenerator(self.config)\n\n    def test_deterministic_generation(self):\n        \"\"\"Test that same input produces same UUID.\"\"\"\n        input_data = \"test-input\"\n\n        uuid1 = self.generator.generate(input_data)\n        uuid2 = self.generator.generate(input_data)\n\n        assert uuid1 == uuid2\n        assert isinstance(uuid1, str)\n        assert len(uuid1) == 36\n\n    def test_different_inputs_different_uuids(self):\n        \"\"\"Test that different inputs produce different UUIDs.\"\"\"\n        uuid1 = self.generator.generate(\"input1\")\n        uuid2 = self.generator.generate(\"input2\")\n\n        assert uuid1 != uuid2\n\n    def test_valid_uuid_format(self):\n        \"\"\"Test that generated UUIDs have valid format.\"\"\"\n        uuid_result = self.generator.generate(\"test\")\n\n        # Should be parseable as UUID\n        parsed_uuid = uuid.UUID(uuid_result)\n        assert str(parsed_uuid) == uuid_result\n\n        # Should have correct format\n        assert len(uuid_result) == 36\n        assert uuid_result.count('-') == 4\n\n    @pytest.mark.parametrize(\"input_data\", [\n        \"string\",\n        {\"key\": \"value\"},\n        [\"list\", \"item\"],\n        42,\n        3.14,\n        True,\n        None\n    ])\n    def test_various_input_types(self, input_data):\n        \"\"\"Test UUID generation with various input types.\"\"\"\n        uuid_result = self.generator.generate(input_data)\n\n        assert isinstance(uuid_result, str)\n        assert len(uuid_result) == 36\n\n        # Same input should produce same UUID\n        uuid_again = self.generator.generate(input_data)\n        assert uuid_result == uuid_again\n\n    def test_namespace_isolation(self):\n        \"\"\"Test that different namespaces produce different UUIDs.\"\"\"\n        config1 = IDConfig(namespace=\"namespace1\")\n        config2 = IDConfig(namespace=\"namespace2\")\n\n        gen1 = UUIDGenerator(config1)\n        gen2 = UUIDGenerator(config2)\n\n        input_data = \"same-input\"\n        uuid1 = gen1.generate(input_data)\n        uuid2 = gen2.generate(input_data)\n\n        assert uuid1 != uuid2\n\n    def test_empty_input_handling(self):\n        \"\"\"Test handling of empty inputs.\"\"\"\n        empty_inputs = [\"\", {}, [], None]\n\n        for empty_input in empty_inputs:\n            uuid_result = self.generator.generate(empty_input)\n            assert isinstance(uuid_result, str)\n            assert len(uuid_result) == 36\n</code></pre>"},{"location":"development/testing/#configuration-tests","title":"Configuration Tests","text":"<pre><code>from uuid_forge.config import load_config_from_env, init_config_file\nfrom uuid_forge.core import IDConfig\nimport os\nimport tempfile\n\nclass TestConfiguration:\n    \"\"\"Test configuration loading and validation.\"\"\"\n\n    def test_default_config(self):\n        \"\"\"Test default configuration values.\"\"\"\n        config = IDConfig()\n\n        assert config.namespace is not None\n        assert isinstance(config.salt, str)\n        assert len(config.salt) &gt; 0\n\n    def test_custom_namespace(self):\n        \"\"\"Test custom namespace configuration.\"\"\"\n        custom_namespace = \"custom-test-namespace\"\n        config = IDConfig(namespace=custom_namespace)\n\n        assert config.namespace == custom_namespace\n\n    def test_environment_config_loading(self):\n        \"\"\"Test loading configuration from environment variables.\"\"\"\n        test_namespace = \"env-test-namespace\"\n        test_salt = \"env-test-salt\"\n\n        # Set environment variables\n        os.environ[\"UUID_FORGE_NAMESPACE\"] = test_namespace\n        os.environ[\"UUID_FORGE_SALT\"] = test_salt\n\n        try:\n            config = load_config_from_env()\n            assert config.namespace == test_namespace\n            assert config.salt == test_salt\n        finally:\n            # Cleanup\n            del os.environ[\"UUID_FORGE_NAMESPACE\"]\n            del os.environ[\"UUID_FORGE_SALT\"]\n\n    def test_config_file_creation(self):\n        \"\"\"Test configuration file creation.\"\"\"\n        with tempfile.TemporaryDirectory() as temp_dir:\n            config_path = os.path.join(temp_dir, \"test_config.yaml\")\n\n            init_config_file(config_path)\n\n            assert os.path.exists(config_path)\n\n            # File should contain expected content\n            with open(config_path, 'r') as f:\n                content = f.read()\n                assert \"namespace:\" in content\n                assert \"salt:\" in content\n</code></pre>"},{"location":"development/testing/#cli-tests","title":"CLI Tests","text":"<pre><code>from typer.testing import CliRunner\nfrom uuid_forge.cli import app\nimport json\n\nclass TestCLI:\n    \"\"\"Test command-line interface.\"\"\"\n\n    def setUp(self):\n        self.runner = CliRunner()\n\n    def test_generate_command(self):\n        \"\"\"Test basic UUID generation command.\"\"\"\n        result = self.runner.invoke(app, [\"generate\", \"test-input\"])\n\n        assert result.exit_code == 0\n        output = result.stdout.strip()\n        assert len(output) == 36\n        assert output.count('-') == 4\n\n    def test_generate_multiple_inputs(self):\n        \"\"\"Test generating UUIDs for multiple inputs.\"\"\"\n        result = self.runner.invoke(app, [\n            \"generate\", \"input1\", \"input2\", \"input3\"\n        ])\n\n        assert result.exit_code == 0\n        lines = result.stdout.strip().split('\\n')\n        assert len(lines) == 3\n\n        # All should be valid UUIDs\n        for line in lines:\n            assert len(line) == 36\n            assert line.count('-') == 4\n\n        # All should be different\n        assert len(set(lines)) == 3\n\n    def test_namespace_option(self):\n        \"\"\"Test namespace option.\"\"\"\n        result1 = self.runner.invoke(app, [\n            \"generate\", \"--namespace\", \"ns1\", \"test\"\n        ])\n        result2 = self.runner.invoke(app, [\n            \"generate\", \"--namespace\", \"ns2\", \"test\"\n        ])\n\n        assert result1.exit_code == 0\n        assert result2.exit_code == 0\n\n        uuid1 = result1.stdout.strip()\n        uuid2 = result2.stdout.strip()\n\n        # Different namespaces should produce different UUIDs\n        assert uuid1 != uuid2\n\n    def test_config_commands(self):\n        \"\"\"Test configuration management commands.\"\"\"\n        # Test config show\n        result = self.runner.invoke(app, [\"config\", \"show\"])\n        assert result.exit_code == 0\n\n        # Output should contain configuration information\n        assert \"namespace\" in result.stdout.lower()\n\n    def test_version_command(self):\n        \"\"\"Test version command.\"\"\"\n        result = self.runner.invoke(app, [\"--version\"])\n        assert result.exit_code == 0\n        assert \"uuid-forge\" in result.stdout.lower()\n\n    def test_help_commands(self):\n        \"\"\"Test help commands.\"\"\"\n        result = self.runner.invoke(app, [\"--help\"])\n        assert result.exit_code == 0\n        assert \"generate\" in result.stdout\n\n        result = self.runner.invoke(app, [\"generate\", \"--help\"])\n        assert result.exit_code == 0\n        assert \"namespace\" in result.stdout\n</code></pre>"},{"location":"development/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"development/testing/#database-integration","title":"Database Integration","text":"<pre><code>import pytest\nimport sqlite3\nfrom uuid_forge import UUIDGenerator\n\nclass TestDatabaseIntegration:\n    \"\"\"Test integration with database systems.\"\"\"\n\n    @pytest.fixture\n    def test_db(self):\n        \"\"\"Create test database.\"\"\"\n        conn = sqlite3.connect(\":memory:\")\n        cursor = conn.cursor()\n\n        cursor.execute(\"\"\"\n            CREATE TABLE users (\n                id TEXT PRIMARY KEY,\n                email TEXT UNIQUE NOT NULL,\n                name TEXT NOT NULL\n            )\n        \"\"\")\n\n        cursor.execute(\"\"\"\n            CREATE TABLE orders (\n                id TEXT PRIMARY KEY,\n                user_id TEXT NOT NULL,\n                total REAL NOT NULL,\n                FOREIGN KEY (user_id) REFERENCES users (id)\n            )\n        \"\"\")\n\n        conn.commit()\n        yield conn\n        conn.close()\n\n    def test_user_order_relationship(self, test_db):\n        \"\"\"Test maintaining relationships with deterministic UUIDs.\"\"\"\n        user_gen = UUIDGenerator(namespace=\"db-users\")\n        order_gen = UUIDGenerator(namespace=\"db-orders\")\n\n        cursor = test_db.cursor()\n\n        # Create user with deterministic UUID\n        user_email = \"dbtest@example.com\"\n        user_id = user_gen.generate(user_email)\n\n        cursor.execute(\n            \"INSERT INTO users (id, email, name) VALUES (?, ?, ?)\",\n            (user_id, user_email, \"Test User\")\n        )\n\n        # Create order with deterministic UUID\n        order_data = {\n            \"user_id\": user_id,\n            \"total\": 100.50,\n            \"items\": [\"item1\", \"item2\"]\n        }\n        order_id = order_gen.generate(order_data)\n\n        cursor.execute(\n            \"INSERT INTO orders (id, user_id, total) VALUES (?, ?, ?)\",\n            (order_id, user_id, 100.50)\n        )\n\n        test_db.commit()\n\n        # Verify relationship\n        cursor.execute(\"\"\"\n            SELECT u.email, o.total\n            FROM users u\n            JOIN orders o ON u.id = o.user_id\n            WHERE u.id = ?\n        \"\"\", (user_id,))\n\n        result = cursor.fetchone()\n        assert result is not None\n        assert result[0] == user_email\n        assert result[1] == 100.50\n\n        # Verify UUIDs are deterministic\n        user_id_2 = user_gen.generate(user_email)\n        order_id_2 = order_gen.generate(order_data)\n\n        assert user_id == user_id_2\n        assert order_id == order_id_2\n</code></pre>"},{"location":"development/testing/#api-integration","title":"API Integration","text":"<pre><code>import pytest\nimport requests_mock\nfrom uuid_forge import UUIDGenerator\n\nclass TestAPIIntegration:\n    \"\"\"Test integration with API services.\"\"\"\n\n    def test_rest_api_integration(self):\n        \"\"\"Test integration with REST API.\"\"\"\n        user_gen = UUIDGenerator(namespace=\"api-users\")\n\n        with requests_mock.Mocker() as m:\n            user_email = \"apitest@example.com\"\n            user_id = user_gen.generate(user_email)\n\n            # Mock API response\n            m.post(\n                \"http://api.example.com/users\",\n                json={\"id\": user_id, \"email\": user_email},\n                status_code=201\n            )\n\n            # Test API call\n            response = requests.post(\n                \"http://api.example.com/users\",\n                json={\"email\": user_email}\n            )\n\n            assert response.status_code == 201\n            data = response.json()\n            assert data[\"id\"] == user_id\n            assert data[\"email\"] == user_email\n</code></pre>"},{"location":"development/testing/#property-based-testing","title":"Property-Based Testing","text":""},{"location":"development/testing/#determinism-properties","title":"Determinism Properties","text":"<pre><code>from hypothesis import given, strategies as st\nfrom uuid_forge import UUIDGenerator\nimport uuid\n\nclass TestDeterminismProperties:\n    \"\"\"Test determinism properties using Hypothesis.\"\"\"\n\n    def setUp(self):\n        self.generator = UUIDGenerator(namespace=\"property-test\")\n\n    @given(st.text(min_size=1))\n    def test_determinism_property(self, input_text):\n        \"\"\"Property: Same input always produces same output.\"\"\"\n        uuid1 = self.generator.generate(input_text)\n        uuid2 = self.generator.generate(input_text)\n\n        assert uuid1 == uuid2\n\n    @given(st.text(min_size=1))\n    def test_valid_uuid_property(self, input_text):\n        \"\"\"Property: All outputs are valid UUIDs.\"\"\"\n        uuid_result = self.generator.generate(input_text)\n\n        # Should be parseable as UUID\n        parsed = uuid.UUID(uuid_result)\n        assert str(parsed) == uuid_result\n\n        # Should have correct length and format\n        assert len(uuid_result) == 36\n        assert uuid_result.count('-') == 4\n\n    @given(st.lists(st.text(min_size=1), min_size=2, unique=True))\n    def test_uniqueness_property(self, input_list):\n        \"\"\"Property: Different inputs produce different UUIDs.\"\"\"\n        uuids = [self.generator.generate(inp) for inp in input_list]\n\n        # All UUIDs should be unique\n        assert len(set(uuids)) == len(uuids)\n\n    @given(st.dictionaries(st.text(), st.text(), min_size=1))\n    def test_dict_determinism_property(self, input_dict):\n        \"\"\"Property: Dictionary inputs produce deterministic UUIDs.\"\"\"\n        uuid1 = self.generator.generate(input_dict)\n        uuid2 = self.generator.generate(input_dict)\n\n        assert uuid1 == uuid2\n</code></pre>"},{"location":"development/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"development/testing/#benchmark-tests","title":"Benchmark Tests","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\nimport time\n\nclass TestPerformance:\n    \"\"\"Test performance requirements.\"\"\"\n\n    def setUp(self):\n        self.generator = UUIDGenerator(namespace=\"perf-test\")\n\n    @pytest.mark.benchmark\n    def test_single_generation_speed(self, benchmark):\n        \"\"\"Benchmark single UUID generation.\"\"\"\n        result = benchmark(self.generator.generate, \"benchmark-input\")\n\n        assert len(result) == 36\n\n    def test_batch_generation_performance(self):\n        \"\"\"Test batch generation performance.\"\"\"\n        test_inputs = [f\"input-{i}\" for i in range(1000)]\n\n        start_time = time.time()\n        uuids = [self.generator.generate(inp) for inp in test_inputs]\n        end_time = time.time()\n\n        generation_time = end_time - start_time\n\n        # Should generate 1000 UUIDs in under 100ms\n        assert generation_time &lt; 0.1\n        assert len(uuids) == 1000\n        assert len(set(uuids)) == 1000  # All unique\n\n    def test_memory_efficiency(self):\n        \"\"\"Test memory usage during generation.\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        # Generate many UUIDs\n        large_inputs = [f\"input-{i}\" for i in range(10000)]\n        uuids = [self.generator.generate(inp) for inp in large_inputs]\n\n        peak_memory = process.memory_info().rss\n        memory_increase = peak_memory - initial_memory\n\n        # Memory increase should be reasonable\n        assert memory_increase &lt; 50 * 1024 * 1024  # Less than 50MB\n        assert len(uuids) == 10000\n\n    @pytest.mark.slow\n    def test_large_scale_performance(self):\n        \"\"\"Test performance with large-scale generation.\"\"\"\n        # Generate 100,000 UUIDs\n        start_time = time.time()\n\n        uuids = []\n        for i in range(100000):\n            uuid_result = self.generator.generate(f\"large-scale-{i}\")\n            uuids.append(uuid_result)\n\n        end_time = time.time()\n        total_time = end_time - start_time\n\n        # Should complete in reasonable time\n        assert total_time &lt; 10.0  # Less than 10 seconds\n        assert len(uuids) == 100000\n        assert len(set(uuids)) == 100000  # All unique\n</code></pre>"},{"location":"development/testing/#memory-profiling","title":"Memory Profiling","text":"<pre><code>import pytest\nfrom memory_profiler import profile\nfrom uuid_forge import UUIDGenerator\n\nclass TestMemoryUsage:\n    \"\"\"Test memory usage patterns.\"\"\"\n\n    @profile\n    def test_memory_profile_batch_generation(self):\n        \"\"\"Profile memory usage during batch generation.\"\"\"\n        generator = UUIDGenerator(namespace=\"memory-test\")\n\n        # Generate many UUIDs to observe memory pattern\n        uuids = []\n        for i in range(10000):\n            uuid_result = generator.generate(f\"memory-test-{i}\")\n            uuids.append(uuid_result)\n\n        return len(uuids)\n</code></pre>"},{"location":"development/testing/#test-configuration-and-fixtures","title":"Test Configuration and Fixtures","text":""},{"location":"development/testing/#shared-test-configuration","title":"Shared Test Configuration","text":"<pre><code># conftest.py\nimport pytest\nfrom uuid_forge import UUIDGenerator\nfrom uuid_forge.core import IDConfig\nimport tempfile\nimport os\n\n@pytest.fixture\ndef test_generator():\n    \"\"\"Provide a test UUID generator with consistent namespace.\"\"\"\n    config = IDConfig(namespace=\"test-namespace\")\n    return UUIDGenerator(config)\n\n@pytest.fixture\ndef temp_config_file():\n    \"\"\"Provide a temporary configuration file.\"\"\"\n    with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:\n        f.write(\"\"\"\nnamespace: test-config-namespace\nsalt: test-config-salt\n\"\"\")\n        config_path = f.name\n\n    yield config_path\n\n    # Cleanup\n    os.unlink(config_path)\n\n@pytest.fixture\ndef sample_test_data():\n    \"\"\"Provide sample test data.\"\"\"\n    return {\n        \"users\": [\n            {\"email\": \"user1@test.com\", \"name\": \"User One\"},\n            {\"email\": \"user2@test.com\", \"name\": \"User Two\"},\n            {\"email\": \"user3@test.com\", \"name\": \"User Three\"}\n        ],\n        \"orders\": [\n            {\"id\": \"order1\", \"user_email\": \"user1@test.com\", \"total\": 100.0},\n            {\"id\": \"order2\", \"user_email\": \"user2@test.com\", \"total\": 200.0}\n        ]\n    }\n\n@pytest.fixture(scope=\"session\")\ndef performance_generator():\n    \"\"\"Provide a generator for performance tests.\"\"\"\n    config = IDConfig(namespace=\"performance-test\")\n    return UUIDGenerator(config)\n\n# Test markers\npytest.mark.slow = pytest.mark.mark_slow(\"Slow running tests\")\npytest.mark.benchmark = pytest.mark.benchmark(\"Benchmark tests\")\npytest.mark.integration = pytest.mark.integration(\"Integration tests\")\n</code></pre>"},{"location":"development/testing/#test-execution","title":"Test Execution","text":""},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test categories\nuv run pytest -m \"not slow\"  # Skip slow tests\nuv run pytest -m benchmark   # Only benchmark tests\nuv run pytest -m integration # Only integration tests\n\n# Run with coverage\nuv run pytest --cov=uuid_forge --cov-report=html\n\n# Run specific test file\nuv run pytest tests/test_core.py\n\n# Run specific test\nuv run pytest tests/test_core.py::TestUUIDGenerator::test_deterministic_generation\n\n# Run tests matching pattern\nuv run pytest -k \"test_uuid\"\n\n# Run tests with verbose output\nuv run pytest -v\n\n# Run tests with detailed output\nuv run pytest -vv\n\n# Stop on first failure\nuv run pytest -x\n\n# Run failed tests from last run\nuv run pytest --lf\n</code></pre>"},{"location":"development/testing/#continuous-integration","title":"Continuous Integration","text":"<pre><code># .github/workflows/test.yml\nname: Test Suite\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, windows-latest, macos-latest]\n        python-version: [\"3.11\", \"3.12\"]\n\n    steps:\n      - uses: actions/checkout@v3\n\n      - name: Set up Python ${{ matrix.python-version }}\n        uses: actions/setup-python@v4\n        with:\n          python-version: ${{ matrix.python-version }}\n\n      - name: Install uv\n        run: |\n          pip install uv\n\n      - name: Install dependencies\n        run: |\n          uv sync --dev\n\n      - name: Run tests\n        run: |\n          uv run pytest --cov=uuid_forge --cov-report=xml\n\n      - name: Upload coverage\n        uses: codecov/codecov-action@v3\n        with:\n          file: ./coverage.xml\n</code></pre>"},{"location":"development/testing/#test-best-practices","title":"Test Best Practices","text":""},{"location":"development/testing/#writing-good-tests","title":"Writing Good Tests","text":"<ol> <li>Clear Names: Test names should describe what is being tested</li> <li>Single Responsibility: Each test should test one thing</li> <li>Deterministic: Tests should not depend on external factors</li> <li>Fast: Unit tests should run quickly</li> <li>Independent: Tests should not depend on each other</li> </ol>"},{"location":"development/testing/#test-organization_1","title":"Test Organization","text":"<ol> <li>Group Related Tests: Use classes to group related test methods</li> <li>Use Fixtures: Share setup code using pytest fixtures</li> <li>Parametrize Tests: Use <code>@pytest.mark.parametrize</code> for similar tests</li> <li>Mark Tests: Use pytest marks to categorize tests</li> </ol>"},{"location":"development/testing/#coverage-goals","title":"Coverage Goals","text":"<ul> <li>Unit Tests: Aim for &gt;95% code coverage</li> <li>Integration Tests: Cover critical workflows</li> <li>Property Tests: Validate mathematical properties</li> <li>Performance Tests: Ensure performance requirements</li> </ul>"},{"location":"development/testing/#debugging-tests","title":"Debugging Tests","text":""},{"location":"development/testing/#debug-failing-tests","title":"Debug Failing Tests","text":"<pre><code># Run with pdb debugger\nuv run pytest --pdb\n\n# Run specific failing test with verbose output\nuv run pytest tests/test_core.py::test_failing -vv\n\n# Show local variables in traceback\nuv run pytest --tb=long\n</code></pre>"},{"location":"development/testing/#test-output-analysis","title":"Test Output Analysis","text":"<pre><code># Show print statements\nuv run pytest -s\n\n# Show test duration\nuv run pytest --durations=10\n\n# Generate HTML coverage report\nuv run pytest --cov=uuid_forge --cov-report=html\nopen htmlcov/index.html\n</code></pre>"},{"location":"development/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Release Process - Preparing releases</li> <li>Contributing - Contributing guidelines</li> <li>Best Practices - Code best practices</li> </ul>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>UUID-Forge provides flexible configuration options to suit different use cases and environments.</p>"},{"location":"getting-started/configuration/#configuration-file","title":"Configuration File","text":"<p>UUID-Forge looks for configuration in the following locations (in order of precedence):</p> <ol> <li><code>uuid_forge.yaml</code> in the current directory</li> <li><code>~/.uuid_forge.yaml</code> in the user's home directory</li> <li><code>/etc/uuid_forge.yaml</code> system-wide configuration</li> </ol>"},{"location":"getting-started/configuration/#configuration-format","title":"Configuration Format","text":"<pre><code># uuid_forge.yaml\nnamespace: \"my-application\"\nversion: 1\nformat: \"hex\"\ncase: \"lower\"\nseparator: \"-\"\n\n# Custom namespaces for different contexts\nnamespaces:\n  users: \"550e8400-e29b-41d4-a716-446655440000\"\n  orders: \"550e8400-e29b-41d4-a716-446655440001\"\n  products: \"550e8400-e29b-41d4-a716-446655440002\"\n</code></pre>"},{"location":"getting-started/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"getting-started/configuration/#core-settings","title":"Core Settings","text":"<ul> <li><code>namespace</code>: Default namespace UUID (string or UUID)</li> <li><code>version</code>: UUID version to generate (1, 3, 4, or 5)</li> <li><code>format</code>: Output format (<code>hex</code>, <code>urn</code>, <code>bytes</code>)</li> <li><code>case</code>: Case for hex output (<code>upper</code>, <code>lower</code>)</li> <li><code>separator</code>: Separator character for hex format</li> </ul>"},{"location":"getting-started/configuration/#advanced-settings","title":"Advanced Settings","text":"<ul> <li><code>seed</code>: Random seed for reproducible generation</li> <li><code>clock_seq</code>: Clock sequence for version 1 UUIDs</li> <li><code>node</code>: Node ID for version 1 UUIDs</li> </ul>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":"<p>Configuration can also be set via environment variables:</p> <pre><code>export UUID_FORGE_NAMESPACE=\"my-app\"\nexport UUID_FORGE_VERSION=5\nexport UUID_FORGE_FORMAT=\"hex\"\n</code></pre>"},{"location":"getting-started/configuration/#programmatic-configuration","title":"Programmatic Configuration","text":"<pre><code>from uuid_forge import UUIDGenerator, IDConfig\n\n# Create configuration\nconfig = IDConfig(\n    namespace=\"my-application\",\n    version=5,\n    format=\"hex\",\n    case=\"lower\"\n)\n\n# Initialize with configuration\nforge = UUIDGenerator(config)\n\n# Or use default configuration\nforge = UUIDGenerator()\n</code></pre>"},{"location":"getting-started/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>UUID-Forge validates all configuration values and provides helpful error messages for invalid settings.</p>"},{"location":"getting-started/configuration/#next-steps","title":"Next Steps","text":"<ul> <li>Core Concepts - Understand UUID generation principles</li> <li>Basic Usage - Start generating UUIDs</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>UUID-Forge can be installed using various package managers. Choose the method that best fits your workflow.</p>"},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>pip, uv, or poetry (depending on your preferred installation method)</li> </ul>"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#using-uv-recommended","title":"Using uv (Recommended)","text":"<pre><code>uv add uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#using-pip","title":"Using pip","text":"<pre><code>pip install uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#using-poetry","title":"Using poetry","text":"<pre><code>poetry add uuid-forge\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you want to contribute to UUID-Forge or install from source:</p> <pre><code># Clone the repository\ngit clone https://github.com/yourusername/uuid-forge.git\ncd uuid-forge\n\n# Install in development mode\nuv sync --dev\n</code></pre>"},{"location":"getting-started/installation/#verification","title":"Verification","text":"<p>Verify your installation by running:</p> <pre><code>python -c \"import uuid_forge; print(uuid_forge.__version__)\"\n</code></pre> <p>Or use the CLI:</p> <pre><code>uuid-forge --version\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Get up and running in 5 minutes</li> <li>Configuration - Learn about configuration options</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with UUID-Forge in under 5 minutes.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of UUIDs</li> <li>A text editor or IDE</li> </ul>"},{"location":"getting-started/quickstart/#step-1-installation","title":"Step 1: Installation","text":"<p>Install UUID-Forge using your preferred package manager:</p> uv (recommended)pippoetry <pre><code>uv add uuid-forge\n</code></pre> <pre><code>pip install uuid-forge\n</code></pre> <pre><code>poetry add uuid-forge\n</code></pre>"},{"location":"getting-started/quickstart/#step-2-generate-a-salt","title":"Step 2: Generate a Salt","text":"<p>Security first! Generate a cryptographic salt for production use:</p> <pre><code>uuid-forge new-salt\n</code></pre> <p>This will output something like:</p> <pre><code>xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\n</code></pre> <p>Keep This Secret!</p> <p>Store this salt securely and never commit it to version control.</p>"},{"location":"getting-started/quickstart/#set-environment-variable","title":"Set Environment Variable","text":"<p>Add the salt to your environment:</p> <pre><code>export UUID_FORGE_SALT='xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB'\n</code></pre> <p>Or create a <code>.env</code> file:</p> <pre><code>uuid-forge init\n</code></pre> <p>This creates a <code>.env</code> file with a generated salt and usage instructions.</p>"},{"location":"getting-started/quickstart/#step-3-your-first-uuid","title":"Step 3: Your First UUID","text":"<p>Create a Python file <code>example.py</code>:</p> <pre><code>from uuid_forge import generate_uuid_only, load_config_from_env\n\n# Load configuration from environment\nconfig = load_config_from_env()\n\n# Generate a deterministic UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(f\"Invoice UUID: {invoice_uuid}\")\n</code></pre> <p>Run it:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"getting-started/quickstart/#step-4-verify-idempotency","title":"Step 4: Verify Idempotency","text":"<p>The magic of UUID-Forge is that the same inputs always produce the same UUID. Add this to your script:</p> <pre><code># Regenerate the UUID from the same business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\n# They're identical!\nassert invoice_uuid == regenerated_uuid\nprint(\"\u2713 UUIDs are identical!\")\n</code></pre> <p>Run again:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n\u2713 UUIDs are identical!\n</code></pre>"},{"location":"getting-started/quickstart/#step-5-use-across-systems","title":"Step 5: Use Across Systems","text":"<p>Now use this UUID consistently across all your storage systems:</p> <pre><code>import psycopg2\nimport boto3\nimport redis\n\n# Database - Primary key\ndb = psycopg2.connect(\"...\")\ncursor = db.cursor()\ncursor.execute(\n    \"INSERT INTO invoices (id, region, number, amount) VALUES (%s, %s, %s, %s)\",\n    (invoice_uuid, \"EUR\", 12345, 1500.50)\n)\n\n# S3 - Object storage\ns3 = boto3.client('s3')\ns3.put_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{invoice_uuid}.pdf',\n    Body=pdf_data\n)\n\n# Redis - Cache\nr = redis.Redis()\nr.setex(\n    f'invoice:{invoice_uuid}',\n    3600,  # 1 hour TTL\n    json.dumps({'region': 'EUR', 'number': 12345})\n)\n\nprint(f\"\u2713 Stored invoice {invoice_uuid} in Postgres, S3, and Redis\")\n</code></pre>"},{"location":"getting-started/quickstart/#step-6-retrieve-without-lookups","title":"Step 6: Retrieve Without Lookups","text":"<p>The real power: retrieve from any system without database lookups!</p> <pre><code># User requests invoice by business data\nrequested_region = \"EUR\"\nrequested_number = 12345\n\n# Regenerate UUID from business data (no database query!)\nlookup_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=requested_region,\n    invoice_number=requested_number\n)\n\n# Now access any storage system directly\npdf_data = s3.get_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{lookup_uuid}.pdf'\n)\n\ncached_data = r.get(f'invoice:{lookup_uuid}')\n\ndb_record = cursor.execute(\n    \"SELECT * FROM invoices WHERE id = %s\",\n    (lookup_uuid,)\n).fetchone()\n\nprint(\"\u2713 Retrieved from all systems without any UUID lookups!\")\n</code></pre>"},{"location":"getting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"getting-started/quickstart/#pattern-1-with-prefixes-for-human-readability","title":"Pattern 1: With Prefixes for Human Readability","text":"<pre><code>from uuid_forge import generate_uuid_with_prefix\n\n# Generate with prefix\nprefixed_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(prefixed_id)\n# Output: INV-EUR-550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"getting-started/quickstart/#pattern-2-using-the-oo-api","title":"Pattern 2: Using the OO API","text":"<pre><code>from uuid_forge import UUIDGenerator\n\n# Create generator once\ngenerator = UUIDGenerator(config=config)\n\n# Generate multiple UUIDs\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\nshipment_uuid = generator.generate(\"shipment\", order_id=str(order_uuid))\n</code></pre>"},{"location":"getting-started/quickstart/#pattern-3-different-entity-types","title":"Pattern 3: Different Entity Types","text":"<pre><code># Each entity type has its own UUID space\nuser_uuid = generate_uuid_only(\"user\", config=config, email=\"alice@example.com\")\norder_uuid = generate_uuid_only(\"order\", config=config, user_id=str(user_uuid), number=123)\ninvoice_uuid = generate_uuid_only(\"invoice\", config=config, order_id=str(order_uuid))\n\n# Same business data, different entity types = different UUIDs\nassert user_uuid != order_uuid != invoice_uuid\n</code></pre>"},{"location":"getting-started/quickstart/#cli-usage","title":"CLI Usage","text":"<p>UUID-Forge includes a powerful CLI for quick UUID generation:</p> <pre><code># Generate UUID\nuuid-forge generate invoice --attr region=EUR --attr number=12345\n\n# With prefix\nuuid-forge generate invoice --prefix INV-EUR --attr region=EUR --attr number=12345\n\n# Extract UUID from prefixed ID\nuuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Validate configuration\nuuid-forge validate\n\n# Show current configuration\nuuid-forge info\n</code></pre>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics, explore:</p> <ul> <li>Core Concepts - Understand how it works</li> <li>Best Practices - Production guidelines</li> <li>Use Cases - Real-world examples</li> <li>API Reference - Complete documentation</li> </ul>"},{"location":"getting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/quickstart/#issue-no-salt-configured-warning","title":"Issue: \"No salt configured\" warning","text":"<p>Solution: Set the <code>UUID_FORGE_SALT</code> environment variable or use <code>uuid-forge init</code> to create a config file.</p>"},{"location":"getting-started/quickstart/#issue-different-uuids-on-different-machines","title":"Issue: Different UUIDs on different machines","text":"<p>Solution: Ensure all machines use the same salt and namespace configuration.</p>"},{"location":"getting-started/quickstart/#issue-uuids-change-after-restart","title":"Issue: UUIDs change after restart","text":"<p>Solution: Verify environment variables are set correctly and persistently.</p>"},{"location":"getting-started/quickstart/#get-help","title":"Get Help","text":"<ul> <li>GitHub Issues</li> <li>GitHub Discussions</li> <li>API Reference</li> </ul>"},{"location":"guide/advanced-usage/","title":"Advanced Usage","text":"<p>Explore the advanced features and customization options of UUID-Forge for complex use cases.</p>"},{"location":"guide/advanced-usage/#custom-namespaces-and-hierarchies","title":"Custom Namespaces and Hierarchies","text":""},{"location":"guide/advanced-usage/#creating-namespace-hierarchies","title":"Creating Namespace Hierarchies","text":"<pre><code>from uuid_forge import UUIDGenerator\nimport uuid\n\n# Create a root namespace for your organization\norg_namespace = Namespace(\"mycompany.com\")\n\n# Create service-specific namespaces\nuser_service_ns = uuid.uuid5(org_namespace, \"user-service\")\norder_service_ns = uuid.uuid5(org_namespace, \"order-service\")\n\n# Use hierarchical namespaces\nuser_forge = UUIDGenerator(namespace=user_service_ns)\norder_forge = UUIDGenerator(namespace=order_service_ns)\n</code></pre>"},{"location":"guide/advanced-usage/#namespace-factories","title":"Namespace Factories","text":"<pre><code>class NamespaceFactory:\n    def __init__(self, root_namespace):\n        self.root = root_namespace\n        self._namespaces = {}\n\n    def get_namespace(self, service_name):\n        if service_name not in self._namespaces:\n            self._namespaces[service_name] = uuid.uuid5(\n                self.root, service_name\n            )\n        return self._namespaces[service_name]\n\n# Usage\nfactory = NamespaceFactory(org_namespace)\nuser_ns = factory.get_namespace(\"users\")\nproduct_ns = factory.get_namespace(\"products\")\n</code></pre>"},{"location":"guide/advanced-usage/#complex-data-processing","title":"Complex Data Processing","text":""},{"location":"guide/advanced-usage/#nested-dictionary-handling","title":"Nested Dictionary Handling","text":"<pre><code>complex_data = {\n    \"user\": {\n        \"id\": 12345,\n        \"profile\": {\n            \"email\": \"john@example.com\",\n            \"preferences\": {\n                \"theme\": \"dark\",\n                \"notifications\": True\n            }\n        }\n    },\n    \"metadata\": {\n        \"created_at\": \"2024-01-15T10:30:00Z\",\n        \"version\": \"2.1\"\n    }\n}\n\n# UUID-Forge handles nested structures automatically\nuuid_result = forge.generate(complex_data)\n</code></pre>"},{"location":"guide/advanced-usage/#custom-serialization","title":"Custom Serialization","text":"<pre><code>import json\nfrom datetime import datetime\n\nclass CustomEncoder(json.JSONEncoder):\n    def default(self, obj):\n        if isinstance(obj, datetime):\n            return obj.isoformat()\n        return super().default(obj)\n\n# Use custom serialization for consistent UUIDs\nforge = UUIDGenerator(json_encoder=CustomEncoder)\n</code></pre>"},{"location":"guide/advanced-usage/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/advanced-usage/#batch-processing","title":"Batch Processing","text":"<pre><code># Efficient batch processing\ndef process_batch(items, namespace=\"default\"):\n    forge = UUIDGenerator(namespace=namespace)\n    return [(item, forge.generate(item)) for item in items]\n\n# Process large datasets\nlarge_dataset = [\"item_{}\".format(i) for i in range(10000)]\nresults = process_batch(large_dataset)\n</code></pre>"},{"location":"guide/advanced-usage/#caching-strategies","title":"Caching Strategies","text":"<pre><code>from functools import lru_cache\n\nclass CachedUUIDGenerator:\n    def __init__(self, namespace=None):\n        self.forge = UUIDGenerator(namespace=namespace)\n\n    @lru_cache(maxsize=1000)\n    def generate_cached(self, input_data):\n        return self.forge.generate(input_data)\n\n# Use cached version for frequently accessed items\ncached_forge = CachedUUIDGenerator()\n</code></pre>"},{"location":"guide/advanced-usage/#multi-version-support","title":"Multi-Version Support","text":""},{"location":"guide/advanced-usage/#version-specific-generation","title":"Version-Specific Generation","text":"<pre><code># Different UUID versions for different use cases\nv3_forge = UUIDGenerator(version=3)  # MD5-based\nv4_forge = UUIDGenerator(version=4)  # Random\nv5_forge = UUIDGenerator(version=5)  # SHA-1-based (recommended)\n\n# Same input, different versions\ninput_data = \"test@example.com\"\nuuid_v3 = v3_forge.generate(input_data)\nuuid_v4 = v4_forge.generate(input_data)  # Non-deterministic\nuuid_v5 = v5_forge.generate(input_data)\n</code></pre>"},{"location":"guide/advanced-usage/#version-migration","title":"Version Migration","text":"<pre><code>def migrate_uuids(old_items, old_version=3, new_version=5):\n    \"\"\"Migrate UUIDs from one version to another\"\"\"\n    old_forge = UUIDGenerator(version=old_version)\n    new_forge = UUIDGenerator(version=new_version)\n\n    migrations = {}\n    for item in old_items:\n        old_uuid = old_forge.generate(item)\n        new_uuid = new_forge.generate(item)\n        migrations[old_uuid] = new_uuid\n\n    return migrations\n</code></pre>"},{"location":"guide/advanced-usage/#custom-input-processors","title":"Custom Input Processors","text":""},{"location":"guide/advanced-usage/#custom-object-handling","title":"Custom Object Handling","text":"<pre><code>class CustomProcessor:\n    @staticmethod\n    def process_object(obj):\n        if hasattr(obj, 'to_uuid_string'):\n            return obj.to_uuid_string()\n        elif hasattr(obj, '__dict__'):\n            return json.dumps(obj.__dict__, sort_keys=True)\n        else:\n            return str(obj)\n\n# Register custom processor\nforge = UUIDGenerator(object_processor=CustomProcessor.process_object)\n</code></pre>"},{"location":"guide/advanced-usage/#integration-patterns","title":"Integration Patterns","text":""},{"location":"guide/advanced-usage/#database-integration","title":"Database Integration","text":"<pre><code>import sqlalchemy as sa\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.dialects.postgresql import UUID\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n\n    id = sa.Column(UUID(as_uuid=True), primary_key=True)\n    email = sa.Column(sa.String, unique=True, nullable=False)\n\n    def __init__(self, email):\n        self.email = email\n        # Generate deterministic UUID from email\n        forge = UUIDGenerator(namespace=\"users\")\n        self.id = uuid.UUID(forge.generate(email))\n\n# Usage\nuser = User(\"john@example.com\")\n# user.id is now a deterministic UUID\n</code></pre>"},{"location":"guide/advanced-usage/#message-queue-integration","title":"Message Queue Integration","text":"<pre><code>import json\nfrom uuid_forge import UUIDGenerator\n\nclass MessageHandler:\n    def __init__(self):\n        self.forge = UUIDGenerator(namespace=\"messages\")\n\n    def create_message(self, data):\n        # Create deterministic message ID\n        message_id = self.forge.generate(data)\n\n        return {\n            \"id\": message_id,\n            \"data\": data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n\n    def is_duplicate(self, message_data, processed_ids):\n        message_id = self.forge.generate(message_data)\n        return message_id in processed_ids\n</code></pre>"},{"location":"guide/advanced-usage/#configuration-management","title":"Configuration Management","text":""},{"location":"guide/advanced-usage/#environment-based-configuration","title":"Environment-Based Configuration","text":"<pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig\n\ndef create_forge_from_env():\n    config = IDConfig(\n        namespace=os.getenv('UUID_NAMESPACE', 'default'),\n        version=int(os.getenv('UUID_VERSION', '5')),\n        format=os.getenv('UUID_FORMAT', 'hex'),\n        case=os.getenv('UUID_CASE', 'lower')\n    )\n    return UUIDGenerator(config)\n\n# Use environment-specific configuration\nforge = create_forge_from_env()\n</code></pre>"},{"location":"guide/advanced-usage/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Reference - Master the command-line interface</li> <li>Best Practices - Learn optimization techniques</li> <li>Use Cases - See real-world applications</li> </ul>"},{"location":"guide/basic-usage/","title":"Basic Usage","text":"<p>This guide covers the fundamental ways to use UUID-Forge in your applications.</p>"},{"location":"guide/basic-usage/#quick-start","title":"Quick Start","text":"<pre><code>from uuid_forge import UUIDGenerator\n\n# Create a forge instance\nforge = UUIDGenerator()\n\n# Generate a UUID from a string\nuser_id = forge.generate(\"john.doe@example.com\")\nprint(user_id)  # 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/basic-usage/#creating-uuids-from-different-input-types","title":"Creating UUIDs from Different Input Types","text":""},{"location":"guide/basic-usage/#from-strings","title":"From Strings","text":"<pre><code># Simple string\nuuid1 = forge.generate(\"user123\")\n\n# Email addresses\nuuid2 = forge.generate(\"user@example.com\")\n\n# Complex identifiers\nuuid3 = forge.generate(\"order:2024:Q1:12345\")\n</code></pre>"},{"location":"guide/basic-usage/#from-dictionaries","title":"From Dictionaries","text":"<pre><code># User data\nuser_data = {\n    \"email\": \"john@example.com\",\n    \"username\": \"john_doe\",\n    \"department\": \"engineering\"\n}\nuser_uuid = forge.generate(user_data)\n\n# Order data\norder_data = {\n    \"customer_id\": \"12345\",\n    \"product_id\": \"67890\",\n    \"timestamp\": \"2024-01-15T10:30:00Z\"\n}\norder_uuid = forge.generate(order_data)\n</code></pre>"},{"location":"guide/basic-usage/#from-objects","title":"From Objects","text":"<pre><code>class User:\n    def __init__(self, email, name):\n        self.email = email\n        self.name = name\n\n    def __str__(self):\n        return f\"{self.email}:{self.name}\"\n\nuser = User(\"john@example.com\", \"John Doe\")\nuser_uuid = forge.generate(user)\n</code></pre>"},{"location":"guide/basic-usage/#different-output-formats","title":"Different Output Formats","text":"<pre><code># Default hex format with dashes\nuuid_hex = forge.generate(\"test\", format=\"hex\")\n# Output: 550e8400-e29b-41d4-a716-446655440000\n\n# URN format\nuuid_urn = forge.generate(\"test\", format=\"urn\")\n# Output: urn:uuid:550e8400-e29b-41d4-a716-446655440000\n\n# Raw bytes\nuuid_bytes = forge.generate(\"test\", format=\"bytes\")\n# Output: b'U\\x0e\\x84\\x00\\xe2\\x9b...'\n\n# Hex without dashes\nuuid_plain = forge.generate(\"test\", format=\"hex\", separator=\"\")\n# Output: 550e8400e29b41d4a716446655440000\n</code></pre>"},{"location":"guide/basic-usage/#using-different-namespaces","title":"Using Different Namespaces","text":"<pre><code># Different namespaces produce different UUIDs for same input\nforge_users = UUIDGenerator(namespace=\"users\")\nforge_orders = UUIDGenerator(namespace=\"orders\")\n\nuser_uuid = forge_users.generate(\"john@example.com\")\norder_uuid = forge_orders.generate(\"john@example.com\")\n\nprint(user_uuid != order_uuid)  # True\n</code></pre>"},{"location":"guide/basic-usage/#batch-generation","title":"Batch Generation","text":"<pre><code># Generate multiple UUIDs efficiently\nemails = [\n    \"user1@example.com\",\n    \"user2@example.com\",\n    \"user3@example.com\"\n]\n\nuuids = [forge.generate(email) for email in emails]\n\n# Or with custom namespace per UUID\nnamespaces = [\"users\", \"admins\", \"guests\"]\nuuids = [\n    UUIDGenerator(namespace=ns).generate(email)\n    for ns, email in zip(namespaces, emails)\n]\n</code></pre>"},{"location":"guide/basic-usage/#working-with-existing-uuids","title":"Working with Existing UUIDs","text":"<pre><code>import uuid\n\n# Convert existing UUID to different format\nexisting_uuid = uuid.uuid4()\nuuid_string = str(existing_uuid)\n\n# Regenerate deterministically\nregenerated = forge.generate(uuid_string)\n</code></pre>"},{"location":"guide/basic-usage/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    # This will work\n    valid_uuid = forge.generate(\"valid_input\")\n\n    # This might raise an exception\n    invalid_uuid = forge.generate(None)\n\nexcept ValueError as e:\n    print(f\"Invalid input: {e}\")\nexcept Exception as e:\n    print(f\"Unexpected error: {e}\")\n</code></pre>"},{"location":"guide/basic-usage/#validation","title":"Validation","text":"<pre><code>import uuid\n\n# Validate generated UUID\ngenerated = forge.generate(\"test\")\n\n# Check if it's a valid UUID\ntry:\n    parsed = uuid.UUID(generated)\n    print(f\"Valid UUID: {parsed}\")\nexcept ValueError:\n    print(\"Invalid UUID generated\")\n</code></pre>"},{"location":"guide/basic-usage/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Usage - Explore advanced features and customization</li> <li>CLI Reference - Learn about command-line usage</li> <li>Best Practices - Optimize your UUID generation patterns</li> </ul>"},{"location":"guide/best-practices/","title":"Best Practices","text":"<p>Learn the optimal patterns and practices for using UUID-Forge effectively in production systems.</p>"},{"location":"guide/best-practices/#choosing-the-right-uuid-version","title":"Choosing the Right UUID Version","text":""},{"location":"guide/best-practices/#version-5-recommended","title":"Version 5 (Recommended)","text":"<p>Use UUID version 5 for most deterministic use cases:</p> <pre><code># Recommended for production\nforge = UUIDGenerator(version=5)\n</code></pre> <p>Benefits:</p> <ul> <li>Strong SHA-1 hashing</li> <li>Excellent collision resistance</li> <li>Industry standard for deterministic UUIDs</li> </ul>"},{"location":"guide/best-practices/#version-3-legacy-support","title":"Version 3 (Legacy Support)","text":"<p>Only use version 3 when maintaining compatibility:</p> <pre><code># Only for legacy compatibility\nforge = UUIDGenerator(version=3)\n</code></pre> <p>Limitations:</p> <ul> <li>Uses MD5 (considered cryptographically weak)</li> <li>Higher collision probability</li> </ul>"},{"location":"guide/best-practices/#version-4-random","title":"Version 4 (Random)","text":"<p>Use for non-deterministic requirements:</p> <pre><code># For truly random UUIDs\nforge = UUIDGenerator(version=4)\n</code></pre>"},{"location":"guide/best-practices/#namespace-design","title":"Namespace Design","text":""},{"location":"guide/best-practices/#hierarchical-namespaces","title":"Hierarchical Namespaces","text":"<p>Design namespaces hierarchically for better organization:</p> <pre><code>import uuid\n\n# Root namespace for your organization\nROOT_NS = Namespace(\"mycompany.com\")\n\n# Service-specific namespaces\nUSER_SERVICE_NS = uuid.uuid5(ROOT_NS, \"user-service\")\nORDER_SERVICE_NS = uuid.uuid5(ROOT_NS, \"order-service\")\nPRODUCT_SERVICE_NS = uuid.uuid5(ROOT_NS, \"product-service\")\n\n# Environment-specific namespaces\nDEV_USER_NS = uuid.uuid5(USER_SERVICE_NS, \"development\")\nPROD_USER_NS = uuid.uuid5(USER_SERVICE_NS, \"production\")\n</code></pre>"},{"location":"guide/best-practices/#namespace-naming-conventions","title":"Namespace Naming Conventions","text":"<p>Follow consistent naming patterns:</p> <pre><code># Good: Clear, hierarchical naming\nnamespaces = {\n    \"users.profiles\": uuid.uuid5(ROOT_NS, \"users.profiles\"),\n    \"users.auth\": uuid.uuid5(ROOT_NS, \"users.auth\"),\n    \"orders.processing\": uuid.uuid5(ROOT_NS, \"orders.processing\"),\n    \"orders.fulfillment\": uuid.uuid5(ROOT_NS, \"orders.fulfillment\")\n}\n\n# Avoid: Ambiguous or flat naming\n# \"ns1\", \"namespace_a\", \"temp_ns\"\n</code></pre>"},{"location":"guide/best-practices/#input-data-preparation","title":"Input Data Preparation","text":""},{"location":"guide/best-practices/#canonical-representation","title":"Canonical Representation","text":"<p>Ensure consistent input representation:</p> <pre><code>def prepare_user_input(user_data):\n    \"\"\"Prepare user data for consistent UUID generation\"\"\"\n    return {\n        \"email\": user_data[\"email\"].lower().strip(),\n        \"username\": user_data[\"username\"].lower().strip(),\n        \"department\": user_data.get(\"department\", \"\").lower().strip()\n    }\n\n# Use prepared data\nuser_data = prepare_user_input(raw_user_data)\nuser_uuid = forge.generate(user_data)\n</code></pre>"},{"location":"guide/best-practices/#handle-optional-fields","title":"Handle Optional Fields","text":"<p>Be consistent with optional and null values:</p> <pre><code>def normalize_data(data):\n    \"\"\"Normalize data structure for UUID generation\"\"\"\n    normalized = {}\n    for key, value in data.items():\n        if value is None:\n            normalized[key] = \"\"  # Consistent null representation\n        elif isinstance(value, str):\n            normalized[key] = value.strip().lower()\n        else:\n            normalized[key] = value\n    return normalized\n</code></pre>"},{"location":"guide/best-practices/#performance-optimization","title":"Performance Optimization","text":""},{"location":"guide/best-practices/#reuse-forge-instances","title":"Reuse Forge Instances","text":"<p>Create forge instances once and reuse them:</p> <pre><code># Good: Reuse instances\nclass UserService:\n    def __init__(self):\n        self.user_forge = UUIDGenerator(namespace=\"users\")\n\n    def create_user_uuid(self, user_data):\n        return self.user_forge.generate(user_data)\n\n# Avoid: Creating new instances repeatedly\ndef create_user_uuid(user_data):\n    forge = UUIDGenerator(namespace=\"users\")  # Inefficient\n    return forge.generate(user_data)\n</code></pre>"},{"location":"guide/best-practices/#batch-processing","title":"Batch Processing","text":"<p>Process multiple items efficiently:</p> <pre><code>def process_users_batch(users):\n    \"\"\"Process multiple users efficiently\"\"\"\n    forge = UUIDGenerator(namespace=\"users\")\n    return [\n        {\n            \"uuid\": forge.generate(user),\n            \"data\": user\n        }\n        for user in users\n    ]\n</code></pre>"},{"location":"guide/best-practices/#caching-strategies","title":"Caching Strategies","text":"<p>Implement appropriate caching:</p> <pre><code>from functools import lru_cache\n\nclass UUIDService:\n    def __init__(self):\n        self.forge = UUIDGenerator(namespace=\"default\")\n\n    @lru_cache(maxsize=1000)\n    def get_cached_uuid(self, input_key):\n        \"\"\"Cache frequently accessed UUIDs\"\"\"\n        return self.forge.generate(input_key)\n\n    def clear_cache(self):\n        \"\"\"Clear cache when needed\"\"\"\n        self.get_cached_uuid.cache_clear()\n</code></pre>"},{"location":"guide/best-practices/#error-handling","title":"Error Handling","text":""},{"location":"guide/best-practices/#robust-input-validation","title":"Robust Input Validation","text":"<p>Validate inputs before UUID generation:</p> <pre><code>def safe_generate_uuid(forge, input_data):\n    \"\"\"Safely generate UUID with proper error handling\"\"\"\n    try:\n        if input_data is None:\n            raise ValueError(\"Input data cannot be None\")\n\n        if isinstance(input_data, str) and not input_data.strip():\n            raise ValueError(\"Input string cannot be empty\")\n\n        return forge.generate(input_data)\n\n    except Exception as e:\n        logger.error(f\"UUID generation failed: {e}\")\n        raise\n</code></pre>"},{"location":"guide/best-practices/#graceful-degradation","title":"Graceful Degradation","text":"<p>Handle failures gracefully:</p> <pre><code>def generate_with_fallback(primary_forge, fallback_forge, input_data):\n    \"\"\"Generate UUID with fallback strategy\"\"\"\n    try:\n        return primary_forge.generate(input_data)\n    except Exception as e:\n        logger.warning(f\"Primary forge failed: {e}, using fallback\")\n        return fallback_forge.generate(input_data)\n</code></pre>"},{"location":"guide/best-practices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"guide/best-practices/#deterministic-testing","title":"Deterministic Testing","text":"<p>Leverage determinism for better tests:</p> <pre><code>def test_user_uuid_generation():\n    \"\"\"Test that UUID generation is deterministic\"\"\"\n    forge = UUIDGenerator(namespace=\"test-users\")\n\n    user_data = {\"email\": \"test@example.com\", \"name\": \"Test User\"}\n\n    # Generate UUID multiple times\n    uuid1 = forge.generate(user_data)\n    uuid2 = forge.generate(user_data)\n\n    # Should be identical\n    assert uuid1 == uuid2\n\n    # Should be valid UUID\n    assert uuid.UUID(uuid1)\n</code></pre>"},{"location":"guide/best-practices/#test-data-management","title":"Test Data Management","text":"<p>Use consistent test data:</p> <pre><code># Test fixtures\nTEST_USERS = [\n    {\"email\": \"user1@test.com\", \"name\": \"User One\"},\n    {\"email\": \"user2@test.com\", \"name\": \"User Two\"},\n    {\"email\": \"user3@test.com\", \"name\": \"User Three\"}\n]\n\nTEST_NAMESPACE = \"test-environment\"\n\ndef test_batch_uuid_generation():\n    \"\"\"Test batch UUID generation\"\"\"\n    forge = UUIDGenerator(namespace=TEST_NAMESPACE)\n\n    uuids = [forge.generate(user) for user in TEST_USERS]\n\n    # All UUIDs should be unique\n    assert len(set(uuids)) == len(uuids)\n\n    # All should be valid UUIDs\n    for uuid_str in uuids:\n        assert uuid.UUID(uuid_str)\n</code></pre>"},{"location":"guide/best-practices/#production-deployment","title":"Production Deployment","text":""},{"location":"guide/best-practices/#configuration-management","title":"Configuration Management","text":"<p>Use environment-specific configuration:</p> <pre><code>import os\nfrom uuid_forge import UUIDGenerator, IDConfig\n\ndef create_production_forge():\n    \"\"\"Create forge with production configuration\"\"\"\n    config = IDConfig(\n        namespace=os.environ[\"UUID_NAMESPACE\"],\n        version=int(os.environ.get(\"UUID_VERSION\", \"5\")),\n        format=os.environ.get(\"UUID_FORMAT\", \"hex\")\n    )\n    return UUIDGenerator(config)\n</code></pre>"},{"location":"guide/best-practices/#monitoring-and-logging","title":"Monitoring and Logging","text":"<p>Monitor UUID generation in production:</p> <pre><code>import logging\nimport time\n\nlogger = logging.getLogger(__name__)\n\nclass MonitoredUUIDGenerator:\n    def __init__(self, namespace=None):\n        self.forge = UUIDGenerator(namespace=namespace)\n        self.generation_count = 0\n\n    def generate(self, input_data):\n        start_time = time.time()\n\n        try:\n            result = self.forge.generate(input_data)\n            self.generation_count += 1\n\n            duration = time.time() - start_time\n            logger.info(f\"UUID generated in {duration:.3f}s\")\n\n            return result\n\n        except Exception as e:\n            logger.error(f\"UUID generation failed: {e}\")\n            raise\n</code></pre>"},{"location":"guide/best-practices/#security-considerations","title":"Security Considerations","text":""},{"location":"guide/best-practices/#sensitive-data-handling","title":"Sensitive Data Handling","text":"<p>Be careful with sensitive data in UUIDs:</p> <pre><code>def generate_user_uuid_safe(user_data):\n    \"\"\"Generate UUID without exposing sensitive data\"\"\"\n    # Use only non-sensitive identifiers\n    safe_data = {\n        \"user_id\": user_data[\"id\"],\n        \"account_type\": user_data[\"account_type\"],\n        \"created_date\": user_data[\"created_at\"].date().isoformat()\n    }\n    # Don't include: passwords, PII, sensitive fields\n\n    return forge.generate(safe_data)\n</code></pre>"},{"location":"guide/best-practices/#namespace-isolation","title":"Namespace Isolation","text":"<p>Ensure proper namespace isolation:</p> <pre><code># Separate namespaces for different security contexts\nPUBLIC_NS = uuid.uuid5(ROOT_NS, \"public\")\nINTERNAL_NS = uuid.uuid5(ROOT_NS, \"internal\")\nADMIN_NS = uuid.uuid5(ROOT_NS, \"admin\")\n\n# Use appropriate namespace based on context\ndef generate_context_uuid(data, context):\n    namespaces = {\n        \"public\": PUBLIC_NS,\n        \"internal\": INTERNAL_NS,\n        \"admin\": ADMIN_NS\n    }\n\n    forge = UUIDGenerator(namespace=namespaces[context])\n    return forge.generate(data)\n</code></pre>"},{"location":"guide/best-practices/#migration-and-versioning","title":"Migration and Versioning","text":""},{"location":"guide/best-practices/#version-migration-strategy","title":"Version Migration Strategy","text":"<p>Plan for UUID version migrations:</p> <pre><code>class UUIDMigrationService:\n    def __init__(self):\n        self.old_forge = UUIDGenerator(version=3)  # Legacy\n        self.new_forge = UUIDGenerator(version=5)  # New\n\n    def migrate_uuid(self, input_data):\n        \"\"\"Migrate from old to new UUID version\"\"\"\n        old_uuid = self.old_forge.generate(input_data)\n        new_uuid = self.new_forge.generate(input_data)\n\n        return {\n            \"old_uuid\": old_uuid,\n            \"new_uuid\": new_uuid,\n            \"input_data\": input_data\n        }\n</code></pre>"},{"location":"guide/best-practices/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":""},{"location":"guide/best-practices/#inconsistent-input-preparation","title":"\u274c Inconsistent Input Preparation","text":"<pre><code># Don't do this - inconsistent casing\nuuid1 = forge.generate(\"User@Example.Com\")\nuuid2 = forge.generate(\"user@example.com\")\n# These will be different!\n</code></pre>"},{"location":"guide/best-practices/#creating-new-forge-instances-repeatedly","title":"\u274c Creating New Forge Instances Repeatedly","text":"<pre><code># Don't do this - inefficient\ndef get_user_uuid(user_email):\n    forge = UUIDGenerator(namespace=\"users\")  # Creates new instance every time\n    return forge.generate(user_email)\n</code></pre>"},{"location":"guide/best-practices/#mixing-uuid-versions-for-same-entity","title":"\u274c Mixing UUID Versions for Same Entity","text":"<pre><code># Don't do this - inconsistent versioning\nuser_uuid_v3 = UUIDGenerator(version=3).generate(user_data)\nuser_uuid_v5 = UUIDGenerator(version=5).generate(user_data)\n# These will be different UUIDs for the same user!\n</code></pre>"},{"location":"guide/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>Use Cases - See real-world implementation examples</li> <li>API Reference - Detailed API documentation</li> <li>Development - Contributing to UUID-Forge</li> </ul>"},{"location":"guide/cli/","title":"CLI Reference","text":"<p>UUID-Forge provides a powerful command-line interface for generating UUIDs and managing configurations.</p>"},{"location":"guide/cli/#installation-and-setup","title":"Installation and Setup","text":"<p>The CLI is installed automatically with UUID-Forge:</p> <pre><code>pip install uuid-forge\n</code></pre> <p>Verify installation:</p> <pre><code>uuid-forge --version\n</code></pre>"},{"location":"guide/cli/#basic-usage","title":"Basic Usage","text":""},{"location":"guide/cli/#generate-single-uuid","title":"Generate Single UUID","text":"<pre><code># Generate UUID from string\nuuid-forge generate \"user@example.com\"\n\n# Generate with custom namespace\nuuid-forge generate \"user@example.com\" --namespace \"users\"\n\n# Generate with specific version\nuuid-forge generate \"user@example.com\" --version 5\n</code></pre>"},{"location":"guide/cli/#output-formats","title":"Output Formats","text":"<pre><code># Default hex format\nuuid-forge generate \"test\"\n# Output: 550e8400-e29b-41d4-a716-446655440000\n\n# URN format\nuuid-forge generate \"test\" --format urn\n# Output: urn:uuid:550e8400-e29b-41d4-a716-446655440000\n\n# Raw hex (no separators)\nuuid-forge generate \"test\" --format hex --no-separators\n# Output: 550e8400e29b41d4a716446655440000\n\n# Uppercase\nuuid-forge generate \"test\" --case upper\n# Output: 550E8400-E29B-41D4-A716-446655440000\n</code></pre>"},{"location":"guide/cli/#batch-operations","title":"Batch Operations","text":""},{"location":"guide/cli/#generate-multiple-uuids","title":"Generate Multiple UUIDs","text":"<pre><code># From multiple arguments\nuuid-forge generate \"user1\" \"user2\" \"user3\"\n\n# From file (one input per line)\nuuid-forge generate --input-file users.txt\n\n# From stdin\necho -e \"user1\\nuser2\\nuser3\" | uuid-forge generate --stdin\n</code></pre>"},{"location":"guide/cli/#output-to-file","title":"Output to File","text":"<pre><code># Save to file\nuuid-forge generate \"user1\" \"user2\" --output results.txt\n\n# Append to existing file\nuuid-forge generate \"user3\" --output results.txt --append\n\n# JSON output format\nuuid-forge generate \"user1\" \"user2\" --output results.json --format-output json\n</code></pre>"},{"location":"guide/cli/#configuration-management","title":"Configuration Management","text":""},{"location":"guide/cli/#view-current-configuration","title":"View Current Configuration","text":"<pre><code># Show all configuration\nuuid-forge config show\n\n# Show specific setting\nuuid-forge config get namespace\n</code></pre>"},{"location":"guide/cli/#set-configuration","title":"Set Configuration","text":"<pre><code># Set default namespace\nuuid-forge config set namespace \"my-app\"\n\n# Set default version\nuuid-forge config set version 5\n\n# Set output format\nuuid-forge config set format hex\n</code></pre>"},{"location":"guide/cli/#configuration-files","title":"Configuration Files","text":"<pre><code># Create configuration file\nuuid-forge config init\n\n# Use specific config file\nuuid-forge --config /path/to/config.yaml generate \"test\"\n\n# Validate configuration\nuuid-forge config validate\n</code></pre>"},{"location":"guide/cli/#advanced-features","title":"Advanced Features","text":""},{"location":"guide/cli/#namespace-management","title":"Namespace Management","text":"<pre><code># List available namespaces\nuuid-forge namespace list\n\n# Create custom namespace\nuuid-forge namespace create \"my-service\" --parent users\n\n# Generate with custom namespace\nuuid-forge generate \"test\" --namespace-id 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/cli/#templates-and-presets","title":"Templates and Presets","text":"<pre><code># Create preset\nuuid-forge preset create \"users\" --namespace \"users\" --version 5 --format hex\n\n# Use preset\nuuid-forge generate \"john@example.com\" --preset users\n\n# List presets\nuuid-forge preset list\n\n# Delete preset\nuuid-forge preset delete \"users\"\n</code></pre>"},{"location":"guide/cli/#validation-and-testing","title":"Validation and Testing","text":""},{"location":"guide/cli/#validate-uuids","title":"Validate UUIDs","text":"<pre><code># Validate single UUID\nuuid-forge validate 550e8400-e29b-41d4-a716-446655440000\n\n# Validate multiple UUIDs\nuuid-forge validate --input-file uuids.txt\n\n# Check if UUID is deterministic\nuuid-forge validate --check-deterministic \"test-input\" 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"guide/cli/#testing-and-debugging","title":"Testing and Debugging","text":"<pre><code># Dry run (show what would be generated)\nuuid-forge generate \"test\" --dry-run\n\n# Verbose output\nuuid-forge generate \"test\" --verbose\n\n# Debug mode\nuuid-forge generate \"test\" --debug\n</code></pre>"},{"location":"guide/cli/#integration-examples","title":"Integration Examples","text":""},{"location":"guide/cli/#shell-scripts","title":"Shell Scripts","text":"<pre><code>#!/bin/bash\n\n# Generate user UUID and store in variable\nUSER_UUID=$(uuid-forge generate \"$USER_EMAIL\" --namespace users)\n\n# Use in database insert\npsql -c \"INSERT INTO users (id, email) VALUES ('$USER_UUID', '$USER_EMAIL')\"\n</code></pre>"},{"location":"guide/cli/#make-integration","title":"Make Integration","text":"<pre><code># Makefile\ngenerate-test-uuids:\n    uuid-forge generate --input-file test-users.txt --output test-uuids.txt\n\nvalidate-uuids:\n    uuid-forge validate --input-file production-uuids.txt\n</code></pre>"},{"location":"guide/cli/#cicd-pipeline","title":"CI/CD Pipeline","text":"<pre><code># GitHub Actions\nsteps:\n  - name: Generate UUIDs for testing\n    run: |\n      uuid-forge generate \\\n        --input-file test-data.txt \\\n        --output test-uuids.json \\\n        --format-output json \\\n        --namespace testing\n</code></pre>"},{"location":"guide/cli/#command-reference","title":"Command Reference","text":""},{"location":"guide/cli/#global-options","title":"Global Options","text":"<pre><code>--config PATH          # Configuration file path\n--namespace NAME       # Default namespace\n--version {3,4,5}      # UUID version\n--format {hex,urn,bytes} # Output format\n--case {upper,lower}   # Case for hex output\n--no-separators        # Remove separators from hex\n--verbose              # Verbose output\n--debug                # Debug mode\n--help                 # Show help\n</code></pre>"},{"location":"guide/cli/#subcommands","title":"Subcommands","text":"<ul> <li><code>generate</code> - Generate UUIDs</li> <li><code>config</code> - Manage configuration</li> <li><code>namespace</code> - Manage namespaces</li> <li><code>preset</code> - Manage presets</li> <li><code>validate</code> - Validate UUIDs</li> <li><code>version</code> - Show version information</li> </ul>"},{"location":"guide/cli/#environment-variables","title":"Environment Variables","text":"<pre><code># Configuration via environment\nexport UUID_FORGE_NAMESPACE=\"my-app\"\nexport UUID_FORGE_VERSION=5\nexport UUID_FORGE_FORMAT=\"hex\"\nexport UUID_FORGE_CASE=\"lower\"\nexport UUID_FORGE_CONFIG_FILE=\"/path/to/config.yaml\"\n</code></pre>"},{"location":"guide/cli/#tips-and-tricks","title":"Tips and Tricks","text":""},{"location":"guide/cli/#performance-optimization","title":"Performance Optimization","text":"<pre><code># Use batch processing for large datasets\nuuid-forge generate --input-file large-dataset.txt --batch-size 1000\n\n# Parallel processing\ncat users.txt | xargs -P 4 -I {} uuid-forge generate \"{}\" --namespace users\n</code></pre>"},{"location":"guide/cli/#scripting","title":"Scripting","text":"<pre><code># Generate and format for SQL\nuuid-forge generate \"user@example.com\" --format hex --case upper | \\\nsed \"s/.*/INSERT INTO users (id) VALUES ('&amp;');/\"\n\n# Check for duplicates\nuuid-forge generate --input-file data.txt | sort | uniq -d\n</code></pre>"},{"location":"guide/cli/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Optimize your UUID generation</li> <li>Use Cases - Real-world applications</li> <li>API Reference - Programmatic usage</li> </ul>"},{"location":"guide/concepts/","title":"Core Concepts","text":"<p>Understanding the core concepts behind UUID-Forge will help you use it effectively in your applications.</p>"},{"location":"guide/concepts/#what-are-uuids","title":"What are UUIDs?","text":"<p>UUIDs (Universally Unique Identifiers) are 128-bit values used to uniquely identify information in computer systems. They are designed to be unique across space and time without requiring a central authority.</p>"},{"location":"guide/concepts/#deterministic-generation","title":"Deterministic Generation","text":"<p>UUID-Forge specializes in deterministic UUID generation, meaning that given the same input, it will always produce the same UUID. This is crucial for:</p> <ul> <li>Cross-system coordination: Different services can generate the same UUID for the same entity</li> <li>Data consistency: Ensures referential integrity across distributed systems</li> <li>Testing: Predictable UUIDs make testing easier and more reliable</li> <li>Migration: Consistent UUIDs during data migration and transformation</li> </ul>"},{"location":"guide/concepts/#uuid-versions","title":"UUID Versions","text":"<p>UUID-Forge supports multiple UUID versions:</p>"},{"location":"guide/concepts/#version-3-md5-hash","title":"Version 3 (MD5 Hash)","text":"<ul> <li>Uses MD5 hashing algorithm</li> <li>Deterministic based on namespace and name</li> <li>Legacy support (MD5 is considered weak)</li> </ul>"},{"location":"guide/concepts/#version-4-random","title":"Version 4 (Random)","text":"<ul> <li>Randomly generated</li> <li>Not deterministic by nature</li> <li>Highest entropy</li> </ul>"},{"location":"guide/concepts/#version-5-sha-1-hash","title":"Version 5 (SHA-1 Hash)","text":"<ul> <li>Uses SHA-1 hashing algorithm</li> <li>Deterministic based on namespace and name</li> <li>Recommended for most deterministic use cases</li> </ul>"},{"location":"guide/concepts/#namespaces","title":"Namespaces","text":"<p>Namespaces are used to create logical groupings of UUIDs. They ensure that:</p> <ul> <li>UUIDs generated with different namespaces are unique</li> <li>Same name in different namespaces produces different UUIDs</li> <li>Hierarchical organization of UUID generation</li> </ul>"},{"location":"guide/concepts/#standard-namespaces","title":"Standard Namespaces","text":"<p>UUID-Forge provides several predefined namespaces:</p> <ul> <li><code>DNS</code>: For domain names</li> <li><code>URL</code>: For URLs</li> <li><code>OID</code>: For ISO OIDs</li> <li><code>X500</code>: For X.500 Distinguished Names</li> </ul>"},{"location":"guide/concepts/#custom-namespaces","title":"Custom Namespaces","text":"<p>You can define custom namespaces for your application:</p> <pre><code>from uuid_forge import UUIDGenerator\nimport uuid\n\n# Create a custom namespace for your application\nmy_namespace = uuid.uuid4()\nforge = UUIDGenerator(namespace=my_namespace)\n</code></pre>"},{"location":"guide/concepts/#input-processing","title":"Input Processing","text":"<p>UUID-Forge can process various input types:</p> <ul> <li>Strings: Text data, identifiers, names</li> <li>Dictionaries: Structured data converted to canonical form</li> <li>Objects: Any object with string representation</li> <li>Binary data: Raw bytes</li> </ul>"},{"location":"guide/concepts/#determinism-guarantees","title":"Determinism Guarantees","text":"<p>UUID-Forge guarantees that:</p> <ol> <li>Same input \u2192 Same UUID (within same namespace and configuration)</li> <li>Different input \u2192 Different UUID (with high probability)</li> <li>Cross-platform consistency (same UUID on different systems)</li> <li>Version consistency (same UUID across UUID-Forge versions)</li> </ol>"},{"location":"guide/concepts/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Usage - Learn how to generate your first UUIDs</li> <li>Advanced Usage - Explore advanced features</li> <li>Best Practices - Learn optimal usage patterns</li> </ul>"},{"location":"use-cases/microservices/","title":"Microservices Architecture","text":"<p>Learn how to use UUID-Forge effectively in microservices architectures for consistent entity identification across services.</p>"},{"location":"use-cases/microservices/#overview","title":"Overview","text":"<p>In microservices architectures, UUID-Forge solves the critical problem of consistent entity identification across distributed services. By generating deterministic UUIDs, different services can independently create the same UUID for the same entity, eliminating the need for centralized ID generation or complex coordination.</p>"},{"location":"use-cases/microservices/#key-benefits","title":"Key Benefits","text":"<ul> <li>Service Independence: Services can generate UUIDs without inter-service communication</li> <li>Data Consistency: Same entity gets same UUID across all services</li> <li>Event Sourcing: Consistent UUIDs for event correlation</li> <li>Testing: Predictable UUIDs simplify integration testing</li> </ul>"},{"location":"use-cases/microservices/#service-design-patterns","title":"Service Design Patterns","text":""},{"location":"use-cases/microservices/#1-namespace-per-service-pattern","title":"1. Namespace-per-Service Pattern","text":"<p>Each service uses its own namespace for entity isolation:</p> <pre><code># User Service\nfrom uuid_forge import UUIDGenerator\n# Service-specific namespace\nUSER_SERVICE_NS = Namespace(\"user-service.mycompany.com\")\nuser_forge = UUIDGenerator(namespace=USER_SERVICE_NS)\n\nclass UserService:\n    def create_user(self, email, name):\n        user_id = user_forge.generate({\n            \"email\": email.lower().strip(),\n            \"type\": \"user\"\n        })\n        return {\"id\": user_id, \"email\": email, \"name\": name}\n</code></pre> <pre><code># Order Service\nORDER_SERVICE_NS = Namespace(\"order-service.mycompany.com\")\norder_forge = UUIDGenerator(namespace=ORDER_SERVICE_NS)\n\nclass OrderService:\n    def create_order(self, user_email, items):\n        # Generate consistent user reference\n        user_id = user_forge.generate({\n            \"email\": user_email.lower().strip(),\n            \"type\": \"user\"\n        })\n\n        # Generate order ID\n        order_id = order_forge.generate({\n            \"user_id\": user_id,\n            \"items\": sorted(items),\n            \"type\": \"order\"\n        })\n\n        return {\"id\": order_id, \"user_id\": user_id, \"items\": items}\n</code></pre>"},{"location":"use-cases/microservices/#2-entity-type-based-namespaces","title":"2. Entity-Type-Based Namespaces","text":"<p>Create namespaces based on entity types:</p> <pre><code># Root namespace for the organization\nROOT_NS = Namespace(\"mycompany.com\")\n\n# Entity-specific namespaces\nUSERS_NS = uuid.uuid5(ROOT_NS, \"users\")\nORDERS_NS = uuid.uuid5(ROOT_NS, \"orders\")\nPRODUCTS_NS = uuid.uuid5(ROOT_NS, \"products\")\n\n# Shared forge instances\nuser_forge = UUIDGenerator(namespace=USERS_NS)\norder_forge = UUIDGenerator(namespace=ORDERS_NS)\nproduct_forge = UUIDGenerator(namespace=PRODUCTS_NS)\n\n# Any service can generate consistent entity UUIDs\ndef get_user_uuid(email):\n    return user_forge.generate(email.lower().strip())\n\ndef get_product_uuid(sku):\n    return product_forge.generate(sku.upper().strip())\n</code></pre>"},{"location":"use-cases/microservices/#service-integration-examples","title":"Service Integration Examples","text":""},{"location":"use-cases/microservices/#user-management-service","title":"User Management Service","text":"<pre><code>class UserManagementService:\n    def __init__(self):\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n\n    def register_user(self, email, profile_data):\n        user_id = self.user_forge.generate(email)\n\n        user = {\n            \"id\": user_id,\n            \"email\": email,\n            \"profile\": profile_data,\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Store in database\n        self.db.users.insert(user)\n\n        # Publish event\n        self.event_bus.publish(\"user.registered\", {\n            \"user_id\": user_id,\n            \"email\": email\n        })\n\n        return user\n\n    def get_user_id(self, email):\n        \"\"\"Other services can call this to get consistent user ID\"\"\"\n        return self.user_forge.generate(email)\n</code></pre>"},{"location":"use-cases/microservices/#order-processing-service","title":"Order Processing Service","text":"<pre><code>class OrderProcessingService:\n    def __init__(self):\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n        self.order_forge = UUIDGenerator(namespace=ORDERS_NS)\n        self.product_forge = UUIDGenerator(namespace=PRODUCTS_NS)\n\n    def create_order(self, user_email, product_skus, quantities):\n        # Generate consistent IDs\n        user_id = self.user_forge.generate(user_email)\n\n        order_items = []\n        for sku, qty in zip(product_skus, quantities):\n            product_id = self.product_forge.generate(sku)\n            order_items.append({\n                \"product_id\": product_id,\n                \"sku\": sku,\n                \"quantity\": qty\n            })\n\n        # Generate order ID from user and items\n        order_data = {\n            \"user_id\": user_id,\n            \"items\": sorted(order_items, key=lambda x: x[\"sku\"]),\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        order_id = self.order_forge.generate(order_data)\n\n        order = {\n            \"id\": order_id,\n            \"user_id\": user_id,\n            \"items\": order_items,\n            \"status\": \"pending\",\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Store order\n        self.db.orders.insert(order)\n\n        # Publish event\n        self.event_bus.publish(\"order.created\", {\n            \"order_id\": order_id,\n            \"user_id\": user_id\n        })\n\n        return order\n</code></pre>"},{"location":"use-cases/microservices/#notification-service","title":"Notification Service","text":"<pre><code>class NotificationService:\n    def __init__(self):\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n        self.notification_forge = UUIDGenerator(namespace=NOTIFICATIONS_NS)\n\n    def handle_order_created(self, event_data):\n        user_id = event_data[\"user_id\"]\n        order_id = event_data[\"order_id\"]\n\n        # Generate notification ID\n        notification_id = self.notification_forge.generate({\n            \"user_id\": user_id,\n            \"type\": \"order_confirmation\",\n            \"reference_id\": order_id\n        })\n\n        notification = {\n            \"id\": notification_id,\n            \"user_id\": user_id,\n            \"type\": \"order_confirmation\",\n            \"message\": f\"Your order {order_id} has been created\",\n            \"created_at\": datetime.utcnow()\n        }\n\n        self.send_notification(notification)\n</code></pre>"},{"location":"use-cases/microservices/#event-driven-architecture","title":"Event-Driven Architecture","text":""},{"location":"use-cases/microservices/#event-correlation","title":"Event Correlation","text":"<p>Use deterministic UUIDs for event correlation:</p> <pre><code>class EventService:\n    def __init__(self):\n        self.event_forge = UUIDGenerator(namespace=\"events\")\n\n    def create_correlation_id(self, user_id, action, timestamp):\n        \"\"\"Create deterministic correlation ID for event tracing\"\"\"\n        return self.event_forge.generate({\n            \"user_id\": user_id,\n            \"action\": action,\n            \"timestamp\": timestamp.isoformat()\n        })\n\n    def publish_correlated_events(self, user_id, action):\n        timestamp = datetime.utcnow()\n        correlation_id = self.create_correlation_id(user_id, action, timestamp)\n\n        events = [\n            {\"type\": \"action.started\", \"correlation_id\": correlation_id},\n            {\"type\": \"action.processed\", \"correlation_id\": correlation_id},\n            {\"type\": \"action.completed\", \"correlation_id\": correlation_id}\n        ]\n\n        for event in events:\n            self.event_bus.publish(event[\"type\"], event)\n</code></pre>"},{"location":"use-cases/microservices/#saga-pattern-implementation","title":"Saga Pattern Implementation","text":"<pre><code>class SagaOrchestrator:\n    def __init__(self):\n        self.saga_forge = UUIDGenerator(namespace=\"sagas\")\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n        self.order_forge = UUIDGenerator(namespace=ORDERS_NS)\n\n    def start_order_saga(self, user_email, order_data):\n        user_id = self.user_forge.generate(user_email)\n        order_id = self.order_forge.generate(order_data)\n\n        # Generate deterministic saga ID\n        saga_id = self.saga_forge.generate({\n            \"type\": \"order_processing\",\n            \"user_id\": user_id,\n            \"order_id\": order_id\n        })\n\n        saga_state = {\n            \"saga_id\": saga_id,\n            \"user_id\": user_id,\n            \"order_id\": order_id,\n            \"steps\": [\"validate_user\", \"reserve_inventory\", \"process_payment\"],\n            \"current_step\": 0,\n            \"status\": \"started\"\n        }\n\n        self.execute_saga_step(saga_state)\n        return saga_id\n</code></pre>"},{"location":"use-cases/microservices/#api-gateway-integration","title":"API Gateway Integration","text":""},{"location":"use-cases/microservices/#request-tracing","title":"Request Tracing","text":"<pre><code>class APIGateway:\n    def __init__(self):\n        self.trace_forge = UUIDGenerator(namespace=\"traces\")\n\n    def create_trace_id(self, request):\n        \"\"\"Create deterministic trace ID for request tracking\"\"\"\n        trace_data = {\n            \"method\": request.method,\n            \"path\": request.path,\n            \"user_agent\": request.headers.get(\"User-Agent\", \"\"),\n            \"timestamp\": datetime.utcnow().replace(microsecond=0).isoformat()\n        }\n        return self.trace_forge.generate(trace_data)\n\n    def process_request(self, request):\n        trace_id = self.create_trace_id(request)\n        request.headers[\"X-Trace-ID\"] = trace_id\n        return self.forward_to_service(request)\n</code></pre>"},{"location":"use-cases/microservices/#database-consistency","title":"Database Consistency","text":""},{"location":"use-cases/microservices/#cross-service-queries","title":"Cross-Service Queries","text":"<pre><code>class ReportingService:\n    def __init__(self):\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n        self.order_forge = UUIDGenerator(namespace=ORDERS_NS)\n\n    def generate_user_order_report(self, user_email):\n        user_id = self.user_forge.generate(user_email)\n\n        # Query user data from user service database\n        user_data = self.user_db.find_one({\"id\": user_id})\n\n        # Query order data from order service database\n        orders = self.order_db.find({\"user_id\": user_id})\n\n        return {\n            \"user\": user_data,\n            \"orders\": list(orders),\n            \"generated_at\": datetime.utcnow()\n        }\n</code></pre>"},{"location":"use-cases/microservices/#testing-strategies","title":"Testing Strategies","text":""},{"location":"use-cases/microservices/#integration-testing","title":"Integration Testing","text":"<pre><code>class IntegrationTestSuite:\n    def setUp(self):\n        self.user_service = UserManagementService()\n        self.order_service = OrderProcessingService()\n        self.notification_service = NotificationService()\n\n    def test_cross_service_uuid_consistency(self):\n        \"\"\"Test that all services generate same UUID for same entity\"\"\"\n        email = \"test@example.com\"\n\n        # Generate user ID from different services\n        user_id_1 = self.user_service.get_user_id(email)\n        user_id_2 = self.order_service.user_forge.generate(email)\n        user_id_3 = self.notification_service.user_forge.generate(email)\n\n        # All should be identical\n        assert user_id_1 == user_id_2 == user_id_3\n\n    def test_end_to_end_workflow(self):\n        \"\"\"Test complete workflow with consistent UUIDs\"\"\"\n        email = \"customer@example.com\"\n\n        # Register user\n        user = self.user_service.register_user(email, {\"name\": \"Test User\"})\n\n        # Create order\n        order = self.order_service.create_order(email, [\"SKU001\"], [1])\n\n        # Verify same user ID is used\n        assert user[\"id\"] == order[\"user_id\"]\n</code></pre>"},{"location":"use-cases/microservices/#monitoring-and-observability","title":"Monitoring and Observability","text":""},{"location":"use-cases/microservices/#uuid-tracking","title":"UUID Tracking","text":"<pre><code>import logging\n\nclass UUIDTracker:\n    def __init__(self):\n        self.logger = logging.getLogger(__name__)\n        self.user_forge = UUIDGenerator(namespace=USERS_NS)\n\n    def track_uuid_usage(self, service_name, entity_type, input_data, uuid_result):\n        \"\"\"Track UUID generation for debugging and monitoring\"\"\"\n        self.logger.info({\n            \"event\": \"uuid_generated\",\n            \"service\": service_name,\n            \"entity_type\": entity_type,\n            \"uuid\": uuid_result,\n            \"input_hash\": hash(str(input_data))  # Don't log sensitive data\n        })\n\n    def validate_uuid_consistency(self, expected_uuid, input_data):\n        \"\"\"Validate that UUID generation is still consistent\"\"\"\n        generated_uuid = self.user_forge.generate(input_data)\n        if generated_uuid != expected_uuid:\n            self.logger.error({\n                \"event\": \"uuid_inconsistency_detected\",\n                \"expected\": expected_uuid,\n                \"generated\": generated_uuid,\n                \"input_hash\": hash(str(input_data))\n            })\n            return False\n        return True\n</code></pre>"},{"location":"use-cases/microservices/#next-steps","title":"Next Steps","text":"<ul> <li>Multi-Storage Use Case - Learn about UUID consistency across storage systems</li> <li>Testing Use Case - Advanced testing strategies with deterministic UUIDs</li> <li>Migration Use Case - Data migration patterns with UUID-Forge</li> </ul>"},{"location":"use-cases/migration/","title":"Data Migration with UUID-Forge","text":"<p>Learn how to use deterministic UUIDs for seamless data migration across systems, databases, and platforms.</p>"},{"location":"use-cases/migration/#overview","title":"Overview","text":"<p>Data migration often involves moving data between different systems while maintaining referential integrity and consistency. UUID-Forge's deterministic generation ensures that the same entities receive the same UUIDs across different environments and migration phases.</p>"},{"location":"use-cases/migration/#migration-challenges","title":"Migration Challenges","text":""},{"location":"use-cases/migration/#traditional-migration-problems","title":"Traditional Migration Problems","text":"<ul> <li>ID Mapping: Translating IDs between different systems</li> <li>Referential Integrity: Maintaining relationships during migration</li> <li>Incremental Migration: Handling partial migrations over time</li> <li>Rollback Scenarios: Reverting migrations safely</li> <li>Cross-System Consistency: Ensuring same entity has same ID everywhere</li> </ul>"},{"location":"use-cases/migration/#uuid-forge-solutions","title":"UUID-Forge Solutions","text":"<ul> <li>Deterministic IDs: Same input always generates same UUID</li> <li>No ID Mapping Required: UUIDs are consistent across systems</li> <li>Referential Integrity Maintained: Related entities get related UUIDs</li> <li>Idempotent Migration: Running migration multiple times is safe</li> <li>Cross-Platform Consistency: Same UUIDs on any system</li> </ul>"},{"location":"use-cases/migration/#migration-patterns","title":"Migration Patterns","text":""},{"location":"use-cases/migration/#database-to-database-migration","title":"Database-to-Database Migration","text":""},{"location":"use-cases/migration/#legacy-system-to-modern-database","title":"Legacy System to Modern Database","text":"<pre><code>from uuid_forge import UUIDGenerator\nimport psycopg2\nimport sqlite3\n\nclass DatabaseMigrator:\n    def __init__(self):\n        # Generators for different entity types\n        self.user_gen = UUIDGenerator(namespace=\"users\")\n        self.order_gen = UUIDGenerator(namespace=\"orders\")\n        self.product_gen = UUIDGenerator(namespace=\"products\")\n\n        # Database connections\n        self.legacy_db = sqlite3.connect(\"legacy.db\")\n        self.modern_db = psycopg2.connect(\"postgresql://...\")\n\n    def migrate_users(self):\n        \"\"\"Migrate users from legacy SQLite to PostgreSQL\"\"\"\n        legacy_cursor = self.legacy_db.cursor()\n        modern_cursor = self.modern_db.cursor()\n\n        # Read from legacy database\n        legacy_cursor.execute(\"SELECT email, name, created_at FROM users\")\n        legacy_users = legacy_cursor.fetchall()\n\n        for email, name, created_at in legacy_users:\n            # Generate deterministic UUID for user\n            user_uuid = self.user_gen.generate(email)\n\n            # Insert into modern database\n            modern_cursor.execute(\n                \"INSERT INTO users (id, email, name, created_at) VALUES (%s, %s, %s, %s)\",\n                (user_uuid, email, name, created_at)\n            )\n\n        self.modern_db.commit()\n        print(f\"Migrated {len(legacy_users)} users\")\n\n    def migrate_orders(self):\n        \"\"\"Migrate orders maintaining user relationships\"\"\"\n        legacy_cursor = self.legacy_db.cursor()\n        modern_cursor = self.modern_db.cursor()\n\n        # Read orders with user email for UUID generation\n        legacy_cursor.execute(\"\"\"\n            SELECT o.id, u.email, o.total, o.created_at\n            FROM orders o\n            JOIN users u ON o.user_id = u.id\n        \"\"\")\n        legacy_orders = legacy_cursor.fetchall()\n\n        for legacy_order_id, user_email, total, created_at in legacy_orders:\n            # Generate consistent UUIDs\n            user_uuid = self.user_gen.generate(user_email)\n\n            # Generate order UUID from user and legacy order data\n            order_data = {\n                \"user_email\": user_email,\n                \"legacy_id\": legacy_order_id,\n                \"total\": total,\n                \"created_at\": created_at\n            }\n            order_uuid = self.order_gen.generate(order_data)\n\n            # Insert into modern database\n            modern_cursor.execute(\n                \"INSERT INTO orders (id, user_id, total, created_at) VALUES (%s, %s, %s, %s)\",\n                (order_uuid, user_uuid, total, created_at)\n            )\n\n        self.modern_db.commit()\n        print(f\"Migrated {len(legacy_orders)} orders\")\n</code></pre>"},{"location":"use-cases/migration/#nosql-to-sql-migration","title":"NoSQL to SQL Migration","text":"<pre><code>from pymongo import MongoClient\nimport psycopg2\nfrom uuid_forge import UUIDGenerator\n\nclass NoSQLToSQLMigrator:\n    def __init__(self):\n        self.mongo_client = MongoClient(\"mongodb://localhost:27017/\")\n        self.mongo_db = self.mongo_client.legacy_app\n\n        self.postgres_conn = psycopg2.connect(\"postgresql://...\")\n\n        # UUID generators\n        self.user_gen = UUIDGenerator(namespace=\"users\")\n        self.post_gen = UUIDGenerator(namespace=\"posts\")\n        self.comment_gen = UUIDGenerator(namespace=\"comments\")\n\n    def migrate_user_posts(self):\n        \"\"\"Migrate nested document structure to relational tables\"\"\"\n        cursor = self.postgres_conn.cursor()\n\n        # Read MongoDB documents\n        for user_doc in self.mongo_db.users.find():\n            user_email = user_doc[\"email\"]\n            user_uuid = self.user_gen.generate(user_email)\n\n            # Migrate user\n            cursor.execute(\n                \"INSERT INTO users (id, email, name) VALUES (%s, %s, %s)\",\n                (user_uuid, user_doc[\"email\"], user_doc[\"name\"])\n            )\n\n            # Migrate embedded posts\n            for post in user_doc.get(\"posts\", []):\n                post_data = {\n                    \"user_email\": user_email,\n                    \"title\": post[\"title\"],\n                    \"content\": post[\"content\"],\n                    \"created_at\": post[\"created_at\"].isoformat()\n                }\n                post_uuid = self.post_gen.generate(post_data)\n\n                cursor.execute(\n                    \"INSERT INTO posts (id, user_id, title, content, created_at) VALUES (%s, %s, %s, %s, %s)\",\n                    (post_uuid, user_uuid, post[\"title\"], post[\"content\"], post[\"created_at\"])\n                )\n\n                # Migrate embedded comments\n                for comment in post.get(\"comments\", []):\n                    comment_data = {\n                        \"post_id\": post_uuid,\n                        \"author\": comment[\"author\"],\n                        \"content\": comment[\"content\"],\n                        \"created_at\": comment[\"created_at\"].isoformat()\n                    }\n                    comment_uuid = self.comment_gen.generate(comment_data)\n\n                    cursor.execute(\n                        \"INSERT INTO comments (id, post_id, author, content, created_at) VALUES (%s, %s, %s, %s, %s)\",\n                        (comment_uuid, post_uuid, comment[\"author\"], comment[\"content\"], comment[\"created_at\"])\n                    )\n\n        self.postgres_conn.commit()\n</code></pre>"},{"location":"use-cases/migration/#cloud-migration","title":"Cloud Migration","text":""},{"location":"use-cases/migration/#on-premises-to-cloud-migration","title":"On-Premises to Cloud Migration","text":"<pre><code>import boto3\nfrom uuid_forge import UUIDGenerator\n\nclass CloudMigrator:\n    def __init__(self):\n        # Local database connection\n        self.local_db = psycopg2.connect(\"postgresql://localhost/app\")\n\n        # AWS services\n        self.dynamodb = boto3.resource('dynamodb', region_name='us-east-1')\n        self.s3 = boto3.client('s3')\n\n        # UUID generators\n        self.user_gen = UUIDGenerator(namespace=\"cloud-users\")\n        self.file_gen = UUIDGenerator(namespace=\"cloud-files\")\n\n    def migrate_to_dynamodb(self):\n        \"\"\"Migrate relational data to DynamoDB\"\"\"\n        cursor = self.local_db.cursor()\n        table = self.dynamodb.Table('Users')\n\n        cursor.execute(\"SELECT email, name, profile_data FROM users\")\n\n        for email, name, profile_data in cursor.fetchall():\n            user_uuid = self.user_gen.generate(email)\n\n            # Store in DynamoDB with UUID as partition key\n            table.put_item(\n                Item={\n                    'user_id': user_uuid,\n                    'email': email,\n                    'name': name,\n                    'profile_data': profile_data,\n                    'migrated_at': datetime.utcnow().isoformat()\n                }\n            )\n\n    def migrate_files_to_s3(self):\n        \"\"\"Migrate files to S3 with deterministic keys\"\"\"\n        cursor = self.local_db.cursor()\n\n        cursor.execute(\"SELECT file_path, metadata, content FROM files\")\n\n        for file_path, metadata, content in cursor.fetchall():\n            # Generate deterministic S3 key\n            file_data = {\n                \"original_path\": file_path,\n                \"size\": len(content),\n                \"metadata\": metadata\n            }\n            file_uuid = self.file_gen.generate(file_data)\n            s3_key = f\"migrated-files/{file_uuid}\"\n\n            # Upload to S3\n            self.s3.put_object(\n                Bucket='migration-bucket',\n                Key=s3_key,\n                Body=content,\n                Metadata={\n                    'original-path': file_path,\n                    'file-uuid': file_uuid,\n                    **metadata\n                }\n            )\n</code></pre>"},{"location":"use-cases/migration/#incremental-migration","title":"Incremental Migration","text":""},{"location":"use-cases/migration/#phased-migration-strategy","title":"Phased Migration Strategy","text":"<pre><code>class IncrementalMigrator:\n    def __init__(self):\n        self.source_db = psycopg2.connect(\"postgresql://source/\")\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n\n        self.user_gen = UUIDGenerator(namespace=\"incremental-users\")\n\n        # Track migration progress\n        self.migration_state = {\n            \"last_migrated_id\": 0,\n            \"batch_size\": 1000,\n            \"total_migrated\": 0\n        }\n\n    def migrate_batch(self):\n        \"\"\"Migrate a batch of records\"\"\"\n        source_cursor = self.source_db.cursor()\n        target_cursor = self.target_db.cursor()\n\n        # Get next batch\n        source_cursor.execute(\n            \"SELECT id, email, name FROM users WHERE id &gt; %s ORDER BY id LIMIT %s\",\n            (self.migration_state[\"last_migrated_id\"], self.migration_state[\"batch_size\"])\n        )\n\n        batch = source_cursor.fetchall()\n        if not batch:\n            print(\"Migration complete!\")\n            return False\n\n        # Migrate batch with deterministic UUIDs\n        for source_id, email, name in batch:\n            user_uuid = self.user_gen.generate(email)\n\n            # Use ON CONFLICT for idempotent migration\n            target_cursor.execute(\n                \"\"\"\n                INSERT INTO users (id, email, name, source_id, migrated_at)\n                VALUES (%s, %s, %s, %s, %s)\n                ON CONFLICT (email) DO UPDATE SET\n                    name = EXCLUDED.name,\n                    migrated_at = EXCLUDED.migrated_at\n                \"\"\",\n                (user_uuid, email, name, source_id, datetime.utcnow())\n            )\n\n            self.migration_state[\"last_migrated_id\"] = source_id\n\n        self.target_db.commit()\n        self.migration_state[\"total_migrated\"] += len(batch)\n\n        print(f\"Migrated batch: {len(batch)} records, Total: {self.migration_state['total_migrated']}\")\n        return True\n\n    def run_incremental_migration(self):\n        \"\"\"Run migration in batches\"\"\"\n        while self.migrate_batch():\n            time.sleep(1)  # Brief pause between batches\n</code></pre>"},{"location":"use-cases/migration/#data-synchronization","title":"Data Synchronization","text":""},{"location":"use-cases/migration/#bidirectional-sync","title":"Bidirectional Sync","text":"<pre><code>class DataSynchronizer:\n    def __init__(self):\n        self.system_a = psycopg2.connect(\"postgresql://system-a/\")\n        self.system_b = psycopg2.connect(\"postgresql://system-b/\")\n\n        self.user_gen = UUIDGenerator(namespace=\"sync-users\")\n        self.sync_log = []\n\n    def sync_user_changes(self):\n        \"\"\"Synchronize user changes between systems\"\"\"\n        cursor_a = self.system_a.cursor()\n        cursor_b = self.system_b.cursor()\n\n        # Get changes from system A\n        cursor_a.execute(\n            \"SELECT email, name, updated_at FROM users WHERE updated_at &gt; %s\",\n            (self.last_sync_time,)\n        )\n\n        changes_a = cursor_a.fetchall()\n\n        for email, name, updated_at in changes_a:\n            user_uuid = self.user_gen.generate(email)\n\n            # Apply change to system B\n            cursor_b.execute(\n                \"\"\"\n                INSERT INTO users (id, email, name, updated_at)\n                VALUES (%s, %s, %s, %s)\n                ON CONFLICT (id) DO UPDATE SET\n                    name = EXCLUDED.name,\n                    updated_at = EXCLUDED.updated_at\n                WHERE users.updated_at &lt; EXCLUDED.updated_at\n                \"\"\",\n                (user_uuid, email, name, updated_at)\n            )\n\n            self.sync_log.append({\n                \"user_id\": user_uuid,\n                \"direction\": \"A-&gt;B\",\n                \"timestamp\": datetime.utcnow()\n            })\n\n        self.system_b.commit()\n</code></pre>"},{"location":"use-cases/migration/#migration-validation","title":"Migration Validation","text":""},{"location":"use-cases/migration/#data-integrity-verification","title":"Data Integrity Verification","text":"<pre><code>class MigrationValidator:\n    def __init__(self):\n        self.source_db = psycopg2.connect(\"postgresql://source/\")\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n\n        self.user_gen = UUIDGenerator(namespace=\"validation-users\")\n\n    def validate_user_migration(self):\n        \"\"\"Validate that all users migrated correctly\"\"\"\n        source_cursor = self.source_db.cursor()\n        target_cursor = self.target_db.cursor()\n\n        source_cursor.execute(\"SELECT email, name FROM users ORDER BY email\")\n        source_users = source_cursor.fetchall()\n\n        target_cursor.execute(\"SELECT email, name FROM users ORDER BY email\")\n        target_users = target_cursor.fetchall()\n\n        validation_results = {\n            \"total_source\": len(source_users),\n            \"total_target\": len(target_users),\n            \"missing_users\": [],\n            \"data_mismatches\": []\n        }\n\n        source_dict = {email: name for email, name in source_users}\n        target_dict = {email: name for email, name in target_users}\n\n        # Check for missing users\n        for email in source_dict:\n            if email not in target_dict:\n                validation_results[\"missing_users\"].append(email)\n            elif source_dict[email] != target_dict[email]:\n                validation_results[\"data_mismatches\"].append({\n                    \"email\": email,\n                    \"source_name\": source_dict[email],\n                    \"target_name\": target_dict[email]\n                })\n\n        return validation_results\n\n    def validate_referential_integrity(self):\n        \"\"\"Validate that relationships are maintained\"\"\"\n        target_cursor = self.target_db.cursor()\n\n        # Check that all orders have valid user references\n        target_cursor.execute(\"\"\"\n            SELECT COUNT(*) FROM orders o\n            LEFT JOIN users u ON o.user_id = u.id\n            WHERE u.id IS NULL\n        \"\"\")\n\n        orphaned_orders = target_cursor.fetchone()[0]\n\n        return {\n            \"orphaned_orders\": orphaned_orders,\n            \"integrity_valid\": orphaned_orders == 0\n        }\n</code></pre>"},{"location":"use-cases/migration/#rollback-strategies","title":"Rollback Strategies","text":""},{"location":"use-cases/migration/#safe-migration-rollback","title":"Safe Migration Rollback","text":"<pre><code>class MigrationRollback:\n    def __init__(self):\n        self.target_db = psycopg2.connect(\"postgresql://target/\")\n        self.backup_db = psycopg2.connect(\"postgresql://backup/\")\n\n    def create_rollback_point(self):\n        \"\"\"Create a rollback point before migration\"\"\"\n        target_cursor = self.target_db.cursor()\n        backup_cursor = self.backup_db.cursor()\n\n        # Backup current state\n        target_cursor.execute(\"SELECT * FROM users\")\n        users = target_cursor.fetchall()\n\n        # Clear backup and restore\n        backup_cursor.execute(\"DELETE FROM users\")\n\n        for user in users:\n            backup_cursor.execute(\n                \"INSERT INTO users VALUES (%s, %s, %s, %s)\",\n                user\n            )\n\n        self.backup_db.commit()\n        print(\"Rollback point created\")\n\n    def rollback_migration(self):\n        \"\"\"Rollback to previous state\"\"\"\n        target_cursor = self.target_db.cursor()\n        backup_cursor = self.backup_db.cursor()\n\n        # Clear target\n        target_cursor.execute(\"DELETE FROM users\")\n\n        # Restore from backup\n        backup_cursor.execute(\"SELECT * FROM users\")\n        backup_users = backup_cursor.fetchall()\n\n        for user in backup_users:\n            target_cursor.execute(\n                \"INSERT INTO users VALUES (%s, %s, %s, %s)\",\n                user\n            )\n\n        self.target_db.commit()\n        print(\"Migration rolled back successfully\")\n</code></pre>"},{"location":"use-cases/migration/#migration-monitoring","title":"Migration Monitoring","text":""},{"location":"use-cases/migration/#progress-tracking","title":"Progress Tracking","text":"<pre><code>class MigrationMonitor:\n    def __init__(self):\n        self.metrics = {\n            \"start_time\": None,\n            \"records_processed\": 0,\n            \"records_failed\": 0,\n            \"current_phase\": None,\n            \"estimated_completion\": None\n        }\n\n    def start_monitoring(self, total_records):\n        \"\"\"Start migration monitoring\"\"\"\n        self.metrics[\"start_time\"] = datetime.utcnow()\n        self.metrics[\"total_records\"] = total_records\n        print(f\"Migration started: {total_records} records to process\")\n\n    def update_progress(self, records_processed, current_phase=\"processing\"):\n        \"\"\"Update migration progress\"\"\"\n        self.metrics[\"records_processed\"] = records_processed\n        self.metrics[\"current_phase\"] = current_phase\n\n        elapsed = datetime.utcnow() - self.metrics[\"start_time\"]\n        progress_pct = (records_processed / self.metrics[\"total_records\"]) * 100\n\n        if records_processed &gt; 0:\n            avg_time_per_record = elapsed / records_processed\n            remaining_records = self.metrics[\"total_records\"] - records_processed\n            eta = datetime.utcnow() + (avg_time_per_record * remaining_records)\n            self.metrics[\"estimated_completion\"] = eta\n\n        print(f\"Progress: {progress_pct:.1f}% ({records_processed}/{self.metrics['total_records']}) - ETA: {eta}\")\n\n    def log_error(self, record_id, error):\n        \"\"\"Log migration error\"\"\"\n        self.metrics[\"records_failed\"] += 1\n        print(f\"Error processing record {record_id}: {error}\")\n\n    def complete_monitoring(self):\n        \"\"\"Complete migration monitoring\"\"\"\n        total_time = datetime.utcnow() - self.metrics[\"start_time\"]\n        success_rate = ((self.metrics[\"records_processed\"] - self.metrics[\"records_failed\"]) /\n                       self.metrics[\"total_records\"]) * 100\n\n        print(f\"Migration completed in {total_time}\")\n        print(f\"Success rate: {success_rate:.1f}%\")\n        print(f\"Records processed: {self.metrics['records_processed']}\")\n        print(f\"Records failed: {self.metrics['records_failed']}\")\n</code></pre>"},{"location":"use-cases/migration/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Use Case - Testing migration strategies</li> <li>Best Practices - Migration optimization</li> <li>Development Guide - Development environment setup</li> </ul>"},{"location":"use-cases/multi-storage/","title":"Multi-Storage Systems","text":"<p>Learn how UUID-Forge ensures consistency across different storage systems and databases.</p>"},{"location":"use-cases/multi-storage/#overview","title":"Overview","text":"<p>In modern applications, data often spans multiple storage systems - SQL databases, NoSQL stores, message queues, caches, and file systems. UUID-Forge provides deterministic UUID generation to maintain consistent entity identification across all these systems.</p>"},{"location":"use-cases/multi-storage/#common-challenges","title":"Common Challenges","text":""},{"location":"use-cases/multi-storage/#storage-system-inconsistencies","title":"Storage System Inconsistencies","text":"<p>Different storage systems may handle UUIDs differently:</p> <ul> <li>SQL databases: Native UUID columns with specific formatting</li> <li>NoSQL stores: String or binary UUID representations</li> <li>Message queues: UUID as message correlation IDs</li> <li>Caches: UUID as cache keys</li> <li>File systems: UUID in filenames or directory structures</li> </ul>"},{"location":"use-cases/multi-storage/#synchronization-issues","title":"Synchronization Issues","text":"<p>Traditional approaches face challenges:</p> <ul> <li>Database sequences: Not available across all systems</li> <li>Auto-generated UUIDs: Different for same entity</li> <li>Centralized ID generation: Single point of failure</li> <li>Manual coordination: Error-prone and complex</li> </ul>"},{"location":"use-cases/multi-storage/#uuid-forge-solution","title":"UUID-Forge Solution","text":""},{"location":"use-cases/multi-storage/#deterministic-generation","title":"Deterministic Generation","text":"<p>Same input always produces the same UUID:</p> <pre><code>from uuid_forge import UUIDGenerator\n\n# Initialize generator\ngenerator = UUIDGenerator(namespace=\"users\")\n\n# Same UUID across all storage systems\nuser_email = \"john@example.com\"\nuser_uuid = generator.generate(user_email)\n\n# Use in SQL database\nsql_insert = f\"INSERT INTO users (id, email) VALUES ('{user_uuid}', '{user_email}')\"\n\n# Use in MongoDB\nmongo_doc = {\"_id\": user_uuid, \"email\": user_email}\n\n# Use as Redis key\nredis_key = f\"user:{user_uuid}\"\n</code></pre>"},{"location":"use-cases/multi-storage/#implementation-patterns","title":"Implementation Patterns","text":""},{"location":"use-cases/multi-storage/#database-integration","title":"Database Integration","text":""},{"location":"use-cases/multi-storage/#postgresql-with-uuid-column","title":"PostgreSQL with UUID Column","text":"<pre><code>import psycopg2\nfrom uuid_forge import UUIDGenerator\n\nclass UserRepository:\n    def __init__(self):\n        self.generator = UUIDGenerator(namespace=\"users\")\n        self.conn = psycopg2.connect(\"postgresql://...\")\n\n    def create_user(self, email, name):\n        user_id = self.generator.generate(email)\n\n        with self.conn.cursor() as cur:\n            cur.execute(\n                \"INSERT INTO users (id, email, name) VALUES (%s, %s, %s)\",\n                (user_id, email, name)\n            )\n\n        return user_id\n\n    def get_user_id(self, email):\n        \"\"\"Get consistent user ID without database lookup\"\"\"\n        return self.generator.generate(email)\n</code></pre>"},{"location":"use-cases/multi-storage/#mongodb-integration","title":"MongoDB Integration","text":"<pre><code>from pymongo import MongoClient\nfrom uuid_forge import UUIDGenerator\n\nclass DocumentStore:\n    def __init__(self):\n        self.generator = UUIDGenerator(namespace=\"documents\")\n        self.client = MongoClient(\"mongodb://...\")\n        self.db = self.client.myapp\n\n    def store_document(self, content, metadata):\n        doc_data = {\n            \"content\": content,\n            \"metadata\": metadata,\n            \"created_at\": datetime.utcnow()\n        }\n\n        # Generate deterministic ID from content and metadata\n        doc_id = self.generator.generate(doc_data)\n\n        # Store in MongoDB\n        self.db.documents.insert_one({\n            \"_id\": doc_id,\n            **doc_data\n        })\n\n        return doc_id\n</code></pre>"},{"location":"use-cases/multi-storage/#cache-integration","title":"Cache Integration","text":""},{"location":"use-cases/multi-storage/#redis-caching","title":"Redis Caching","text":"<pre><code>import redis\nfrom uuid_forge import UUIDGenerator\n\nclass CacheManager:\n    def __init__(self):\n        self.user_generator = UUIDGenerator(namespace=\"users\")\n        self.session_generator = UUIDGenerator(namespace=\"sessions\")\n        self.redis = redis.Redis(host=\"localhost\", port=6379)\n\n    def cache_user_data(self, email, user_data):\n        user_id = self.user_generator.generate(email)\n        cache_key = f\"user:{user_id}\"\n\n        # Store in Redis with deterministic key\n        self.redis.setex(cache_key, 3600, json.dumps(user_data))\n\n        return cache_key\n\n    def get_cached_user(self, email):\n        user_id = self.user_generator.generate(email)\n        cache_key = f\"user:{user_id}\"\n\n        cached_data = self.redis.get(cache_key)\n        return json.loads(cached_data) if cached_data else None\n</code></pre>"},{"location":"use-cases/multi-storage/#message-queue-integration","title":"Message Queue Integration","text":""},{"location":"use-cases/multi-storage/#rabbitmq-with-correlation-ids","title":"RabbitMQ with Correlation IDs","text":"<pre><code>import pika\nfrom uuid_forge import UUIDGenerator\n\nclass MessagePublisher:\n    def __init__(self):\n        self.message_generator = UUIDGenerator(namespace=\"messages\")\n        self.connection = pika.BlockingConnection(\n            pika.ConnectionParameters(\"localhost\")\n        )\n        self.channel = self.connection.channel()\n\n    def publish_user_event(self, user_email, event_type, event_data):\n        # Generate deterministic correlation ID\n        correlation_data = {\n            \"user_email\": user_email,\n            \"event_type\": event_type,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        correlation_id = self.message_generator.generate(correlation_data)\n\n        message = {\n            \"correlation_id\": correlation_id,\n            \"user_email\": user_email,\n            \"event_type\": event_type,\n            \"data\": event_data\n        }\n\n        self.channel.basic_publish(\n            exchange=\"user_events\",\n            routing_key=event_type,\n            body=json.dumps(message),\n            properties=pika.BasicProperties(correlation_id=correlation_id)\n        )\n\n        return correlation_id\n</code></pre>"},{"location":"use-cases/multi-storage/#cross-system-consistency-examples","title":"Cross-System Consistency Examples","text":""},{"location":"use-cases/multi-storage/#e-commerce-order-processing","title":"E-commerce Order Processing","text":"<pre><code>class OrderProcessingSystem:\n    def __init__(self):\n        self.user_gen = UUIDGenerator(namespace=\"users\")\n        self.order_gen = UUIDGenerator(namespace=\"orders\")\n        self.product_gen = UUIDGenerator(namespace=\"products\")\n\n        # Multiple storage systems\n        self.postgres = psycopg2.connect(\"postgresql://...\")\n        self.redis = redis.Redis()\n        self.mongo = MongoClient()\n        self.es = Elasticsearch()\n\n    def process_order(self, user_email, product_skus, quantities):\n        # Generate consistent IDs\n        user_id = self.user_gen.generate(user_email)\n\n        order_items = []\n        for sku, qty in zip(product_skus, quantities):\n            product_id = self.product_gen.generate(sku)\n            order_items.append({\n                \"product_id\": product_id,\n                \"sku\": sku,\n                \"quantity\": qty\n            })\n\n        order_data = {\n            \"user_id\": user_id,\n            \"items\": sorted(order_items, key=lambda x: x[\"sku\"]),\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        order_id = self.order_gen.generate(order_data)\n\n        # Store in PostgreSQL (transactional data)\n        with self.postgres.cursor() as cur:\n            cur.execute(\n                \"INSERT INTO orders (id, user_id, status, created_at) VALUES (%s, %s, %s, %s)\",\n                (order_id, user_id, \"pending\", datetime.utcnow())\n            )\n\n            for item in order_items:\n                cur.execute(\n                    \"INSERT INTO order_items (order_id, product_id, quantity) VALUES (%s, %s, %s)\",\n                    (order_id, item[\"product_id\"], item[\"quantity\"])\n                )\n\n        # Cache in Redis (fast access)\n        self.redis.setex(\n            f\"order:{order_id}\",\n            3600,\n            json.dumps(order_data)\n        )\n\n        # Store in MongoDB (document store)\n        self.mongo.orders.insert_one({\n            \"_id\": order_id,\n            **order_data\n        })\n\n        # Index in Elasticsearch (search)\n        self.es.index(\n            index=\"orders\",\n            id=order_id,\n            body={\n                **order_data,\n                \"searchable_text\": f\"{user_email} {' '.join(product_skus)}\"\n            }\n        )\n\n        return order_id\n</code></pre>"},{"location":"use-cases/multi-storage/#file-system-integration","title":"File System Integration","text":"<pre><code>import os\nfrom pathlib import Path\nfrom uuid_forge import UUIDGenerator\n\nclass FileManager:\n    def __init__(self, base_path):\n        self.base_path = Path(base_path)\n        self.file_generator = UUIDGenerator(namespace=\"files\")\n\n    def store_file(self, content, metadata):\n        # Generate deterministic file UUID\n        file_data = {\n            \"content_hash\": hashlib.md5(content).hexdigest(),\n            \"metadata\": metadata,\n            \"size\": len(content)\n        }\n        file_uuid = self.file_generator.generate(file_data)\n\n        # Create directory structure using UUID segments\n        dir_path = self.base_path / file_uuid[:2] / file_uuid[2:4]\n        dir_path.mkdir(parents=True, exist_ok=True)\n\n        # Store file with UUID name\n        file_path = dir_path / f\"{file_uuid}.dat\"\n        with open(file_path, \"wb\") as f:\n            f.write(content)\n\n        # Store metadata in database with same UUID\n        self.store_metadata_in_db(file_uuid, metadata, str(file_path))\n\n        return file_uuid\n\n    def get_file_path(self, content, metadata):\n        \"\"\"Get file path without creating file\"\"\"\n        file_data = {\n            \"content_hash\": hashlib.md5(content).hexdigest(),\n            \"metadata\": metadata,\n            \"size\": len(content)\n        }\n        file_uuid = self.file_generator.generate(file_data)\n\n        return self.base_path / file_uuid[:2] / file_uuid[2:4] / f\"{file_uuid}.dat\"\n</code></pre>"},{"location":"use-cases/multi-storage/#testing-multi-storage-consistency","title":"Testing Multi-Storage Consistency","text":""},{"location":"use-cases/multi-storage/#integration-testing","title":"Integration Testing","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\nclass TestMultiStorageConsistency:\n    def setUp(self):\n        self.user_gen = UUIDGenerator(namespace=\"test-users\")\n        self.order_gen = UUIDGenerator(namespace=\"test-orders\")\n\n        # Initialize test storage systems\n        self.setup_test_databases()\n\n    def test_user_id_consistency(self):\n        \"\"\"Test user ID consistency across all storage systems\"\"\"\n        email = \"test@example.com\"\n\n        # Generate UUID from different components\n        user_id_1 = self.user_gen.generate(email)\n        user_id_2 = self.get_user_id_from_postgres(email)\n        user_id_3 = self.get_user_id_from_cache(email)\n        user_id_4 = self.get_user_id_from_mongo(email)\n\n        # All should be identical\n        assert user_id_1 == user_id_2 == user_id_3 == user_id_4\n\n    def test_cross_system_query(self):\n        \"\"\"Test querying data across multiple systems using consistent UUIDs\"\"\"\n        email = \"customer@example.com\"\n        user_id = self.user_gen.generate(email)\n\n        # Store user in different systems\n        self.store_user_in_postgres(user_id, email)\n        self.cache_user_in_redis(user_id, {\"name\": \"Test User\"})\n        self.index_user_in_elasticsearch(user_id, email)\n\n        # Query from different systems using same UUID\n        pg_user = self.get_user_from_postgres(user_id)\n        cached_user = self.get_user_from_cache(user_id)\n        indexed_user = self.search_user_in_elasticsearch(user_id)\n\n        # Verify data consistency\n        assert pg_user[\"id\"] == cached_user[\"id\"] == indexed_user[\"id\"] == user_id\n</code></pre>"},{"location":"use-cases/multi-storage/#monitoring-and-debugging","title":"Monitoring and Debugging","text":""},{"location":"use-cases/multi-storage/#uuid-consistency-validation","title":"UUID Consistency Validation","text":"<pre><code>class ConsistencyValidator:\n    def __init__(self):\n        self.generators = {\n            \"users\": UUIDGenerator(namespace=\"users\"),\n            \"orders\": UUIDGenerator(namespace=\"orders\"),\n            \"products\": UUIDGenerator(namespace=\"products\")\n        }\n\n    def validate_storage_consistency(self, entity_type, identifier):\n        \"\"\"Validate UUID consistency across storage systems\"\"\"\n        expected_uuid = self.generators[entity_type].generate(identifier)\n\n        results = {\n            \"postgres\": self.get_uuid_from_postgres(entity_type, identifier),\n            \"redis\": self.get_uuid_from_redis(entity_type, identifier),\n            \"mongodb\": self.get_uuid_from_mongodb(entity_type, identifier),\n            \"elasticsearch\": self.get_uuid_from_elasticsearch(entity_type, identifier)\n        }\n\n        inconsistencies = []\n        for system, uuid_value in results.items():\n            if uuid_value != expected_uuid:\n                inconsistencies.append({\n                    \"system\": system,\n                    \"expected\": expected_uuid,\n                    \"actual\": uuid_value\n                })\n\n        return {\n            \"consistent\": len(inconsistencies) == 0,\n            \"expected_uuid\": expected_uuid,\n            \"inconsistencies\": inconsistencies\n        }\n</code></pre>"},{"location":"use-cases/multi-storage/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Use Case - Testing strategies with consistent UUIDs</li> <li>Migration Use Case - Data migration patterns</li> <li>Best Practices - Optimization and patterns</li> </ul>"},{"location":"use-cases/testing/","title":"Testing with UUID-Forge","text":"<p>Learn how to leverage deterministic UUIDs for more effective testing strategies.</p>"},{"location":"use-cases/testing/#overview","title":"Overview","text":"<p>Deterministic UUID generation provides significant advantages for testing by making UUIDs predictable and reproducible. This enables more reliable tests, easier debugging, and better test data management.</p>"},{"location":"use-cases/testing/#benefits-for-testing","title":"Benefits for Testing","text":""},{"location":"use-cases/testing/#predictable-test-data","title":"Predictable Test Data","text":"<pre><code>from uuid_forge import UUIDGenerator\n\ndef test_user_creation():\n    \"\"\"Test with predictable UUIDs\"\"\"\n    generator = UUIDGenerator(namespace=\"test-users\")\n\n    # Always generates the same UUID for same input\n    user_id = generator.generate(\"test@example.com\")\n\n    # Test assertions can use exact UUID values\n    assert user_id == \"expected-uuid-value-here\"\n    assert len(user_id) == 36\n</code></pre>"},{"location":"use-cases/testing/#reproducible-test-scenarios","title":"Reproducible Test Scenarios","text":"<pre><code>class TestOrderProcessing:\n    def setUp(self):\n        self.user_gen = UUIDGenerator(namespace=\"test-users\")\n        self.order_gen = UUIDGenerator(namespace=\"test-orders\")\n\n    def test_order_workflow(self):\n        \"\"\"Test complete order workflow with predictable UUIDs\"\"\"\n        # Same UUIDs generated every test run\n        user_id = self.user_gen.generate(\"customer@test.com\")\n        order_data = {\n            \"user_id\": user_id,\n            \"items\": [\"product1\", \"product2\"],\n            \"timestamp\": \"2024-01-15T10:00:00Z\"\n        }\n        order_id = self.order_gen.generate(order_data)\n\n        # Test can rely on specific UUID values\n        assert order_id == self.expected_order_uuid\n        assert user_id == self.expected_user_uuid\n</code></pre>"},{"location":"use-cases/testing/#test-data-management","title":"Test Data Management","text":""},{"location":"use-cases/testing/#fixture-based-testing","title":"Fixture-Based Testing","text":"<pre><code>import pytest\nfrom uuid_forge import UUIDGenerator\n\n@pytest.fixture\ndef test_generators():\n    \"\"\"Provide test UUID generators\"\"\"\n    return {\n        \"users\": UUIDGenerator(namespace=\"test-users\"),\n        \"orders\": UUIDGenerator(namespace=\"test-orders\"),\n        \"products\": UUIDGenerator(namespace=\"test-products\")\n    }\n\n@pytest.fixture\ndef test_users(test_generators):\n    \"\"\"Generate test user data\"\"\"\n    users = [\n        {\"email\": \"user1@test.com\", \"name\": \"User One\"},\n        {\"email\": \"user2@test.com\", \"name\": \"User Two\"},\n        {\"email\": \"user3@test.com\", \"name\": \"User Three\"}\n    ]\n\n    for user in users:\n        user[\"id\"] = test_generators[\"users\"].generate(user[\"email\"])\n\n    return users\n\ndef test_user_processing(test_users):\n    \"\"\"Test using predictable user data\"\"\"\n    assert len(test_users) == 3\n    assert all(user[\"id\"] for user in test_users)\n\n    # UUIDs are deterministic - same every test run\n    expected_first_uuid = test_users[0][\"id\"]\n    assert expected_first_uuid == \"predictable-uuid-for-user1\"\n</code></pre>"},{"location":"use-cases/testing/#database-testing","title":"Database Testing","text":"<pre><code>class TestDatabaseOperations:\n    def setUp(self):\n        self.user_gen = UUIDGenerator(namespace=\"db-test-users\")\n        self.setup_test_database()\n\n    def test_user_crud_operations(self):\n        \"\"\"Test CRUD operations with deterministic UUIDs\"\"\"\n        user_email = \"dbtest@example.com\"\n        user_id = self.user_gen.generate(user_email)\n\n        # Create\n        self.db.create_user(user_id, user_email, \"Test User\")\n\n        # Read\n        stored_user = self.db.get_user(user_id)\n        assert stored_user[\"id\"] == user_id\n        assert stored_user[\"email\"] == user_email\n\n        # Update\n        self.db.update_user(user_id, {\"name\": \"Updated Name\"})\n        updated_user = self.db.get_user(user_id)\n        assert updated_user[\"name\"] == \"Updated Name\"\n\n        # Delete\n        self.db.delete_user(user_id)\n        assert self.db.get_user(user_id) is None\n\n    def test_relationship_integrity(self):\n        \"\"\"Test foreign key relationships\"\"\"\n        user_id = self.user_gen.generate(\"parent@test.com\")\n        order_gen = UUIDGenerator(namespace=\"db-test-orders\")\n\n        # Create parent record\n        self.db.create_user(user_id, \"parent@test.com\", \"Parent User\")\n\n        # Create child record with deterministic UUID\n        order_data = {\"user_id\": user_id, \"total\": 100.00}\n        order_id = order_gen.generate(order_data)\n        self.db.create_order(order_id, user_id, 100.00)\n\n        # Verify relationship\n        user_orders = self.db.get_user_orders(user_id)\n        assert len(user_orders) == 1\n        assert user_orders[0][\"id\"] == order_id\n</code></pre>"},{"location":"use-cases/testing/#integration-testing","title":"Integration Testing","text":""},{"location":"use-cases/testing/#multi-service-testing","title":"Multi-Service Testing","text":"<pre><code>class TestMicroservicesIntegration:\n    def setUp(self):\n        self.user_service = UserService()\n        self.order_service = OrderService()\n        self.notification_service = NotificationService()\n\n        # All services use same UUID generators\n        self.user_gen = UUIDGenerator(namespace=\"integration-users\")\n\n    def test_cross_service_workflow(self):\n        \"\"\"Test workflow spanning multiple services\"\"\"\n        user_email = \"integration@test.com\"\n        user_id = self.user_gen.generate(user_email)\n\n        # Step 1: Create user\n        user = self.user_service.create_user(user_email, \"Test User\")\n        assert user[\"id\"] == user_id\n\n        # Step 2: Create order (should reference same user ID)\n        order = self.order_service.create_order(user_email, [\"item1\", \"item2\"])\n        assert order[\"user_id\"] == user_id\n\n        # Step 3: Send notification (should reference same user ID)\n        notification = self.notification_service.send_order_confirmation(user_email, order[\"id\"])\n        assert notification[\"user_id\"] == user_id\n\n        # All services generated same user ID independently\n        assert user[\"id\"] == order[\"user_id\"] == notification[\"user_id\"]\n</code></pre>"},{"location":"use-cases/testing/#api-testing","title":"API Testing","text":"<pre><code>import requests\nfrom uuid_forge import UUIDGenerator\n\nclass TestAPIEndpoints:\n    def setUp(self):\n        self.base_url = \"http://localhost:8000/api\"\n        self.user_gen = UUIDGenerator(namespace=\"api-test-users\")\n\n    def test_user_api_endpoints(self):\n        \"\"\"Test user API with predictable UUIDs\"\"\"\n        user_email = \"apitest@example.com\"\n        expected_user_id = self.user_gen.generate(user_email)\n\n        # POST /users - Create user\n        create_response = requests.post(\n            f\"{self.base_url}/users\",\n            json={\"email\": user_email, \"name\": \"API Test User\"}\n        )\n        assert create_response.status_code == 201\n        created_user = create_response.json()\n        assert created_user[\"id\"] == expected_user_id\n\n        # GET /users/{id} - Retrieve user\n        get_response = requests.get(f\"{self.base_url}/users/{expected_user_id}\")\n        assert get_response.status_code == 200\n        retrieved_user = get_response.json()\n        assert retrieved_user[\"id\"] == expected_user_id\n        assert retrieved_user[\"email\"] == user_email\n\n        # PUT /users/{id} - Update user\n        update_response = requests.put(\n            f\"{self.base_url}/users/{expected_user_id}\",\n            json={\"name\": \"Updated API User\"}\n        )\n        assert update_response.status_code == 200\n\n        # DELETE /users/{id} - Delete user\n        delete_response = requests.delete(f\"{self.base_url}/users/{expected_user_id}\")\n        assert delete_response.status_code == 204\n</code></pre>"},{"location":"use-cases/testing/#property-based-testing","title":"Property-Based Testing","text":""},{"location":"use-cases/testing/#hypothesis-integration","title":"Hypothesis Integration","text":"<pre><code>from hypothesis import given, strategies as st\nfrom uuid_forge import UUIDGenerator\n\nclass TestUUIDProperties:\n    def setUp(self):\n        self.generator = UUIDGenerator(namespace=\"property-tests\")\n\n    @given(st.text(min_size=1))\n    def test_uuid_format_property(self, input_text):\n        \"\"\"Property: All generated UUIDs have valid format\"\"\"\n        uuid_result = self.generator.generate(input_text)\n\n        # UUID format properties\n        assert len(uuid_result) == 36\n        assert uuid_result.count(\"-\") == 4\n        assert all(c in \"0123456789abcdef-\" for c in uuid_result.lower())\n\n    @given(st.text(min_size=1))\n    def test_determinism_property(self, input_text):\n        \"\"\"Property: Same input always produces same UUID\"\"\"\n        uuid1 = self.generator.generate(input_text)\n        uuid2 = self.generator.generate(input_text)\n\n        assert uuid1 == uuid2\n\n    @given(st.lists(st.text(min_size=1), min_size=2, unique=True))\n    def test_uniqueness_property(self, input_list):\n        \"\"\"Property: Different inputs produce different UUIDs\"\"\"\n        uuids = [self.generator.generate(input_text) for input_text in input_list]\n\n        # All UUIDs should be unique\n        assert len(set(uuids)) == len(uuids)\n</code></pre>"},{"location":"use-cases/testing/#performance-testing","title":"Performance Testing","text":""},{"location":"use-cases/testing/#benchmark-testing","title":"Benchmark Testing","text":"<pre><code>import time\nfrom uuid_forge import UUIDGenerator\n\nclass TestPerformance:\n    def setUp(self):\n        self.generator = UUIDGenerator(namespace=\"perf-tests\")\n        self.test_data = [f\"user{i}@test.com\" for i in range(1000)]\n\n    def test_single_generation_performance(self):\n        \"\"\"Test single UUID generation performance\"\"\"\n        start_time = time.time()\n\n        uuid_result = self.generator.generate(\"performance@test.com\")\n\n        end_time = time.time()\n        generation_time = end_time - start_time\n\n        # Should generate UUID in under 1ms\n        assert generation_time &lt; 0.001\n        assert len(uuid_result) == 36\n\n    def test_batch_generation_performance(self):\n        \"\"\"Test batch UUID generation performance\"\"\"\n        start_time = time.time()\n\n        uuids = [self.generator.generate(email) for email in self.test_data]\n\n        end_time = time.time()\n        total_time = end_time - start_time\n\n        # Should generate 1000 UUIDs in under 100ms\n        assert total_time &lt; 0.1\n        assert len(uuids) == 1000\n        assert len(set(uuids)) == 1000  # All unique\n\n    def test_memory_usage(self):\n        \"\"\"Test memory usage during generation\"\"\"\n        import psutil\n        import os\n\n        process = psutil.Process(os.getpid())\n        initial_memory = process.memory_info().rss\n\n        # Generate many UUIDs\n        large_test_data = [f\"user{i}@test.com\" for i in range(10000)]\n        uuids = [self.generator.generate(email) for email in large_test_data]\n\n        final_memory = process.memory_info().rss\n        memory_increase = final_memory - initial_memory\n\n        # Memory increase should be reasonable (less than 10MB)\n        assert memory_increase &lt; 10 * 1024 * 1024\n        assert len(uuids) == 10000\n</code></pre>"},{"location":"use-cases/testing/#mock-and-stub-testing","title":"Mock and Stub Testing","text":""},{"location":"use-cases/testing/#deterministic-mocking","title":"Deterministic Mocking","text":"<pre><code>from unittest.mock import patch\nfrom uuid_forge import UUIDGenerator\n\nclass TestWithMocking:\n    def setUp(self):\n        self.test_generator = UUIDGenerator(namespace=\"mock-tests\")\n\n    @patch('external_service.get_user_id')\n    def test_external_service_integration(self, mock_get_user_id):\n        \"\"\"Test integration with external service using predictable UUIDs\"\"\"\n        test_email = \"mocktest@example.com\"\n        expected_uuid = self.test_generator.generate(test_email)\n\n        # Mock external service to return deterministic UUID\n        mock_get_user_id.return_value = expected_uuid\n\n        # Test our service\n        result = our_service.process_user(test_email)\n\n        # Verify mock was called correctly\n        mock_get_user_id.assert_called_once_with(test_email)\n        assert result[\"user_id\"] == expected_uuid\n\n    def test_time_dependent_operations(self):\n        \"\"\"Test operations that depend on time using fixed timestamps\"\"\"\n        fixed_timestamp = \"2024-01-15T10:00:00Z\"\n\n        with patch('datetime.datetime') as mock_datetime:\n            mock_datetime.utcnow.return_value.isoformat.return_value = fixed_timestamp\n\n            # Generate UUID with time component\n            time_data = {\n                \"user\": \"timetest@example.com\",\n                \"timestamp\": fixed_timestamp\n            }\n            uuid_result = self.test_generator.generate(time_data)\n\n            # UUID is deterministic because timestamp is fixed\n            assert uuid_result == self.test_generator.generate(time_data)\n</code></pre>"},{"location":"use-cases/testing/#test-environment-management","title":"Test Environment Management","text":""},{"location":"use-cases/testing/#environment-specific-testing","title":"Environment-Specific Testing","text":"<pre><code>import os\nfrom uuid_forge import UUIDGenerator\n\nclass TestEnvironmentConfiguration:\n    def test_development_environment(self):\n        \"\"\"Test development environment configuration\"\"\"\n        os.environ[\"ENVIRONMENT\"] = \"development\"\n        os.environ[\"UUID_NAMESPACE\"] = \"dev-test\"\n\n        generator = UUIDGenerator(namespace=os.environ[\"UUID_NAMESPACE\"])\n        uuid_result = generator.generate(\"devtest@example.com\")\n\n        # Development environment generates consistent test UUIDs\n        assert uuid_result.startswith(\"dev-specific-pattern\")\n\n    def test_production_environment(self):\n        \"\"\"Test production environment configuration\"\"\"\n        os.environ[\"ENVIRONMENT\"] = \"production\"\n        os.environ[\"UUID_NAMESPACE\"] = \"prod\"\n\n        generator = UUIDGenerator(namespace=os.environ[\"UUID_NAMESPACE\"])\n        uuid_result = generator.generate(\"prodtest@example.com\")\n\n        # Production environment uses different namespace\n        assert uuid_result != \"dev-specific-pattern\"\n\n    def tearDown(self):\n        \"\"\"Clean up environment variables\"\"\"\n        if \"ENVIRONMENT\" in os.environ:\n            del os.environ[\"ENVIRONMENT\"]\n        if \"UUID_NAMESPACE\" in os.environ:\n            del os.environ[\"UUID_NAMESPACE\"]\n</code></pre>"},{"location":"use-cases/testing/#continuous-integration-testing","title":"Continuous Integration Testing","text":""},{"location":"use-cases/testing/#cicd-pipeline-testing","title":"CI/CD Pipeline Testing","text":"<pre><code># .github/workflows/test.yml\nname: Test Suite\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n      - uses: actions/checkout@v2\n\n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: \"3.11\"\n\n      - name: Install dependencies\n        run: |\n          pip install uv\n          uv sync --dev\n\n      - name: Run deterministic tests\n        run: |\n          # Run tests multiple times to verify determinism\n          uv run pytest tests/test_deterministic.py\n          uv run pytest tests/test_deterministic.py\n          uv run pytest tests/test_deterministic.py\n\n      - name: Run integration tests\n        run: uv run pytest tests/test_integration.py\n\n      - name: Run performance tests\n        run: uv run pytest tests/test_performance.py\n</code></pre>"},{"location":"use-cases/testing/#next-steps","title":"Next Steps","text":"<ul> <li>Migration Use Case - Data migration with consistent UUIDs</li> <li>Best Practices - Testing optimization strategies</li> <li>Development Guide - Development testing setup</li> </ul>"}]}