{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"UUID-Forge Documentation","text":"<p>Deterministic UUID Generation for Cross-System Coordination</p> <p>Welcome to the UUID-Forge documentation! This library provides a simple, secure way to generate deterministic UUIDs that remain consistent across multiple storage systems without requiring inter-service communication or centralized ID generation.</p>"},{"location":"#what-is-uuid-forge","title":"What is UUID-Forge?","text":"<p>UUID-Forge solves a common problem in microservices and distributed systems: How do you maintain consistent entity identifiers across multiple storage systems?</p> <pre><code>from uuid_forge import generate_uuid_only, IDConfig\nimport os\n\n# Configure once\nconfig = IDConfig(salt=os.getenv(\"UUID_FORGE_SALT\"))\n\n# Generate UUID from business data\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\n# Later, regenerate the exact same UUID - no database needed!\nregenerated = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nassert invoice_uuid == regenerated  # Always True!\n</code></pre>"},{"location":"#core-principle","title":"Core Principle","text":"<p>Same Input + Same Config = Same UUID, Every Time</p> <p>This enables:</p> <ul> <li>\u2705 Zero coordination between services</li> <li>\u2705 Direct access to any storage system</li> <li>\u2705 No lookups required</li> <li>\u2705 Deterministic testing</li> <li>\u2705 Simple architecture</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li> <p>:material-clock-fast:{ .lg .middle } Quick Start</p> <p>Get up and running in minutes with our step-by-step guide.</p> <p>:octicons-arrow-right-24: Quick Start</p> </li> <li> <p>:material-book-open-variant:{ .lg .middle } User Guide</p> <p>Learn core concepts and best practices for production use.</p> <p>:octicons-arrow-right-24: User Guide</p> </li> <li> <p>:material-application-brackets:{ .lg .middle } API Reference</p> <p>Complete API documentation with examples and type signatures.</p> <p>:octicons-arrow-right-24: API Reference</p> </li> <li> <p>:material-code-braces:{ .lg .middle } CLI Reference</p> <p>Command-line interface for generating UUIDs and managing config.</p> <p>:octicons-arrow-right-24: CLI Reference</p> </li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":""},{"location":"#microservices-architecture","title":"Microservices Architecture","text":"<p>Generate consistent IDs across multiple services without coordination:</p> <pre><code># Order Service\norder_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\n# Invoice Service (different codebase, same UUID!)\ninvoice_order_uuid = generate_uuid_only(\"order\", config=config, order_number=12345)\n\nassert order_uuid == invoice_order_uuid\n</code></pre>"},{"location":"#multi-storage-systems","title":"Multi-Storage Systems","text":"<p>Use the same UUID across all your storage layers:</p> <pre><code># Postgres\ndb.execute(\"INSERT INTO invoices (id, ...) VALUES (%s, ...)\", invoice_uuid)\n\n# S3\ns3.put_object(Key=f\"invoices/{invoice_uuid}.pdf\", ...)\n\n# Redis\nredis.set(f\"invoice:{invoice_uuid}\", ...)\n\n# All accessible with the same UUID!\n</code></pre>"},{"location":"#deterministic-testing","title":"Deterministic Testing","text":"<p>Reproduce exact UUIDs in tests for reliable assertions:</p> <pre><code>def test_invoice_processing():\n    test_config = IDConfig(salt=\"test-salt\")\n\n    # Known UUID for assertions\n    expected_uuid = generate_uuid_only(\n        \"invoice\",\n        config=test_config,\n        region=\"EUR\",\n        number=12345\n    )\n\n    # Test your code\n    result = process_invoice(region=\"EUR\", number=12345)\n\n    assert result.id == expected_uuid\n</code></pre>"},{"location":"#why-uuid-forge","title":"Why UUID-Forge?","text":"<p>Traditional approaches to cross-system ID coordination have significant drawbacks:</p> Approach Problems Central ID Service Single point of failure, latency, complexity Database Lookups Performance impact, requires database access ID Mappings Additional storage, synchronization challenges Random UUIDs No reproducibility, requires storage everywhere <p>UUID-Forge eliminates all of these problems with deterministic generation.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd12 Secure: Cryptographic salt prevents UUID prediction</li> <li>\ud83c\udfaf Deterministic: Identical inputs always produce identical UUIDs</li> <li>\ud83d\ude80 Zero Coordination: No inter-service communication needed</li> <li>\ud83d\udce6 Simple API: Functional-first with optional OO wrapper</li> <li>\ud83d\udd27 Production Ready: Type-safe, tested, documented</li> <li>\ud83c\udfa8 CLI Included: First-class command-line interface</li> <li>\ud83d\udc0d Modern Python: Requires Python 3.11+</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># With uv (recommended)\nuv add uuid-forge\n\n# With pip\npip install uuid-forge\n</code></pre> <p>Learn more \u2192</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ol> <li>Install UUID-Forge</li> <li>Follow the Quick Start guide</li> <li>Learn core concepts</li> <li>Explore use cases</li> </ol>"},{"location":"#community-and-support","title":"Community and Support","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> <li>Contributing: Contributing Guide</li> </ul>"},{"location":"#license","title":"License","text":"<p>UUID-Forge is released under the MIT License. See License for details.</p>"},{"location":"api/core/","title":"Core API Reference","text":"<p>This page documents the core UUID generation functionality provided by <code>uuid_forge.core</code>.</p>"},{"location":"api/core/#overview","title":"Overview","text":"<p>The core module provides three main approaches to generating deterministic UUIDs:</p> <ol> <li>Functional API (recommended): Pure functions for UUID generation</li> <li>Object-Oriented API: Class-based wrapper for convenience</li> <li>Utility Functions: Helper functions for salt generation and UUID extraction</li> </ol>"},{"location":"api/core/#configuration","title":"Configuration","text":""},{"location":"api/core/#uuid_forge.core.IDConfig","title":"uuid_forge.core.IDConfig  <code>dataclass</code>","text":"<pre><code>IDConfig(namespace=NAMESPACE_DNS, salt='')\n</code></pre> <p>Configuration for deterministic UUID generation.</p> <p>This configuration ensures consistent UUID generation across different services and deployments. The namespace provides logical separation between different entity types or applications, while the salt adds security by preventing UUID prediction attacks.</p> <p>Attributes:</p> Name Type Description <code>namespace</code> <code>UUID</code> <p>UUID namespace for generation. Defaults to DNS-based namespace. Use uuid.uuid5(uuid.NAMESPACE_DNS, \"your-domain.com\") for custom namespaces.</p> <code>salt</code> <code>str</code> <p>Random salt for security. CRITICAL: Keep this secret! Generate once per deployment and store securely in environment variables. Without a salt, UUIDs are predictable, which may be a security risk.</p> Example <pre><code>import uuid\nfrom uuid_forge.core import IDConfig\n\n# Production config with salt\nconfig = IDConfig(\n    namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n    salt=\"xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\"\n)\n</code></pre> <p>Methods:</p> Name Description <code>__post_init__</code> <p>Validate configuration after initialization.</p>"},{"location":"api/core/#uuid_forge.core.IDConfig-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.IDConfig.__post_init__","title":"__post_init__","text":"<pre><code>__post_init__()\n</code></pre> <p>Validate configuration after initialization.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __post_init__(self) -&gt; None:\n    \"\"\"Validate configuration after initialization.\"\"\"\n    if not isinstance(self.namespace, uuid_module.UUID):\n        raise TypeError(\n            f\"namespace must be a UUID, got {type(self.namespace).__name__}\"\n        )\n</code></pre>"},{"location":"api/core/#primary-functions","title":"Primary Functions","text":""},{"location":"api/core/#generate_uuid_only","title":"generate_uuid_only","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_only","title":"uuid_forge.core.generate_uuid_only","text":"<pre><code>generate_uuid_only(entity_type, *args, config=None, **kwargs)\n</code></pre> <p>Generate a deterministic UUID from entity type and business data.</p> <p>This is the core function for generating idempotent UUIDs. Given the same inputs and configuration, it will always produce the same UUID. This enables zero-coordination ID generation across multiple services and storage systems.</p> <p>The function uses UUIDv5 (name-based, SHA-1) for deterministic generation, with an optional salt for security. The entity_type provides logical separation between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\"). This provides namespace separation between different entity types.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID. Can be any serializable data that uniquely identifies the entity.</p> <code>()</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt). IMPORTANT: In production, always provide a config with a salt for security.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID. Keys are sorted alphabetically to ensure consistency regardless of argument order.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID that will be identical for the same inputs and config.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\nimport uuid\nimport os\n\n# Production usage with config\nconfig = IDConfig(\n    namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n    salt=os.getenv(\"UUID_SALT\", \"\")\n)\n\n# Generate UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\n# Later, regenerate the same UUID from business data\nregenerated = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    invoice_number=12345,\n    config=config\n)\n\nassert invoice_uuid == regenerated  # Always the same!\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_only(\n    entity_type: str,\n    *args: Any,\n    config: IDConfig | None = None,\n    **kwargs: Any\n) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID from entity type and business data.\n\n    This is the core function for generating idempotent UUIDs. Given the same\n    inputs and configuration, it will always produce the same UUID. This enables\n    zero-coordination ID generation across multiple services and storage systems.\n\n    The function uses UUIDv5 (name-based, SHA-1) for deterministic generation,\n    with an optional salt for security. The entity_type provides logical separation\n    between different kinds of entities (e.g., \"invoice\", \"order\", \"user\").\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n            This provides namespace separation between different entity types.\n        *args: Positional arguments contributing to the UUID. Can be any\n            serializable data that uniquely identifies the entity.\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt). IMPORTANT: In production,\n            always provide a config with a salt for security.\n        **kwargs: Keyword arguments contributing to the UUID. Keys are sorted\n            alphabetically to ensure consistency regardless of argument order.\n\n    Returns:\n        A deterministic UUID that will be identical for the same inputs and config.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_only, IDConfig\n        import uuid\n        import os\n\n        # Production usage with config\n        config = IDConfig(\n            namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n            salt=os.getenv(\"UUID_SALT\", \"\")\n        )\n\n        # Generate UUID for an invoice\n        invoice_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        # Later, regenerate the same UUID from business data\n        regenerated = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            invoice_number=12345,\n            config=config\n        )\n\n        assert invoice_uuid == regenerated  # Always the same!\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; from uuid_forge.core import generate_uuid_only, IDConfig\n    &gt;&gt;&gt; import uuid\n    &gt;&gt;&gt; # Test basic generation\n    &gt;&gt;&gt; uuid1 = generate_uuid_only(\"test\", key=\"value\")\n    &gt;&gt;&gt; assert isinstance(uuid1, uuid.UUID)\n    &gt;&gt;&gt; # Test idempotency\n    &gt;&gt;&gt; uuid2 = generate_uuid_only(\"test\", key=\"value\")\n    &gt;&gt;&gt; assert uuid1 == uuid2, \"Same inputs should produce same UUID\"\n    &gt;&gt;&gt; # Test with different inputs\n    &gt;&gt;&gt; uuid3 = generate_uuid_only(\"test\", key=\"other\")\n    &gt;&gt;&gt; assert uuid1 != uuid3, \"Different inputs should produce different UUIDs\"\n    &gt;&gt;&gt; # Test with config\n    &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n    &gt;&gt;&gt; uuid4 = generate_uuid_only(\"test\", key=\"value\", config=config)\n    &gt;&gt;&gt; uuid5 = generate_uuid_only(\"test\", key=\"value\", config=config)\n    &gt;&gt;&gt; assert uuid4 == uuid5, \"Same config should produce same UUID\"\n    &gt;&gt;&gt; # Test that different config produces different UUID\n    &gt;&gt;&gt; uuid6 = generate_uuid_only(\"test\", key=\"value\")\n    &gt;&gt;&gt; assert uuid4 != uuid6, \"Different config should produce different UUID\"\n    &gt;&gt;&gt; # Test kwargs order doesn't matter\n    &gt;&gt;&gt; uuid7 = generate_uuid_only(\"test\", a=1, b=2)\n    &gt;&gt;&gt; uuid8 = generate_uuid_only(\"test\", b=2, a=1)\n    &gt;&gt;&gt; assert uuid7 == uuid8, \"Kwargs order shouldn't matter\"\n    --&gt;\n    \"\"\"\n    if config is None:\n        config = IDConfig()\n    elif not isinstance(config, IDConfig):\n        raise TypeError(f\"config must be IDConfig, got {type(config).__name__}\")\n\n    # Build the name string from entity type, salt, and normalized inputs\n    parts = [entity_type]\n\n    if config.salt:\n        parts.append(f\"salt:{config.salt}\")\n\n    normalized = _normalize_input(*args, **kwargs)\n    if normalized:\n        parts.append(normalized)\n\n    name = \"|\".join(parts)\n\n    # Generate deterministic UUID\n    return uuid_module.uuid5(config.namespace, name)\n</code></pre>"},{"location":"api/core/#generate_uuid_with_prefix","title":"generate_uuid_with_prefix","text":""},{"location":"api/core/#uuid_forge.core.generate_uuid_with_prefix","title":"uuid_forge.core.generate_uuid_with_prefix","text":"<pre><code>generate_uuid_with_prefix(\n    entity_type, *args, prefix=None, separator=\"-\", config=None, **kwargs\n)\n</code></pre> <p>Generate a deterministic UUID with an optional human-readable prefix.</p> <p>This function extends generate_uuid_only by adding a human-readable prefix to the UUID. The prefix can be useful for: - Quick visual identification of entity types (e.g., \"INV-\" for invoices) - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices) - Making logs and debugging more human-friendly</p> <p>The prefix does NOT affect the UUID generation - it's purely cosmetic. The same business data will always produce the same UUID, regardless of prefix used.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified (e.g., \"invoice\", \"order\").</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID. If None, only the UUID is returned (as a string). Can include business context like region codes, year, or entity type abbreviations.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default config.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,</p> <code>str</code> <p>or just \"{uuid}\" if prefix is None.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If config is provided but is not an IDConfig instance.</p> Example <pre><code>from uuid_forge.core import generate_uuid_with_prefix, IDConfig\nimport os\n\nconfig = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n# With prefix\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Without prefix (just UUID as string)\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n# Custom separator\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    separator=\"_\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_uuid_with_prefix(\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    config: IDConfig | None = None,\n    **kwargs: Any\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with an optional human-readable prefix.\n\n    This function extends generate_uuid_only by adding a human-readable prefix\n    to the UUID. The prefix can be useful for:\n    - Quick visual identification of entity types (e.g., \"INV-\" for invoices)\n    - Including business context (e.g., \"EUR-2024-\" for European 2024 invoices)\n    - Making logs and debugging more human-friendly\n\n    The prefix does NOT affect the UUID generation - it's purely cosmetic.\n    The same business data will always produce the same UUID, regardless of\n    prefix used.\n\n    Args:\n        entity_type: Type of entity being identified (e.g., \"invoice\", \"order\").\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID. If None, only\n            the UUID is returned (as a string). Can include business context\n            like region codes, year, or entity type abbreviations.\n        separator: Character(s) to use between prefix and UUID. Default is \"-\".\n        config: Configuration for UUID generation. If None, uses default config.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string in the format \"{prefix}{separator}{uuid}\" if prefix is provided,\n        or just \"{uuid}\" if prefix is None.\n\n    Raises:\n        TypeError: If config is provided but is not an IDConfig instance.\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n        import os\n\n        config = IDConfig(salt=os.getenv(\"UUID_SALT\", \"\"))\n\n        # With prefix\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Without prefix (just UUID as string)\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"550e8400-e29b-41d4-a716-446655440000\"\n\n        # Custom separator\n        invoice_id = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV\",\n            separator=\"_\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV_550e8400-e29b-41d4-a716-446655440000\"\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; from uuid_forge.core import generate_uuid_with_prefix, IDConfig\n    &gt;&gt;&gt; # Test without prefix\n    &gt;&gt;&gt; id1 = generate_uuid_with_prefix(\"test\", key=\"value\")\n    &gt;&gt;&gt; assert \"-\" in id1  # Should be a UUID string\n    &gt;&gt;&gt; assert not id1.startswith(\"test\")  # No prefix\n    &gt;&gt;&gt; # Test with prefix\n    &gt;&gt;&gt; id2 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n    &gt;&gt;&gt; assert id2.startswith(\"TST-\"), f\"Should start with prefix, got {id2}\"\n    &gt;&gt;&gt; # Test idempotency with prefix\n    &gt;&gt;&gt; id3 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n    &gt;&gt;&gt; assert id2 == id3, \"Same inputs should produce same result\"\n    &gt;&gt;&gt; # Test that different prefixes don't change UUID part\n    &gt;&gt;&gt; id4 = generate_uuid_with_prefix(\"test\", prefix=\"OTHER\", key=\"value\")\n    &gt;&gt;&gt; uuid_part_2 = id2.split(\"-\", 1)[1]\n    &gt;&gt;&gt; uuid_part_4 = id4.split(\"-\", 1)[1]\n    &gt;&gt;&gt; assert uuid_part_2 == uuid_part_4, \"UUID should be same regardless of prefix\"\n    &gt;&gt;&gt; # Test custom separator\n    &gt;&gt;&gt; id5 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n    &gt;&gt;&gt; assert id5.startswith(\"TST_\"), \"Should use custom separator\"\n    &gt;&gt;&gt; # Test with config\n    &gt;&gt;&gt; config = IDConfig(salt=\"test-salt\")\n    &gt;&gt;&gt; id6 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n    &gt;&gt;&gt; id7 = generate_uuid_with_prefix(\"test\", prefix=\"TST\", config=config, key=\"value\")\n    &gt;&gt;&gt; assert id6 == id7, \"Config should be applied consistently\"\n    --&gt;\n    \"\"\"\n    generated_uuid = generate_uuid_only(entity_type, *args, config=config, **kwargs)\n    uuid_str = str(generated_uuid)\n\n    if prefix:\n        return f\"{prefix}{separator}{uuid_str}\"\n    return uuid_str\n</code></pre>"},{"location":"api/core/#extract_uuid_from_prefixed","title":"extract_uuid_from_prefixed","text":""},{"location":"api/core/#uuid_forge.core.extract_uuid_from_prefixed","title":"uuid_forge.core.extract_uuid_from_prefixed","text":"<pre><code>extract_uuid_from_prefixed(prefixed_id, separator='-')\n</code></pre> <p>Extract the UUID from a prefixed identifier.</p> <p>This function parses a prefixed identifier string (created with generate_uuid_with_prefix) and extracts just the UUID portion. It intelligently handles both prefixed and non-prefixed UUIDs.</p> <p>Parameters:</p> Name Type Description Default <code>prefixed_id</code> <code>str</code> <p>The prefixed identifier string. Can be either: - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\" - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"</p> required <code>separator</code> <code>str</code> <p>The separator used between prefix and UUID. Default is \"-\".</p> <code>'-'</code> <p>Returns:</p> Type Description <code>UUID</code> <p>The extracted UUID object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If no valid UUID can be found in the input string.</p> Example <pre><code>from uuid_forge.core import (\n    generate_uuid_with_prefix,\n    extract_uuid_from_prefixed,\n    IDConfig\n)\n\nconfig = IDConfig(salt=\"my-secret-salt\")\n\n# Generate a prefixed ID\nprefixed = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n# Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Extract the UUID\nextracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n# Regenerate from business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    region=\"EUR\",\n    number=12345,\n    config=config\n)\n\nassert extracted_uuid == regenerated_uuid\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def extract_uuid_from_prefixed(\n    prefixed_id: str,\n    separator: str = \"-\"\n) -&gt; uuid_module.UUID:\n    \"\"\"Extract the UUID from a prefixed identifier.\n\n    This function parses a prefixed identifier string (created with\n    generate_uuid_with_prefix) and extracts just the UUID portion.\n    It intelligently handles both prefixed and non-prefixed UUIDs.\n\n    Args:\n        prefixed_id: The prefixed identifier string. Can be either:\n            - A prefixed UUID: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n            - A plain UUID: \"550e8400-e29b-41d4-a716-446655440000\"\n        separator: The separator used between prefix and UUID. Default is \"-\".\n\n    Returns:\n        The extracted UUID object.\n\n    Raises:\n        ValueError: If no valid UUID can be found in the input string.\n\n    Example:\n        ```python\n        from uuid_forge.core import (\n            generate_uuid_with_prefix,\n            extract_uuid_from_prefixed,\n            IDConfig\n        )\n\n        config = IDConfig(salt=\"my-secret-salt\")\n\n        # Generate a prefixed ID\n        prefixed = generate_uuid_with_prefix(\n            \"invoice\",\n            prefix=\"INV-EUR\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n        # Result: \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n        # Extract the UUID\n        extracted_uuid = extract_uuid_from_prefixed(prefixed)\n\n        # Regenerate from business data\n        regenerated_uuid = generate_uuid_only(\n            \"invoice\",\n            region=\"EUR\",\n            number=12345,\n            config=config\n        )\n\n        assert extracted_uuid == regenerated_uuid\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; from uuid_forge.core import (\n    ...     generate_uuid_with_prefix,\n    ...     extract_uuid_from_prefixed,\n    ...     generate_uuid_only\n    ... )\n    &gt;&gt;&gt; import uuid\n    &gt;&gt;&gt; # Test with prefixed UUID\n    &gt;&gt;&gt; prefixed = generate_uuid_with_prefix(\"test\", prefix=\"TST\", key=\"value\")\n    &gt;&gt;&gt; extracted = extract_uuid_from_prefixed(prefixed)\n    &gt;&gt;&gt; assert isinstance(extracted, uuid.UUID)\n    &gt;&gt;&gt; # Verify extracted UUID matches original\n    &gt;&gt;&gt; original = generate_uuid_only(\"test\", key=\"value\")\n    &gt;&gt;&gt; assert extracted == original\n    &gt;&gt;&gt; # Test with plain UUID string\n    &gt;&gt;&gt; plain_uuid = str(generate_uuid_only(\"test\", key=\"other\"))\n    &gt;&gt;&gt; extracted2 = extract_uuid_from_prefixed(plain_uuid)\n    &gt;&gt;&gt; assert isinstance(extracted2, uuid.UUID)\n    &gt;&gt;&gt; assert str(extracted2) == plain_uuid\n    &gt;&gt;&gt; # Test with custom separator\n    &gt;&gt;&gt; prefixed_custom = generate_uuid_with_prefix(\"test\", prefix=\"TST\", separator=\"_\", key=\"value\")\n    &gt;&gt;&gt; extracted3 = extract_uuid_from_prefixed(prefixed_custom, separator=\"_\")\n    &gt;&gt;&gt; assert extracted3 == original\n    &gt;&gt;&gt; # Test with invalid input\n    &gt;&gt;&gt; try:\n    ...     extract_uuid_from_prefixed(\"not-a-uuid\")\n    ...     assert False, \"Should raise ValueError\"\n    ... except ValueError as e:\n    ...     assert \"No valid UUID found\" in str(e)\n    --&gt;\n    \"\"\"\n    # Split by separator and try to find UUID pattern\n    parts = prefixed_id.split(separator)\n\n    # Try each part from the end (UUID is typically at the end)\n    for i in range(len(parts)):\n        # Join remaining parts in case UUID has dashes\n        potential_uuid = separator.join(parts[i:])\n        try:\n            return uuid_module.UUID(potential_uuid)\n        except ValueError:\n            continue\n\n    raise ValueError(f\"No valid UUID found in '{prefixed_id}'\")\n</code></pre>"},{"location":"api/core/#utility-functions","title":"Utility Functions","text":""},{"location":"api/core/#generate_salt","title":"generate_salt","text":""},{"location":"api/core/#uuid_forge.core.generate_salt","title":"uuid_forge.core.generate_salt","text":"<pre><code>generate_salt(length=32)\n</code></pre> <p>Generate a cryptographically secure random salt for UUID generation.</p> <p>This function creates a URL-safe, base64-encoded random string suitable for use as a salt in IDConfig. The salt should be generated once per deployment and stored securely in environment variables.</p> <p>Parameters:</p> Name Type Description Default <code>length</code> <code>int</code> <p>Length of the generated salt in bytes. Default is 32 bytes, which produces a 43-character base64 string.</p> <code>32</code> <p>Returns:</p> Type Description <code>str</code> <p>A URL-safe base64-encoded string suitable for use as a salt.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If length is less than 16 bytes (minimum recommended).</p> Example <pre><code>from uuid_forge.core import generate_salt\n\n# Generate a new salt for your deployment\nsalt = generate_salt()\nprint(f\"Add this to your .env file: UUID_SALT={salt}\")\n</code></pre> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_salt(length: int = 32) -&gt; str:\n    \"\"\"Generate a cryptographically secure random salt for UUID generation.\n\n    This function creates a URL-safe, base64-encoded random string suitable\n    for use as a salt in IDConfig. The salt should be generated once per\n    deployment and stored securely in environment variables.\n\n    Args:\n        length: Length of the generated salt in bytes. Default is 32 bytes,\n            which produces a 43-character base64 string.\n\n    Returns:\n        A URL-safe base64-encoded string suitable for use as a salt.\n\n    Raises:\n        ValueError: If length is less than 16 bytes (minimum recommended).\n\n    Example:\n        ```python\n        from uuid_forge.core import generate_salt\n\n        # Generate a new salt for your deployment\n        salt = generate_salt()\n        print(f\"Add this to your .env file: UUID_SALT={salt}\")\n        ```\n\n    &lt;!-- Example Test:\n    &gt;&gt;&gt; from uuid_forge.core import generate_salt\n    &gt;&gt;&gt; salt = generate_salt()\n    &gt;&gt;&gt; assert isinstance(salt, str)\n    &gt;&gt;&gt; assert len(salt) &gt; 0\n    &gt;&gt;&gt; # Test different lengths\n    &gt;&gt;&gt; salt_16 = generate_salt(16)\n    &gt;&gt;&gt; salt_64 = generate_salt(64)\n    &gt;&gt;&gt; assert len(salt_16) &lt; len(salt_64)\n    &gt;&gt;&gt; # Test minimum length validation\n    &gt;&gt;&gt; try:\n    ...     generate_salt(15)\n    ...     assert False, \"Should raise ValueError for length &lt; 16\"\n    ... except ValueError as e:\n    ...     assert \"at least 16 bytes\" in str(e)\n    --&gt;\n    \"\"\"\n    if length &lt; 16:\n        raise ValueError(\n            f\"Salt length must be at least 16 bytes for security, got {length}\"\n        )\n\n    return secrets.token_urlsafe(length)\n</code></pre>"},{"location":"api/core/#object-oriented-api","title":"Object-Oriented API","text":""},{"location":"api/core/#uuidgenerator","title":"UUIDGenerator","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator","title":"uuid_forge.core.UUIDGenerator","text":"<pre><code>UUIDGenerator(config=None)\n</code></pre> <p>Object-oriented convenience wrapper for UUID generation.</p> <p>This class provides a stateful interface for UUID generation, holding a configuration that's applied to all generated UUIDs. This is useful when you're generating many UUIDs with the same configuration, as it reduces boilerplate and ensures consistency.</p> <p>The functional API (generate_uuid_only, generate_uuid_with_prefix) is recommended for most use cases. Use this class when you need: - Multiple UUIDs with the same configuration - Encapsulation of configuration in a service/repository - Dependency injection patterns</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>The IDConfig used for all UUID generation operations.</p> Example <pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\nimport uuid\nimport os\n\n# Create generator with production config\ngenerator = UUIDGenerator(\n    config=IDConfig(\n        namespace=uuid.uuid5(uuid.NAMESPACE_DNS, \"mycompany.com\"),\n        salt=os.getenv(\"UUID_SALT\", \"\")\n    )\n)\n\n# Generate multiple UUIDs with same config\ninvoice_uuid = generator.generate(\"invoice\", region=\"EUR\", number=123)\norder_uuid = generator.generate(\"order\", customer_id=456)\n\n# With prefixes\nprefixed_invoice = generator.generate_with_prefix(\n    \"invoice\",\n    prefix=\"INV\",\n    region=\"EUR\",\n    number=123\n)\n</code></pre> <p>Initialize the UUID generator with a configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>IDConfig | None</code> <p>Configuration for UUID generation. If None, uses default configuration (DNS namespace, no salt).</p> <code>None</code> <p>Methods:</p> Name Description <code>generate</code> <p>Generate a deterministic UUID using this generator's configuration.</p> <code>generate_with_prefix</code> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __init__(self, config: IDConfig | None = None) -&gt; None:\n    \"\"\"Initialize the UUID generator with a configuration.\n\n    Args:\n        config: Configuration for UUID generation. If None, uses default\n            configuration (DNS namespace, no salt).\n    \"\"\"\n    self.config = config or IDConfig()\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate","title":"generate","text":"<pre><code>generate(entity_type, *args, **kwargs)\n</code></pre> <p>Generate a deterministic UUID using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_only with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>UUID</code> <p>A deterministic UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate(\n    self,\n    entity_type: str,\n    *args: Any,\n    **kwargs: Any\n) -&gt; uuid_module.UUID:\n    \"\"\"Generate a deterministic UUID using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_only with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A deterministic UUID.\n    \"\"\"\n    return generate_uuid_only(entity_type, *args, config=self.config, **kwargs)\n</code></pre>"},{"location":"api/core/#uuid_forge.core.UUIDGenerator.generate_with_prefix","title":"generate_with_prefix","text":"<pre><code>generate_with_prefix(entity_type, *args, prefix=None, separator='-', **kwargs)\n</code></pre> <p>Generate a deterministic UUID with prefix using this generator's configuration.</p> <p>This is a convenience method that calls generate_uuid_with_prefix with the generator's stored configuration.</p> <p>Parameters:</p> Name Type Description Default <code>entity_type</code> <code>str</code> <p>Type of entity being identified.</p> required <code>*args</code> <code>Any</code> <p>Positional arguments contributing to the UUID.</p> <code>()</code> <code>prefix</code> <code>str | None</code> <p>Human-readable prefix to prepend to the UUID.</p> <code>None</code> <code>separator</code> <code>str</code> <p>Character(s) to use between prefix and UUID.</p> <code>'-'</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments contributing to the UUID.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>A string with optional prefix and UUID.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def generate_with_prefix(\n    self,\n    entity_type: str,\n    *args: Any,\n    prefix: str | None = None,\n    separator: str = \"-\",\n    **kwargs: Any\n) -&gt; str:\n    \"\"\"Generate a deterministic UUID with prefix using this generator's configuration.\n\n    This is a convenience method that calls generate_uuid_with_prefix with the\n    generator's stored configuration.\n\n    Args:\n        entity_type: Type of entity being identified.\n        *args: Positional arguments contributing to the UUID.\n        prefix: Human-readable prefix to prepend to the UUID.\n        separator: Character(s) to use between prefix and UUID.\n        **kwargs: Keyword arguments contributing to the UUID.\n\n    Returns:\n        A string with optional prefix and UUID.\n    \"\"\"\n    return generate_uuid_with_prefix(\n        entity_type,\n        *args,\n        prefix=prefix,\n        separator=separator,\n        config=self.config,\n        **kwargs\n    )\n</code></pre>"},{"location":"api/core/#protocols","title":"Protocols","text":""},{"location":"api/core/#representable","title":"Representable","text":""},{"location":"api/core/#uuid_forge.core.Representable","title":"uuid_forge.core.Representable","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for objects that can be represented as strings.</p> <p>Any object implementing repr satisfies this protocol and can be used directly with UUID generation functions.</p> <p>Methods:</p> Name Description <code>__repr__</code> <p>Return string representation of object.</p>"},{"location":"api/core/#uuid_forge.core.Representable-functions","title":"Functions","text":""},{"location":"api/core/#uuid_forge.core.Representable.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return string representation of object.</p> Source code in <code>src/uuid_forge/core.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return string representation of object.\"\"\"\n    ...\n</code></pre>"},{"location":"api/core/#usage-examples","title":"Usage Examples","text":""},{"location":"api/core/#basic-uuid-generation","title":"Basic UUID Generation","text":"<pre><code>from uuid_forge.core import generate_uuid_only, IDConfig\n\n# Create configuration\nconfig = IDConfig(salt=\"production-secret-salt\")\n\n# Generate UUID\nuser_uuid = generate_uuid_only(\n    \"user\",\n    config=config,\n    email=\"alice@example.com\"\n)\n\nprint(user_uuid)  # UUID object\n</code></pre>"},{"location":"api/core/#with-human-readable-prefix","title":"With Human-Readable Prefix","text":"<pre><code>from uuid_forge.core import generate_uuid_with_prefix\n\n# Generate prefixed ID\ninvoice_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    number=12345\n)\n\nprint(invoice_id)  # \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n</code></pre>"},{"location":"api/core/#using-the-oo-api","title":"Using the OO API","text":"<pre><code>from uuid_forge.core import UUIDGenerator, IDConfig\n\n# Create generator with configuration\ngenerator = UUIDGenerator(\n    config=IDConfig(salt=\"production-secret-salt\")\n)\n\n# Generate multiple UUIDs with same config\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\n</code></pre>"},{"location":"api/core/#extracting-uuids","title":"Extracting UUIDs","text":"<pre><code>from uuid_forge.core import extract_uuid_from_prefixed\n\n# Extract UUID from prefixed string\nprefixed = \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\nuuid = extract_uuid_from_prefixed(prefixed)\n\nprint(uuid)  # UUID('550e8400-e29b-41d4-a716-446655440000')\n</code></pre>"},{"location":"api/core/#type-information","title":"Type Information","text":"<p>All functions in the core module are fully typed. Import types for type hints:</p> <pre><code>from uuid import UUID\nfrom uuid_forge.core import IDConfig, Representable\nfrom typing import Optional\n\ndef process_entity(\n    entity_type: str,\n    config: Optional[IDConfig] = None,\n    **kwargs: Any\n) -&gt; UUID:\n    return generate_uuid_only(entity_type, config=config, **kwargs)\n</code></pre>"},{"location":"api/core/#thread-safety","title":"Thread Safety","text":"<p>All functions in the core module are thread-safe. They have no shared mutable state and can be called concurrently from multiple threads.</p>"},{"location":"api/core/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>UUID generation is fast: ~10 microseconds per call</li> <li>No I/O operations are performed</li> <li>Memory usage is minimal (&lt; 1KB per call)</li> <li>Consider caching UUIDs if generating millions per second</li> </ul>"},{"location":"api/core/#security-notes","title":"Security Notes","text":"<p>Always Use a Salt in Production</p> <p>Without a salt, UUIDs are predictable and may pose a security risk. Always configure a cryptographic salt using <code>generate_salt()</code>.</p> <p>Keep Your Salt Secret</p> <p>The salt is effectively a secret key. Anyone with your salt can predict your UUIDs. Store it securely:</p> <ul> <li>Environment variables</li> <li>Secret management systems (AWS Secrets Manager, Vault, etc.)</li> <li>Never commit to version control</li> </ul>"},{"location":"api/core/#see-also","title":"See Also","text":"<ul> <li>Configuration API - Loading configuration from environment</li> <li>CLI Reference - Command-line interface</li> <li>Best Practices - Production guidelines</li> </ul>"},{"location":"gettting-started/quickstart/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with UUID-Forge in under 5 minutes.</p>"},{"location":"gettting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or higher</li> <li>Basic understanding of UUIDs</li> <li>A text editor or IDE</li> </ul>"},{"location":"gettting-started/quickstart/#step-1-installation","title":"Step 1: Installation","text":"<p>Install UUID-Forge using your preferred package manager:</p> uv (recommended)pippoetry <pre><code>uv add uuid-forge\n</code></pre> <pre><code>pip install uuid-forge\n</code></pre> <pre><code>poetry add uuid-forge\n</code></pre>"},{"location":"gettting-started/quickstart/#step-2-generate-a-salt","title":"Step 2: Generate a Salt","text":"<p>Security first! Generate a cryptographic salt for production use:</p> <pre><code>uuid-forge new-salt\n</code></pre> <p>This will output something like:</p> <pre><code>xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB\n</code></pre> <p>Keep This Secret!</p> <p>Store this salt securely and never commit it to version control.</p>"},{"location":"gettting-started/quickstart/#set-environment-variable","title":"Set Environment Variable","text":"<p>Add the salt to your environment:</p> <pre><code>export UUID_FORGE_SALT='xvW9Kz_kRzPmNqYvTaWcXdYeFgZhAiB'\n</code></pre> <p>Or create a <code>.env</code> file:</p> <pre><code>uuid-forge init\n</code></pre> <p>This creates a <code>.env</code> file with a generated salt and usage instructions.</p>"},{"location":"gettting-started/quickstart/#step-3-your-first-uuid","title":"Step 3: Your First UUID","text":"<p>Create a Python file <code>example.py</code>:</p> <pre><code>from uuid_forge import generate_uuid_only, load_config_from_env\n\n# Load configuration from environment\nconfig = load_config_from_env()\n\n# Generate a deterministic UUID for an invoice\ninvoice_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(f\"Invoice UUID: {invoice_uuid}\")\n</code></pre> <p>Run it:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"gettting-started/quickstart/#step-4-verify-idempotency","title":"Step 4: Verify Idempotency","text":"<p>The magic of UUID-Forge is that the same inputs always produce the same UUID. Add this to your script:</p> <pre><code># Regenerate the UUID from the same business data\nregenerated_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\n# They're identical!\nassert invoice_uuid == regenerated_uuid\nprint(\"\u2713 UUIDs are identical!\")\n</code></pre> <p>Run again:</p> <pre><code>python example.py\n</code></pre> <p>Output:</p> <pre><code>Invoice UUID: 550e8400-e29b-41d4-a716-446655440000\n\u2713 UUIDs are identical!\n</code></pre>"},{"location":"gettting-started/quickstart/#step-5-use-across-systems","title":"Step 5: Use Across Systems","text":"<p>Now use this UUID consistently across all your storage systems:</p> <pre><code>import psycopg2\nimport boto3\nimport redis\n\n# Database - Primary key\ndb = psycopg2.connect(\"...\")\ncursor = db.cursor()\ncursor.execute(\n    \"INSERT INTO invoices (id, region, number, amount) VALUES (%s, %s, %s, %s)\",\n    (invoice_uuid, \"EUR\", 12345, 1500.50)\n)\n\n# S3 - Object storage\ns3 = boto3.client('s3')\ns3.put_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{invoice_uuid}.pdf',\n    Body=pdf_data\n)\n\n# Redis - Cache\nr = redis.Redis()\nr.setex(\n    f'invoice:{invoice_uuid}',\n    3600,  # 1 hour TTL\n    json.dumps({'region': 'EUR', 'number': 12345})\n)\n\nprint(f\"\u2713 Stored invoice {invoice_uuid} in Postgres, S3, and Redis\")\n</code></pre>"},{"location":"gettting-started/quickstart/#step-6-retrieve-without-lookups","title":"Step 6: Retrieve Without Lookups","text":"<p>The real power: retrieve from any system without database lookups!</p> <pre><code># User requests invoice by business data\nrequested_region = \"EUR\"\nrequested_number = 12345\n\n# Regenerate UUID from business data (no database query!)\nlookup_uuid = generate_uuid_only(\n    \"invoice\",\n    config=config,\n    region=requested_region,\n    invoice_number=requested_number\n)\n\n# Now access any storage system directly\npdf_data = s3.get_object(\n    Bucket='invoices',\n    Key=f'invoices/2024/EUR/{lookup_uuid}.pdf'\n)\n\ncached_data = r.get(f'invoice:{lookup_uuid}')\n\ndb_record = cursor.execute(\n    \"SELECT * FROM invoices WHERE id = %s\",\n    (lookup_uuid,)\n).fetchone()\n\nprint(\"\u2713 Retrieved from all systems without any UUID lookups!\")\n</code></pre>"},{"location":"gettting-started/quickstart/#common-patterns","title":"Common Patterns","text":""},{"location":"gettting-started/quickstart/#pattern-1-with-prefixes-for-human-readability","title":"Pattern 1: With Prefixes for Human Readability","text":"<pre><code>from uuid_forge import generate_uuid_with_prefix\n\n# Generate with prefix\nprefixed_id = generate_uuid_with_prefix(\n    \"invoice\",\n    prefix=\"INV-EUR\",\n    config=config,\n    region=\"EUR\",\n    invoice_number=12345\n)\n\nprint(prefixed_id)\n# Output: INV-EUR-550e8400-e29b-41d4-a716-446655440000\n</code></pre>"},{"location":"gettting-started/quickstart/#pattern-2-using-the-oo-api","title":"Pattern 2: Using the OO API","text":"<pre><code>from uuid_forge import UUIDGenerator\n\n# Create generator once\ngenerator = UUIDGenerator(config=config)\n\n# Generate multiple UUIDs\norder_uuid = generator.generate(\"order\", order_number=123)\ninvoice_uuid = generator.generate(\"invoice\", order_id=str(order_uuid))\nshipment_uuid = generator.generate(\"shipment\", order_id=str(order_uuid))\n</code></pre>"},{"location":"gettting-started/quickstart/#pattern-3-different-entity-types","title":"Pattern 3: Different Entity Types","text":"<pre><code># Each entity type has its own UUID space\nuser_uuid = generate_uuid_only(\"user\", config=config, email=\"alice@example.com\")\norder_uuid = generate_uuid_only(\"order\", config=config, user_id=str(user_uuid), number=123)\ninvoice_uuid = generate_uuid_only(\"invoice\", config=config, order_id=str(order_uuid))\n\n# Same business data, different entity types = different UUIDs\nassert user_uuid != order_uuid != invoice_uuid\n</code></pre>"},{"location":"gettting-started/quickstart/#cli-usage","title":"CLI Usage","text":"<p>UUID-Forge includes a powerful CLI for quick UUID generation:</p> <pre><code># Generate UUID\nuuid-forge generate invoice --attr region=EUR --attr number=12345\n\n# With prefix\nuuid-forge generate invoice --prefix INV-EUR --attr region=EUR --attr number=12345\n\n# Extract UUID from prefixed ID\nuuid-forge extract \"INV-EUR-550e8400-e29b-41d4-a716-446655440000\"\n\n# Validate configuration\nuuid-forge validate\n\n# Show current configuration\nuuid-forge info\n</code></pre>"},{"location":"gettting-started/quickstart/#next-steps","title":"Next Steps","text":"<p>Now that you've got the basics, explore:</p> <ul> <li>Core Concepts - Understand how it works</li> <li>Best Practices - Production guidelines</li> <li>Use Cases - Real-world examples</li> <li>API Reference - Complete documentation</li> </ul>"},{"location":"gettting-started/quickstart/#troubleshooting","title":"Troubleshooting","text":""},{"location":"gettting-started/quickstart/#issue-no-salt-configured-warning","title":"Issue: \"No salt configured\" warning","text":"<p>Solution: Set the <code>UUID_FORGE_SALT</code> environment variable or use <code>uuid-forge init</code> to create a config file.</p>"},{"location":"gettting-started/quickstart/#issue-different-uuids-on-different-machines","title":"Issue: Different UUIDs on different machines","text":"<p>Solution: Ensure all machines use the same salt and namespace configuration.</p>"},{"location":"gettting-started/quickstart/#issue-uuids-change-after-restart","title":"Issue: UUIDs change after restart","text":"<p>Solution: Verify environment variables are set correctly and persistently.</p>"},{"location":"gettting-started/quickstart/#get-help","title":"Get Help","text":"<ul> <li>GitHub Issues</li> <li>GitHub Discussions</li> <li>API Reference</li> </ul>"}]}
